<%*
// ============================================================
// ğŸ”— æ–°ç‰ˆèƒŒåè¿æ¥çº¿ç¨‹åº (èåˆå¢å¼ºç‰ˆ v2.0)
// åŠŸèƒ½ï¼šTemplaterè§¦å‘ï¼Œæ‚¬æµ®çª—å£æ˜¾ç¤ºå½“å‰æ‰“å¼€æ–‡ä»¶çš„å¼•ç”¨å…³ç³»å›¾
// ç‰¹æ€§ï¼š
//   - å®Œæ•´æ•°æ®æºï¼ˆEVA_Notes.json + EVA_Links.jsonï¼‰
//   - æ‰€å±å›¾é…è‰²åˆ†ç»„
//   - Pan & Zoom å¹³ç§»ç¼©æ”¾
//   - DOM åå¤„ç†ç‚¹å‡»ï¼ˆé¿å… Mermaid click è¯­æ³•æŠ¥é”™ï¼‰
// ============================================================

(async () => {
    // --- 0. Toggle æœºåˆ¶ ---
    const WIDGET_ID = "reference-graph-widget";
    const existing = document.getElementById(WIDGET_ID);
    if (existing) { existing.remove(); return; }

    const { Notice } = tp.obsidian;

    // --- 1. é…ç½® ---
    const CONFIG = {
        maxDepth: 7,           // æœ€å¤§å±•å¼€å±‚æ•°
        layout: "LR",          // å›¾å¸ƒå±€æ–¹å‘: LR(å·¦åˆ°å³), TB(ä¸Šåˆ°ä¸‹), RL, BT
        groupByLevel: true,    // æ˜¯å¦æŒ‰å±‚çº§åˆ†ç»„
        showStats: true,       // æ˜¯å¦æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        nodeMaxLength: 1000,   // èŠ‚ç‚¹åç§°æœ€å¤§é•¿åº¦ï¼ˆå‡ ä¹ä¸é™åˆ¶ï¼‰
        cacheEnabled: true     // æ˜¯å¦å¯ç”¨ç¼“å­˜
    };

    // --- 2. JSONæ–‡ä»¶åé…ç½® ---
    const JSON_CONFIG = {
        NOTES_JSON: "EVA_Notes.json",
        LINKS_JSON: "EVA_Links.json"
    };

    // --- 3. åŠ è½½EVA JSONæ•°æ®ï¼ˆè‡ªåŠ¨å…¨åº“æœç´¢JSONæ–‡ä»¶ï¼‰ ---
    async function loadEvaJson() {
        try {
            const allFiles = app.vault.getFiles();

            const notesFile = allFiles.find(f => f.name === JSON_CONFIG.NOTES_JSON);
            if (!notesFile) {
                throw new Error(`å…¨åº“æœªæ‰¾åˆ° ${JSON_CONFIG.NOTES_JSON}ï¼Œè¯·å…ˆè¿è¡Œ EVA JSON Builder`);
            }

            const linksFile = allFiles.find(f => f.name === JSON_CONFIG.LINKS_JSON);
            if (!linksFile) {
                throw new Error(`å…¨åº“æœªæ‰¾åˆ° ${JSON_CONFIG.LINKS_JSON}ï¼Œè¯·å…ˆè¿è¡Œ EVA JSON Builder`);
            }

            const notesContent = await app.vault.read(notesFile);
            const linksContent = await app.vault.read(linksFile);

            return {
                notes: JSON.parse(notesContent),
                links: JSON.parse(linksContent)
            };
        } catch (err) {
            new Notice(`âŒ æ— æ³•åŠ è½½EVA JSONæ–‡ä»¶: ${err.message}`, 5000);
            throw new Error(`JSONåŠ è½½å¤±è´¥: ${err.message}`);
        }
    }

    // --- 4. ä»JSONè·å–èŠ‚ç‚¹ä¿¡æ¯ ---
    function getNodeInfoFromJson(nodeId, notesJson) {
        const note = notesJson.notes[nodeId];
        if (note) {
            return {
                id: note.id,
                name: note.title,
                suoshutu: note.yaml?.ä¸Šçº§æ¡ç›® || note.yaml?.parent_atom || "",
                filePath: note.file_path
            };
        }
        return {
            id: nodeId,
            name: nodeId,
            suoshutu: "",
            filePath: ""
        };
    }

    // --- 5. å®‰å…¨åŒ–IDï¼ˆå¢å¼ºç‰ˆï¼Œæ”¯æŒæ›´å¤šç‰¹æ®Šå­—ç¬¦ï¼‰ ---
    function safeId(id) {
        // æ›¿æ¢æ‰€æœ‰éå­—æ¯æ•°å­—å­—ç¬¦ä¸ºä¸‹åˆ’çº¿ï¼Œå¹¶ç¡®ä¿ä»¥å­—æ¯å¼€å¤´
        let safe = id.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
        // å¦‚æœä»¥æ•°å­—å¼€å¤´ï¼Œæ·»åŠ å‰ç¼€
        if (/^[0-9]/.test(safe)) {
            safe = 'n_' + safe;
        }
        return safe;
    }

    // --- 6. æ–‡ä»¶ç±»å‹è¿‡æ»¤ï¼ˆåªå…è®¸ .md å’Œ .excalidrawï¼‰ ---
    function isAllowedFileType(fileNameOrPath) {
        if (!fileNameOrPath) return false;
        const lower = fileNameOrPath.toLowerCase();
        // å…è®¸ .md æ–‡ä»¶å’Œ .excalidraw æ–‡ä»¶ï¼ˆåŒ…æ‹¬ .excalidraw.mdï¼‰
        return lower.endsWith('.md') || lower.endsWith('.excalidraw');
    }

    // --- 7. æ„å»ºå¼•ç”¨å›¾ï¼ˆåŸºäºEVA JSON + å®æ—¶æ‰«æï¼‰ ---
    async function buildReferenceGraph(targetNodeId, maxDepth, targetFile) {
        new Notice("âš¡ï¸ åŠ è½½å¼•ç”¨æ•°æ®...", 2000);

        let evaData = null;
        let notesJson = { notes: {} };
        let linksJson = { adjacency: {} };

        try {
            evaData = await loadEvaJson();
            notesJson = evaData.notes;
            linksJson = evaData.links;
        } catch (e) {
            new Notice("âš ï¸ EVA JSONæœªæ‰¾åˆ°ï¼Œå°†å®æ—¶æ‰«æé“¾æ¥", 2000);
        }

        const adjacency = linksJson.adjacency || {};
        const graph = {
            nodes: [],
            edges: [],
            stats: { totalNodes: 0, totalEdges: 0, maxLevel: 0 }
        };

        const visited = new Set();
        const nodeMap = new Map();

        // è§£ææ­£æ–‡ä¸­çš„wikilinksï¼Œå¹¶ç¼“å­˜ç»“æœï¼ˆä¸¥æ ¼æ’é™¤yaml frontmatterï¼‰
        const bodyLinkCache = new Map();

        function stripYamlFrontmatter(rawContent) {
            if (!rawContent) return "";

            // å¤„ç†å¯èƒ½å­˜åœ¨çš„ BOM
            let content = rawContent.replace(/^\uFEFF/, "");

            // ä»…åœ¨æ–‡ä»¶èµ·å§‹å¤„å­˜åœ¨ frontmatter åˆ†éš”ç¬¦æ—¶å°è¯•å‰¥ç¦»
            if (!content.startsWith("---\n") && !content.startsWith("---\r\n")) {
                return content;
            }

            // åŒ¹é…æ ‡å‡† YAML frontmatterï¼ˆ--- ... --- æˆ– --- ... ...ï¼‰
            const fmMatch = content.match(/^---\s*\r?\n[\s\S]*?\r?\n(?:---|\.\.\.)\s*(?:\r?\n|$)/);
            if (!fmMatch) return content;

            return content.slice(fmMatch[0].length);
        }

        async function getBodyLinks(filePath) {
            if (bodyLinkCache.has(filePath)) {
                return bodyLinkCache.get(filePath);
            }

            const emptyResult = {
                outgoingIds: new Set(),
                outgoingPaths: new Set()
            };

            try {
                const file = app.vault.getAbstractFileByPath(filePath);
                if (!file) {
                    bodyLinkCache.set(filePath, emptyResult);
                    return emptyResult;
                }

                const rawContent = await app.vault.read(file);
                const content = stripYamlFrontmatter(rawContent);

                const outgoingIds = new Set();
                const outgoingPaths = new Set();
                const wikiRegex = /\[\[([^\]]+)\]\]/g;
                let match;

                while ((match = wikiRegex.exec(content)) !== null) {
                    let target = match[1].trim();
                    const pipeIdx = target.indexOf('|');
                    if (pipeIdx > -1) target = target.substring(0, pipeIdx).trim();
                    const hashIdx = target.indexOf('#');
                    if (hashIdx > -1) target = target.substring(0, hashIdx).trim();

                    const linkedFile = app.metadataCache.getFirstLinkpathDest(target, filePath);

                    // è¿‡æ»¤ï¼šåªå…è®¸ .md å’Œ .excalidraw æ–‡ä»¶
                    if (linkedFile && !isAllowedFileType(linkedFile.path)) {
                        continue;
                    }

                    if (linkedFile) {
                        outgoingIds.add(linkedFile.basename);
                        outgoingPaths.add(linkedFile.path);
                    } else {
                        outgoingIds.add(target.replace(/\.md$/i, '').replace(/\.excalidraw$/i, ''));
                    }
                }

                const result = { outgoingIds, outgoingPaths };
                bodyLinkCache.set(filePath, result);
                return result;
            } catch (e) {
                console.error("è§£ææ­£æ–‡é“¾æ¥é”™è¯¯:", e);
                bodyLinkCache.set(filePath, emptyResult);
                return emptyResult;
            }
        }

        // å®æ—¶æ‰«ææ–‡ä»¶é“¾æ¥çš„è¾…åŠ©å‡½æ•°ï¼ˆåªæ‰«ææ­£æ–‡ï¼Œä¸æ‰«æyamlï¼‰
        async function scanFileLinks(filePath) {
            const outgoing = [];
            const incoming = [];

            try {
                const file = app.vault.getAbstractFileByPath(filePath);
                if (!file) return { outgoing, incoming };
                const parsed = await getBodyLinks(filePath);
                parsed.outgoingIds.forEach(id => outgoing.push(id));

                // æŸ¥æ‰¾åå‘é“¾æ¥ï¼ˆå“ªäº›æ–‡ä»¶é“¾æ¥åˆ°å½“å‰æ–‡ä»¶ï¼‰
                const resolvedLinks = app.metadataCache.resolvedLinks;
                for (const [sourcePath, links] of Object.entries(resolvedLinks)) {
                    if (links[filePath]) {
                        // è¿‡æ»¤ï¼šåªå…è®¸ .md å’Œ .excalidraw æ–‡ä»¶ä½œä¸ºæ¥æº
                        if (!isAllowedFileType(sourcePath)) {
                            continue;
                        }

                        const sourceFile = app.vault.getAbstractFileByPath(sourcePath);
                        if (sourceFile) {
                            // äºŒæ¬¡æ ¡éªŒï¼šä»…å½“æ¥æºæ–‡ä»¶æ­£æ–‡ç¡®å®é“¾æ¥åˆ°å½“å‰æ–‡ä»¶ï¼Œæ‰è®¡ä¸ºå…¥é“¾
                            const sourceParsed = await getBodyLinks(sourcePath);
                            if (sourceParsed.outgoingPaths.has(filePath) || sourceParsed.outgoingIds.has(file.basename)) {
                                // ç»Ÿä¸€ä½¿ç”¨æ–‡ä»¶åŸºç¡€åä½œä¸ºIDï¼ˆä¸åŒºåˆ†æ˜¯å¦å¸¦ATOMç¼–å·ï¼‰
                                incoming.push(sourceFile.basename);
                            }
                        }
                    }
                }
            } catch (e) {
                console.error("æ‰«ææ–‡ä»¶é“¾æ¥é”™è¯¯:", e);
            }

            return { outgoing: [...new Set(outgoing)], incoming: [...new Set(incoming)] };
        }

        // BFSéå†
        const queue = [{ id: targetNodeId, level: 0, filePath: targetFile?.path }];
        visited.add(targetNodeId);

        while (queue.length > 0) {
            const { id, level, filePath } = queue.shift();

            if (level > maxDepth) continue;

            // è·å–èŠ‚ç‚¹ä¿¡æ¯ï¼šä¼˜å…ˆä»JSONï¼Œå¦åˆ™ä»æ–‡ä»¶ç³»ç»Ÿ
            let nodeInfo = getNodeInfoFromJson(id, notesJson);
            let currentFilePath = nodeInfo.filePath || filePath;

            // å¦‚æœJSONä¸­æ²¡æœ‰è¯¥èŠ‚ç‚¹ï¼Œå°è¯•ä»æ–‡ä»¶ç³»ç»Ÿè·å–ä¿¡æ¯
            if (!nodeInfo.filePath && !filePath) {
                // å°è¯•æ ¹æ®IDæ‰¾åˆ°æ–‡ä»¶ï¼ˆåŒ…æ‹¬ .md å’Œ .excalidrawï¼‰
                // IDç»Ÿä¸€æ˜¯æ–‡ä»¶åŸºç¡€åï¼Œç›´æ¥åŒ¹é…å³å¯
                const allFiles = app.vault.getFiles().filter(f => isAllowedFileType(f.path));
                const matchedFile = allFiles.find(f => f.basename === id);
                if (matchedFile) {
                    currentFilePath = matchedFile.path;
                    nodeInfo = {
                        id: id,
                        name: id,  // ç›´æ¥ä½¿ç”¨ID
                        suoshutu: "",
                        filePath: matchedFile.path
                    };
                }
            }

            // è¿‡æ»¤ï¼šå¦‚æœæ‰¾åˆ°çš„æ–‡ä»¶ä¸æ˜¯å…è®¸çš„ç±»å‹ï¼Œè·³è¿‡è¯¥èŠ‚ç‚¹
            if (currentFilePath && !isAllowedFileType(currentFilePath)) {
                continue;
            }

            const node = {
                id: id,
                name: id,  // ç›´æ¥ä½¿ç”¨IDä½œä¸ºåç§°ï¼ˆåŒ…å«ATOMç¼–å·å¦‚æœ‰ï¼‰
                suoshutu: nodeInfo.suoshutu,
                filePath: currentFilePath,
                level: level,
                isTarget: id === targetNodeId
            };

            if (!nodeMap.has(id)) {
                nodeMap.set(id, node);
                graph.nodes.push(node);
            }

            if (level > graph.stats.maxLevel) {
                graph.stats.maxLevel = level;
            }

            // è·å–é“¾æ¥ï¼šæœ‰æ–‡ä»¶è·¯å¾„æ—¶å¼ºåˆ¶å®æ—¶æ‰«ææ­£æ–‡ï¼ˆæ’é™¤yamlï¼‰ï¼›ä»…åœ¨æ— æ–‡ä»¶è·¯å¾„æ—¶å›é€€JSON
            let outgoingIds = [];
            let incomingIds = [];

            if (currentFilePath) {
                const scanned = await scanFileLinks(currentFilePath);
                outgoingIds = scanned.outgoing;
                incomingIds = scanned.incoming;
            } else {
                outgoingIds = adjacency[id]?.outgoing || [];
                incomingIds = adjacency[id]?.incoming || [];
            }

            // å‡ºé“¾
            for (const targetId of outgoingIds) {
                if (!visited.has(targetId) && level < maxDepth) {
                    visited.add(targetId);
                    queue.push({ id: targetId, level: level + 1, filePath: null });
                }
                graph.edges.push({ from: id, to: targetId, type: 'outgoing' });
            }

            // å…¥é“¾
            for (const sourceId of incomingIds) {
                if (!visited.has(sourceId) && level < maxDepth) {
                    visited.add(sourceId);
                    queue.push({ id: sourceId, level: level + 1, filePath: null });
                }
                graph.edges.push({ from: sourceId, to: id, type: 'incoming' });
            }
        }

        // å»é‡è¾¹
        const edgeSet = new Set();
        graph.edges = graph.edges.filter(edge => {
            const key = `${edge.from}|${edge.to}`;
            if (edgeSet.has(key)) return false;
            edgeSet.add(key);
            return true;
        });

        graph.stats.totalNodes = graph.nodes.length;
        graph.stats.totalEdges = graph.edges.length;

        return graph;
    }

    // --- 7. ç”ŸæˆMermaidä»£ç ï¼ˆä¸å«clickè¯­æ³•ï¼Œåç»­ç”¨DOMç»‘å®šï¼‰ ---
    function generateMermaidCode(graph) {
        let code = `flowchart ${CONFIG.layout}\n`;

        // æ ·å¼å®šä¹‰
        code += "  classDef targetNode fill:#ffeb3b,stroke:#f57f17,stroke-width:3px,color:#000\n";
        code += "  classDef level0 fill:#e3f2fd,stroke:#1976d2\n";
        code += "  classDef level1 fill:#f3e5f5,stroke:#7b1fa2\n";
        code += "  classDef level2 fill:#e8f5e9,stroke:#388e3c\n";
        code += "  classDef level3 fill:#fff3e0,stroke:#f57c00\n";
        code += "  classDef level4 fill:#fce4ec,stroke:#c2185b\n";
        code += "  classDef level5 fill:#e0f2f1,stroke:#00796b\n";

        // æ‰€å±å›¾é…è‰²
        const suoshutuColors = [
            "fill:#e1f5fe,stroke:#0288d1",
            "fill:#fce4ec,stroke:#c2185b",
            "fill:#f1f8e9,stroke:#689f38",
            "fill:#fff8e1,stroke:#ffa000",
            "fill:#ede7f6,stroke:#512da8",
            "fill:#e0f2f1,stroke:#00796b",
            "fill:#fff3e0,stroke:#e65100",
            "fill:#f3e5f5,stroke:#6a1b9a"
        ];

        const suoshutuList = [...new Set(graph.nodes.map(n => n.suoshutu).filter(s => s))];
        const suoshutu2Class = {};
        suoshutuList.forEach((s, i) => {
            const className = `suoshutu${i}`;
            code += `  classDef ${className} ${suoshutuColors[i % suoshutuColors.length]}\n`;
            suoshutu2Class[s] = className;
        });

        // æˆªæ–­åç§°
        function truncateName(name) {
            if (!name) return "æœªå‘½å";
            // æ›¿æ¢å¼•å·é˜²æ­¢è¯­æ³•é”™è¯¯
            let clean = name.replace(/"/g, "'");
            if (clean.length > CONFIG.nodeMaxLength) {
                return clean.substring(0, CONFIG.nodeMaxLength) + "...";
            }
            return clean;
        }

        // æ„å»º safeId -> filePath æ˜ å°„ï¼ˆç”¨äºåç»­DOMç»‘å®šç‚¹å‡»ï¼‰
        const nodeDataMap = {};

        // æŒ‰å±‚çº§åˆ†ç»„
        if (CONFIG.groupByLevel) {
            for (let level = 0; level <= graph.stats.maxLevel; level++) {
                const levelNodes = graph.nodes.filter(node => node.level === level);
                if (levelNodes.length > 0) {
                    code += `  subgraph level${level}["ç¬¬ ${level} å±‚ (${levelNodes.length} ä¸ªèŠ‚ç‚¹)"]\n`;
                    code += `    direction TB\n`;

                    for (const node of levelNodes) {
                        const sid = safeId(node.id);
                        nodeDataMap[sid] = { filePath: node.filePath, name: node.name, id: node.id };
                        const displayName = truncateName(node.name);
                        code += `    ${sid}("${displayName}")\n`;
                    }

                    code += "  end\n";
                }
            }
        } else {
            for (const node of graph.nodes) {
                const sid = safeId(node.id);
                nodeDataMap[sid] = { filePath: node.filePath, name: node.name, id: node.id };
                const displayName = truncateName(node.name);
                code += `  ${sid}("${displayName}")\n`;
            }
        }

        // æ·»åŠ è¾¹
        for (const edge of graph.edges) {
            const fromSid = safeId(edge.from);
            const toSid = safeId(edge.to);
            const fromExists = graph.nodes.some(n => n.id === edge.from);
            const toExists = graph.nodes.some(n => n.id === edge.to);
            if (fromExists && toExists) {
                code += `  ${fromSid} --> ${toSid}\n`;
            }
        }

        // åº”ç”¨æ ·å¼
        for (const node of graph.nodes) {
            const sid = safeId(node.id);
            if (node.isTarget) {
                code += `  class ${sid} targetNode\n`;
            } else if (node.suoshutu && suoshutu2Class[node.suoshutu]) {
                code += `  class ${sid} ${suoshutu2Class[node.suoshutu]}\n`;
            } else {
                const levelClass = `level${Math.min(node.level, 5)}`;
                code += `  class ${sid} ${levelClass}\n`;
            }
        }

        return { code, nodeDataMap };
    }

    // --- 8. è·å–å½“å‰æ‰“å¼€çš„æ–‡ä»¶ ---
    const activeFile = app.workspace.getActiveFile();
    if (!activeFile) {
        new Notice("âŒ è¯·å…ˆæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼", 3000);
        return;
    }

    // æå–èŠ‚ç‚¹IDï¼šç»Ÿä¸€ä½¿ç”¨æ–‡ä»¶åŸºç¡€åï¼ˆä¸å¸¦æ‰©å±•åï¼‰ä½œä¸ºIDï¼Œä¸åŒºåˆ†æ˜¯å¦æœ‰ATOMç¼–å·
    function extractNodeId(file) {
        // ç›´æ¥è¿”å›æ–‡ä»¶åŸºç¡€åï¼ˆåŒ…å«ATOMç¼–å·å¦‚æœ‰ï¼‰
        return file.basename;
    }

    const targetNodeId = extractNodeId(activeFile);

    // é¢„åŠ è½½è·å–ç›®æ ‡èŠ‚ç‚¹åç§°
    let targetNodeName = activeFile.basename;
    try {
        const evaData = await loadEvaJson();
        // å°è¯•ç”¨ATOM IDæŸ¥æ‰¾
        let noteInfo = evaData.notes.notes[targetNodeId];
        // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•éå†æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶è·¯å¾„
        if (!noteInfo) {
            for (const [id, note] of Object.entries(evaData.notes.notes)) {
                if (note.file_path === activeFile.path || note.file_name === activeFile.name) {
                    noteInfo = note;
                    break;
                }
            }
        }
        if (noteInfo) {
            targetNodeName = noteInfo.title || activeFile.basename;
        }
    } catch (e) {
        // ä½¿ç”¨æ–‡ä»¶å
    }

    // --- 9. æ„å»ºWidget ---
    const widget = document.createElement("div");
    widget.id = WIDGET_ID;
    widget.style.cssText = `
        position: fixed;
        top: 50px;
        right: 30px;
        width: 800px;
        height: 85vh;
        max-height: 950px;
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        border-radius: 12px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        font-family: var(--font-text);
        animation: fadeIn 0.3s ease;
    `;

    const styleTag = document.createElement("style");
    styleTag.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #${WIDGET_ID} .ref-header {
            padding: 12px 16px;
            background: var(--background-secondary);
            border-bottom: 1px solid var(--background-modifier-border);
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            flex-shrink: 0;
            z-index: 10;
        }

        #${WIDGET_ID} .ref-header-title {
            font-weight: 600;
            font-size: 14px;
        }

        #${WIDGET_ID} .ref-header-btns {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        #${WIDGET_ID} .ref-btn {
            padding: 4px 10px;
            background: var(--interactive-accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        #${WIDGET_ID} .ref-btn:hover {
            filter: brightness(1.1);
        }

        #${WIDGET_ID} .ref-close {
            cursor: pointer;
            padding: 0 8px;
            color: var(--text-muted);
            font-size: 18px;
            font-weight: bold;
        }

        #${WIDGET_ID} .ref-close:hover {
            color: var(--text-error) !important;
        }

        #${WIDGET_ID} .ref-stats {
            padding: 8px 16px;
            background: var(--background-primary-alt);
            border-bottom: 1px solid var(--background-modifier-border);
            font-size: 12px;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        #${WIDGET_ID} .ref-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: var(--background-primary);
            cursor: grab;
        }

        #${WIDGET_ID} .ref-content:active {
            cursor: grabbing;
        }

        #${WIDGET_ID} .ref-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
        }

        #${WIDGET_ID} .mermaid {
            width: 100%;
            height: 100%;
        }

        #${WIDGET_ID} .mermaid svg {
            width: 100%;
            height: 100%;
        }

        #${WIDGET_ID} .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }

        #${WIDGET_ID} .zoom-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: var(--text-normal);
        }

        #${WIDGET_ID} .zoom-btn:hover {
            background: var(--background-modifier-hover);
        }

        /* å¼ºåˆ¶èŠ‚ç‚¹å¯ç‚¹å‡»æ ·å¼ */
        #${WIDGET_ID} .node {
            cursor: pointer !important;
        }

        #${WIDGET_ID} .node:hover {
            filter: brightness(0.9);
        }
    `;
    widget.appendChild(styleTag);

    // Header
    const header = document.createElement("div");
    header.className = "ref-header";

    const headerTitle = document.createElement("span");
    headerTitle.className = "ref-header-title";
    headerTitle.textContent = `ğŸ”— å¼•ç”¨å…³ç³»å›¾: ${targetNodeName}`;
    header.appendChild(headerTitle);

    const headerBtns = document.createElement("div");
    headerBtns.className = "ref-header-btns";

    const refreshBtn = document.createElement("button");
    refreshBtn.className = "ref-btn";
    refreshBtn.textContent = "ğŸ”„ åˆ·æ–°";
    refreshBtn.onclick = async () => {
        new Notice("è¯·å…³é—­åé‡æ–°è§¦å‘ä»¥åˆ·æ–°æ•°æ®", 2000);
        widget.remove();
    };
    headerBtns.appendChild(refreshBtn);

    const closeBtn = document.createElement("div");
    closeBtn.className = "ref-close";
    closeBtn.innerHTML = "âœ•";
    closeBtn.onclick = () => widget.remove();
    headerBtns.appendChild(closeBtn);

    header.appendChild(headerBtns);
    widget.appendChild(header);

    // StatsåŒºåŸŸ
    const statsDiv = document.createElement("div");
    statsDiv.className = "ref-stats";
    statsDiv.innerHTML = `<span>ç›®æ ‡èŠ‚ç‚¹: <b>${targetNodeId}</b> | æœ€å¤§æ·±åº¦: ${CONFIG.maxDepth} | å¸ƒå±€: ${CONFIG.layout} | <i>æ»šè½®ç¼©æ”¾ / æ‹–æ‹½å¹³ç§» / ç‚¹å‡»è·³è½¬</i></span>`;
    widget.appendChild(statsDiv);

    // å†…å®¹åŒºåŸŸ
    const contentDiv = document.createElement("div");
    contentDiv.className = "ref-content";
    contentDiv.innerHTML = '<div class="ref-loading">â³ æ­£åœ¨æ„å»ºå¼•ç”¨å…³ç³»å›¾...</div>';
    widget.appendChild(contentDiv);

    // ç¼©æ”¾æ§ä»¶
    const zoomControls = document.createElement("div");
    zoomControls.className = "zoom-controls";
    zoomControls.innerHTML = `
        <div class="zoom-btn" id="z-out">âˆ’</div>
        <div class="zoom-btn" id="z-reset">R</div>
        <div class="zoom-btn" id="z-in">+</div>
    `;
    widget.appendChild(zoomControls);

    // çª—å£æ‹–æ‹½åŠŸèƒ½
    let isDragging = false, dragX = 0, dragY = 0;
    header.onmousedown = (e) => {
        if (e.target === closeBtn || e.target === refreshBtn) return;
        isDragging = true;
        const rect = widget.getBoundingClientRect();
        dragX = e.clientX - rect.left;
        dragY = e.clientY - rect.top;
        widget.style.right = "auto";
        widget.style.left = rect.left + "px";
        widget.style.top = rect.top + "px";
        document.addEventListener('mousemove', onWidgetMove);
        document.addEventListener('mouseup', onWidgetUp);
        e.preventDefault();
    };

    const onWidgetMove = (e) => {
        if (!isDragging) return;
        widget.style.left = (e.clientX - dragX) + "px";
        widget.style.top = (e.clientY - dragY) + "px";
    };

    const onWidgetUp = () => {
        isDragging = false;
        document.removeEventListener('mousemove', onWidgetMove);
        document.removeEventListener('mouseup', onWidgetUp);
    };

    // æ·»åŠ åˆ°é¡µé¢
    document.body.appendChild(widget);

    // --- 10. å¼‚æ­¥æ„å»ºå›¾ ---
    try {
        const graph = await buildReferenceGraph(targetNodeId, CONFIG.maxDepth, activeFile);

        // æ›´æ–°ç»Ÿè®¡
        statsDiv.innerHTML = `
            <span>ç›®æ ‡: <b>${targetNodeId}</b></span> |
            <span>èŠ‚ç‚¹: <b>${graph.stats.totalNodes}</b></span> |
            <span>è¾¹: <b>${graph.stats.totalEdges}</b></span> |
            <span>å±‚æ•°: <b>${graph.stats.maxLevel + 1}</b></span> |
            <i style="color:var(--text-faint)">æ»šè½®ç¼©æ”¾ / æ‹–æ‹½å¹³ç§» / ç‚¹å‡»è·³è½¬</i>
        `;

        if (graph.nodes.length === 0) {
            contentDiv.innerHTML = '<div class="ref-loading">âš ï¸ æœªæ‰¾åˆ°ç›¸å…³å¼•ç”¨å…³ç³»ï¼ˆå­¤å²›èŠ‚ç‚¹ï¼‰</div>';
            return;
        }

        // ç”ŸæˆMermaidä»£ç 
        const { code, nodeDataMap } = generateMermaidCode(graph);

        // æ¸…ç©ºåŠ è½½æç¤º
        contentDiv.innerHTML = '';

        // æ¸²æŸ“Mermaid
        const mermaidDiv = document.createElement("div");
        mermaidDiv.className = "mermaid";
        mermaidDiv.textContent = code;
        contentDiv.appendChild(mermaidDiv);

        // å…¼å®¹å¤šç‰ˆæœ¬ Mermaid API
        const mermaidAPI = window.mermaid;
        if (mermaidAPI) {
            try {
                // Mermaid v10+ ä½¿ç”¨ run() æ–¹æ³•
                if (typeof mermaidAPI.run === 'function') {
                    await mermaidAPI.run({ nodes: [mermaidDiv] });
                }
                // Mermaid v9.x åŠæ›´æ—©ç‰ˆæœ¬ä½¿ç”¨ init()
                else if (typeof mermaidAPI.init === 'function') {
                    await mermaidAPI.init(undefined, mermaidDiv);
                }
                // å¤‡ç”¨ï¼šå°è¯• render() æ–¹æ³•
                else if (typeof mermaidAPI.render === 'function') {
                    const uniqueId = 'mermaid-' + Date.now();
                    const { svg } = await mermaidAPI.render(uniqueId, code);
                    mermaidDiv.innerHTML = svg;
                }
            } catch (mermaidErr) {
                console.error("Mermaid æ¸²æŸ“é”™è¯¯:", mermaidErr);
                // å¦‚æœæ¸²æŸ“å¤±è´¥ï¼Œå°è¯•é‡æ–°åˆå§‹åŒ–
                try {
                    mermaidAPI.initialize({ startOnLoad: false, securityLevel: 'loose' });
                    if (typeof mermaidAPI.run === 'function') {
                        await mermaidAPI.run({ nodes: [mermaidDiv] });
                    } else if (typeof mermaidAPI.init === 'function') {
                        await mermaidAPI.init(undefined, mermaidDiv);
                    }
                } catch (retryErr) {
                    console.error("Mermaid é‡è¯•å¤±è´¥:", retryErr);
                    throw retryErr;
                }
            }

            // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿æ¸²æŸ“å®Œæˆ
            await new Promise(resolve => setTimeout(resolve, 100));

            const svg = mermaidDiv.querySelector("svg");
            if (!svg) {
                // SVGæœªç”Ÿæˆï¼Œæ˜¾ç¤ºè¯Šæ–­ä¿¡æ¯
                console.warn("Mermaid è°ƒç”¨æˆåŠŸä½†æœªç”Ÿæˆ SVG");
                new Notice("âš ï¸ Mermaid æ¸²æŸ“å¼‚å¸¸ï¼Œæœªç”Ÿæˆå›¾å½¢", 3000);
                mermaidDiv.innerHTML = `
                    <div style="padding:10px;background:rgba(255,100,0,0.1);border-radius:4px;margin-bottom:10px;">
                        <p style="margin:0;color:var(--text-error);">âš ï¸ Mermaid æ¸²æŸ“å¼‚å¸¸</p>
                        <p style="margin:5px 0 0;font-size:11px;color:var(--text-muted);">Mermaid API å·²è°ƒç”¨ä½†æœªç”Ÿæˆ SVGã€‚å¯èƒ½æ˜¯è¯­æ³•é”™è¯¯æˆ–ç‰ˆæœ¬ä¸å…¼å®¹ã€‚</p>
                    </div>
                    <pre style="font-size:11px;overflow:auto;padding:10px;background:var(--background-secondary);border-radius:4px;max-height:400px;">${code}</pre>
                `;
                return;
            }

            // SVG æ¸²æŸ“æˆåŠŸï¼Œè®¾ç½®æ ·å¼
            svg.style.width = "100%";
            svg.style.height = "100%";
            svg.removeAttribute("maxWidth");

            // --- Pan & Zoom å®ç° ---
            let scale = 1, pX = 0, pY = 0;
            const g = svg.querySelector("g");

            const updateTransform = () => {
                if (!g) return;
                g.style.transform = `translate(${pX}px, ${pY}px) scale(${scale})`;
                g.style.transformOrigin = "0 0";
                g.style.transition = "transform 0.1s ease-out";
            };

            // æ»šè½®ç¼©æ”¾
            contentDiv.onwheel = (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                scale *= delta;
                scale = Math.min(Math.max(0.1, scale), 10);
                updateTransform();
            };

            // æ‹–æ‹½å¹³ç§»
            let isPan = false, startX = 0, startY = 0;
            contentDiv.onmousedown = (e) => {
                if (e.button !== 0) return;
                isPan = true;
                startX = e.clientX - pX;
                startY = e.clientY - pY;
                contentDiv.style.cursor = "grabbing";
            };
            contentDiv.onmousemove = (e) => {
                if (!isPan) return;
                pX = e.clientX - startX;
                pY = e.clientY - startY;
                if (g) {
                    g.style.transition = "none";
                    g.style.transform = `translate(${pX}px, ${pY}px) scale(${scale})`;
                }
            };
            contentDiv.onmouseup = () => { isPan = false; contentDiv.style.cursor = "grab"; };
            contentDiv.onmouseleave = () => { isPan = false; };

            // ç¼©æ”¾æŒ‰é’®
            widget.querySelector("#z-in").onclick = () => { scale *= 1.2; updateTransform(); };
            widget.querySelector("#z-out").onclick = () => { scale /= 1.2; updateTransform(); };
            widget.querySelector("#z-reset").onclick = () => { scale = 1; pX = 0; pY = 0; updateTransform(); };

            // --- DOM åå¤„ç†ï¼šç»‘å®šèŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶ ---
            const nodes = svg.querySelectorAll(".node");
            nodes.forEach(node => {
                // Mermaid ç”Ÿæˆçš„èŠ‚ç‚¹ id æ ¼å¼å¦‚ "flowchart-ATOM_121_001-123"
                // æˆ‘ä»¬éœ€è¦ä»ä¸­åŒ¹é…å‡º safeId
                const nodeId = node.id;

                // éå† nodeDataMap æ‰¾åŒ¹é…çš„ safeId
                let matchedData = null;
                for (const [sid, data] of Object.entries(nodeDataMap)) {
                    // æ£€æŸ¥èŠ‚ç‚¹idæ˜¯å¦åŒ…å«æˆ‘ä»¬çš„safeId
                    if (nodeId.includes(sid + "-") || nodeId.includes("-" + sid + "-") || nodeId.endsWith("-" + sid)) {
                        matchedData = data;
                        break;
                    }
                    // æ›´å®½æ¾çš„åŒ¹é…ï¼šæ£€æŸ¥æ˜¯å¦åŒ…å«safeId
                    if (nodeId.includes(sid)) {
                        matchedData = data;
                        break;
                    }
                }

                if (matchedData && matchedData.filePath) {
                    node.style.cursor = "pointer";

                    node.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // æ‰“å¼€å¯¹åº”ç¬”è®°
                        app.workspace.openLinkText(matchedData.filePath, "", false);
                        new Notice(`ğŸ“„ æ‰“å¼€: ${matchedData.name}`, 2000);
                    };

                    // æ·»åŠ æ‚¬åœæç¤º
                    const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title.textContent = `ç‚¹å‡»æ‰“å¼€: ${matchedData.name}\n${matchedData.filePath}`;
                    node.appendChild(title);
                }
            });
        } else {
            // é™çº§ï¼šæ˜¾ç¤ºä»£ç  + è¯Šæ–­ä¿¡æ¯
            console.warn("Mermaid ä¸å¯ç”¨ï¼Œæ˜¾ç¤ºåŸå§‹ä»£ç ");
            new Notice("âš ï¸ Mermaid æ¸²æŸ“åº“æœªåŠ è½½ï¼Œæ˜¾ç¤ºåŸå§‹ä»£ç ", 3000);
            mermaidDiv.innerHTML = `
                <div style="padding:10px;background:rgba(255,200,0,0.1);border-radius:4px;margin-bottom:10px;">
                    <p style="margin:0;color:var(--text-warning);">âš ï¸ Mermaid æ¸²æŸ“åº“æœªåŠ è½½</p>
                    <p style="margin:5px 0 0;font-size:11px;color:var(--text-muted);">è¯·ç¡®ä¿ Obsidian å·²å¯ç”¨ Mermaid æ”¯æŒï¼Œæˆ–å®‰è£…ç›¸å…³æ’ä»¶</p>
                </div>
                <pre style="font-size:12px;overflow:auto;padding:10px;background:var(--background-secondary);border-radius:4px;">${code}</pre>
            `;
        }

        new Notice(`âœ… å¼•ç”¨å›¾åŠ è½½å®Œæˆ: ${graph.stats.totalNodes}èŠ‚ç‚¹, ${graph.stats.totalEdges}è¾¹`, 3000);

    } catch (err) {
        contentDiv.innerHTML = `<div style="color:red;padding:20px;">
            <p>âŒ æ„å»ºå¤±è´¥: ${err.message}</p>
            <pre style="font-size:11px;overflow:auto;">${err.stack}</pre>
        </div>`;
        new Notice(`âŒ å¼•ç”¨å›¾æ„å»ºå¤±è´¥: ${err.message}`, 5000);
    }

})();
%>
