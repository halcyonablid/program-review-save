<%*
(async () => {
    const { Notice } = tp.obsidian;

    const WIDGET_ID = "eva-tree-widget-templater";
    const STYLE_ID = "eva-tree-widget-style-templater";
    const JSON_FILENAME = "EVA_Notes.json";
    const FILE_PREFIX_FILTER = "ATOM@";
    const START_LEVEL = 1;
    const ONLY_CURRENT_BRANCH = true; // true=ÂΩìÂâçÁ¨îËÆ∞‰∏ªÂàÜÊîØÔºõfalse=ÂÖ®Â∫ì
    const RENDER_WINDOW = 200; // ‰ªÖÊ∏≤ÊüìÂΩìÂâçÊù°ÁõÆÂâçÂêéÂêÑ 200 Êù°
    const INITIAL_TOP_PX = 72;

    const existing = document.getElementById(WIDGET_ID);
    if (existing) {
        if (existing.cleanup) existing.cleanup();
        existing.remove();
        return;
    }

    function normalizeName(name) {
        return String(name || "").replace(/\.md$/i, "").trim();
    }

    function getHierarchyCode(fileName) {
        const name = normalizeName(fileName);
        const atIndex = name.indexOf("@");
        if (atIndex === -1) return null;
        const dashIndex = name.indexOf("-", atIndex);
        if (dashIndex === -1) return null;
        return name.substring(atIndex + 1, dashIndex).trim();
    }

    function processKeywords(text) {
        const patterns = [
            { regex: /¬∑¬∑(.+?)¬∑¬∑/g, className: "keyword-highlight", marker: "¬∑¬∑" },
            { regex: /\+\+(.+?)\+\+/g, className: "emphasis-highlight", marker: "++" }
        ];

        const hasMarkers = patterns.some(p => text.includes(p.marker));
        if (!hasMarkers) return document.createTextNode(text);

        const fragment = document.createDocumentFragment();
        let segments = [{ text, type: "normal" }];

        patterns.forEach(pattern => {
            const newSegments = [];
            segments.forEach(segment => {
                if (segment.type !== "normal") {
                    newSegments.push(segment);
                    return;
                }

                let lastIndex = 0;
                let match;
                const regex = new RegExp(pattern.regex.source, "g");
                while ((match = regex.exec(segment.text)) !== null) {
                    if (match.index > lastIndex) {
                        newSegments.push({ text: segment.text.substring(lastIndex, match.index), type: "normal" });
                    }

                    let keyword = match[1];
                    if (keyword && /[A-Z]/.test(keyword.charAt(0))) {
                        keyword = keyword.substring(1);
                    }
                    newSegments.push({ text: keyword, type: pattern.className });
                    lastIndex = regex.lastIndex;
                }

                if (lastIndex < segment.text.length) {
                    newSegments.push({ text: segment.text.substring(lastIndex), type: "normal" });
                }
            });
            segments = newSegments;
        });

        segments.forEach(segment => {
            if (segment.type === "normal") {
                fragment.appendChild(document.createTextNode(segment.text));
            } else {
                const span = document.createElement("span");
                span.className = segment.type;
                span.textContent = segment.text;
                fragment.appendChild(span);
            }
        });
        return fragment;
    }

    const activeFile = app.workspace.getActiveFile();
    if (!activeFile) {
        new Notice("‚ùå Êú™ÊâæÂà∞ÂΩìÂâçÁ¨îËÆ∞");
        return;
    }
    const activeName = normalizeName(activeFile.basename || activeFile.name);
    const activeCode = getHierarchyCode(activeName);
    const branchRoot = activeCode ? activeCode.split(".")[0] : null;

    let pages = [];
    let maxExistingLevel = 1;
    let mermaidStartCount = 0;
    let mermaidHiddenCount = 0;
    let parentHierarchyCodes = new Set();
    const foldedNodes = new Set();
    const viewState = {
        maxLevel: 20,
        highlightLevel: 0,
        highlightSubLevels: false,
        currentHighlightedFile: activeName
    };

    const widget = document.createElement("div");
    widget.id = WIDGET_ID;
    widget.style.cssText = `
        position: fixed;
        top: ${INITIAL_TOP_PX}px;
        left: 20px;
        width: min(920px, calc(100vw - 40px));
        height: 90vh;
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
        box-shadow: 0 8px 30px rgba(0,0,0,0.4);
        border-radius: 8px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        font-family: var(--font-text);
    `;

    const styleEl = document.createElement("style");
    styleEl.id = STYLE_ID;
    styleEl.textContent = `
        #${WIDGET_ID} .eva-header { padding: 8px 12px; background: var(--background-secondary); border-bottom: 1px solid var(--background-modifier-border); cursor: move; display: flex; justify-content: space-between; align-items: center; user-select: none; flex-shrink: 0; }
        #${WIDGET_ID} .eva-header-title { font-weight: 600; }
        #${WIDGET_ID} .eva-header-action { cursor: pointer; padding: 0 7px; color: var(--text-muted); }
        #${WIDGET_ID} .eva-header-action:hover { color: var(--text-accent); }
        #${WIDGET_ID} .eva-close:hover { color: var(--text-error); }
        #${WIDGET_ID} .eva-body { flex: 1; overflow: auto; padding: 10px 12px 14px; }
        #${WIDGET_ID} .tree-control-info { margin-bottom: 8px; font-style: italic; color: var(--text-muted); font-size: 13px; line-height: 1.4; }
        #${WIDGET_ID} .tree-level-info { margin-bottom: 12px; font-weight: bold; color: var(--text-accent); font-size: 14px; }
        #${WIDGET_ID} .hierarchical-tree-structure { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace !important; white-space: nowrap; overflow-x: auto; line-height: 1.6; font-size: 14px; padding: 6px 0; }
        #${WIDGET_ID} .tree-item { display: flex; align-items: center; margin-bottom: 5px; padding: 3px 5px; border-radius: 3px; }
        #${WIDGET_ID} .tree-item-link { cursor: pointer; transition: background-color 0.15s ease; }
        #${WIDGET_ID} .tree-item-link:hover { background-color: var(--background-secondary); }
        #${WIDGET_ID} .tree-prefix { color: var(--text-faint); white-space: pre; }
        #${WIDGET_ID} .fold-button, #${WIDGET_ID} .fold-placeholder { display: inline-block; width: 1.5em; text-align: center; flex-shrink: 0; user-select: none; }
        #${WIDGET_ID} .fold-button { cursor: pointer; color: var(--text-accent); font-weight: bold; }
        #${WIDGET_ID} .fold-button:hover { color: var(--text-accent-hover); }
        #${WIDGET_ID} .tree-item-highlighted { background-color: rgba(255, 165, 0, 0.3); font-weight: bold; }
        #${WIDGET_ID} .tree-item-subhighlighted { background-color: rgba(255, 165, 0, 0.12); }
        #${WIDGET_ID} .tree-item-current { background-color: rgba(75, 192, 192, 0.3); font-weight: bold; border-left: 3px solid rgba(75, 192, 192, 0.8); }
        #${WIDGET_ID} .supermemo-entry { outline: 1.5px dashed #FF4500; outline-offset: -2px; }
        #${WIDGET_ID} .mermaid-start-entry { background-color: rgba(46, 204, 113, 0.16); border-left: 3px solid rgba(39, 174, 96, 0.9); }
        #${WIDGET_ID} .mermaid-start-badge { margin-left: 8px; padding: 1px 6px; border-radius: 999px; font-size: 11px; line-height: 1.4; font-weight: 600; color: var(--text-normal); background: rgba(46, 204, 113, 0.22); border: 1px solid rgba(39, 174, 96, 0.45); }
        #${WIDGET_ID} .keyword-highlight { color: #e74c3c; font-weight: bold; }
        #${WIDGET_ID} .emphasis-highlight { color: #8e44ad; font-weight: bold; text-decoration: underline; text-decoration-color: #9b59b6; text-decoration-thickness: 1.5px; }
    `;
    document.head.appendChild(styleEl);

    const header = document.createElement("div");
    header.className = "eva-header";
    const title = document.createElement("span");
    title.className = "eva-header-title";
    title.textContent = `üå≥ EVA Ê†ëÁä∂Âõæ${ONLY_CURRENT_BRANCH && branchRoot ? `Ôºà‰∏ªÂàÜÊîØ ${branchRoot}Ôºâ` : "ÔºàÂÖ®Â∫ìÔºâ"}`;

    const actions = document.createElement("div");
    actions.style.cssText = "display:flex; align-items:center; gap:6px;";
    const refreshBtn = document.createElement("span");
    refreshBtn.className = "eva-header-action";
    refreshBtn.textContent = "‚ü≥";
    const closeBtn = document.createElement("span");
    closeBtn.className = "eva-header-action eva-close";
    closeBtn.textContent = "‚úï";

    actions.appendChild(refreshBtn);
    actions.appendChild(closeBtn);
    header.appendChild(title);
    header.appendChild(actions);
    widget.appendChild(header);

    const body = document.createElement("div");
    body.className = "eva-body";
    const controlInfo = document.createElement("div");
    controlInfo.className = "tree-control-info";
    controlInfo.innerHTML = "<b>‰∫§‰∫í:</b> [ÂçïÂáª]ÊâìÂºÄÁ¨îËÆ∞, [Âè≥ÈîÆ]È´ò‰∫ÆÂêåÁ∫ß, [‚ñ∂/‚ñº]ÊäòÂè†/Â±ïÂºÄ<br><b>Âø´Êç∑ÈîÆ:</b> [J/K]Â¢ûÂáèÂ±ÇÁ∫ß, [N/M]È´ò‰∫ÆÂ±ÇÁ∫ß<br><b>Mermaid:</b> Ëµ∑ÁÇπÊòæÁ§∫ÁªøËâ≤Ê†áÁ≠æÔºåËµ∑ÁÇπÂêéÁöÑÊ†ëËäÇÁÇπËá™Âä®Êî∂Á∫≥";
    const levelInfo = document.createElement("div");
    levelInfo.className = "tree-level-info";
    const container = document.createElement("div");
    container.className = "hierarchical-tree-structure";
    body.appendChild(controlInfo);
    body.appendChild(levelInfo);
    body.appendChild(container);
    widget.appendChild(body);

    function precomputeParentNodes() {
        parentHierarchyCodes = new Set();
        pages.forEach(page => {
            const code = getHierarchyCode(page.file_name);
            if (!code) return;
            const parts = code.split(".");
            for (let i = 1; i < parts.length; i++) {
                parentHierarchyCodes.add(parts.slice(0, i).join("."));
            }
        });
    }

    function isAncestorFolded(hierarchyCode) {
        if (!hierarchyCode) return false;
        const parts = hierarchyCode.split(".");
        for (let i = 1; i < parts.length; i++) {
            const ancestor = parts.slice(0, i).join(".");
            if (foldedNodes.has(ancestor)) return true;
        }
        return false;
    }

    function getCurrentMaxVisibleLevel() {
        return Math.min(viewState.maxLevel, Math.max(maxExistingLevel, 1));
    }

    function isDescendantCode(code, ancestorCode) {
        if (!code || !ancestorCode || code === ancestorCode) return false;
        return code.startsWith(`${ancestorCode}.`);
    }

    function isMermaidStart(note) {
        return note?.yaml?.["mermaidÂõæ‰πãËµ∑Âßã"] === true || note?.computed?.mermaid?.is_start === true;
    }

    function resolveMermaidHidden(note, mermaidStartCodes) {
        if (isMermaidStart(note)) return false;
        const computedHidden = note?.computed?.mermaid?.hide_in_tree;
        if (typeof computedHidden === "boolean") return computedHidden;

        const code = getHierarchyCode(note?.file_name);
        if (!code) return false;
        return mermaidStartCodes.some(startCode => isDescendantCode(code, startCode));
    }

    function getCurrentPageIndex() {
        const currentPath = String(activeFile.path || "");
        const byPath = pages.findIndex(page => String(page.file_path || "") === currentPath);
        if (byPath >= 0) return byPath;
        const byName = pages.findIndex(page => normalizeName(page.file_name) === activeName);
        if (byName >= 0) return byName;

        // ÂΩìÂâçÁ¨îËÆ∞Ë¢´ Mermaid Êî∂Á∫≥Êó∂ÔºåÂ∞ΩÈáèÂÆö‰ΩçÂà∞ÊúÄËøëÂèØËßÅÁ•ñÂÖà„ÄÇ
        if (activeCode) {
            const parts = activeCode.split(".");
            while (parts.length > 1) {
                parts.pop();
                const ancestorCode = parts.join(".");
                const idx = pages.findIndex(page => getHierarchyCode(page.file_name) === ancestorCode);
                if (idx >= 0) return idx;
            }
        }

        return 0;
    }

    function centerCurrentRow() {
        const currentRow = container.querySelector(".tree-item-current");
        if (!currentRow) return;
        const bodyRect = body.getBoundingClientRect();
        const rowRect = currentRow.getBoundingClientRect();
        const rowTopInBody = rowRect.top - bodyRect.top + body.scrollTop;
        const target = Math.max(rowTopInBody - body.clientHeight / 2 + rowRect.height / 2, 0);
        body.scrollTop = target;
    }

    function renderTree(options = {}) {
        const { centerCurrent = false } = options;
        container.innerHTML = "";
        const currentIndex = getCurrentPageIndex();
        const start = Math.max(0, currentIndex - RENDER_WINDOW);
        const end = Math.min(pages.length, currentIndex + RENDER_WINDOW + 1);
        const visiblePages = pages.slice(start, end);
        levelInfo.innerHTML = `ÂΩìÂâçÂ±ÇÁ∫ß: ${getCurrentMaxVisibleLevel()}/${Math.max(maxExistingLevel, 1)} | ÊòæÁ§∫: ${visiblePages.length}/${pages.length} | MermaidËµ∑ÁÇπ: ${mermaidStartCount} | MermaidÊî∂Á∫≥: ${mermaidHiddenCount}${viewState.highlightLevel > 0 ? ` | È´ò‰∫Æ: ${viewState.highlightLevel}${viewState.highlightSubLevels ? " (Âê´‰∏ãÁ∫ß)" : ""}` : ""}`;

        visiblePages.forEach((page, offset) => {
            const absoluteIndex = start + offset;
            const fileName = normalizeName(page.file_name);
            const filePath = page.file_path || `${fileName}.md`;
            const hierarchyCode = getHierarchyCode(fileName);
            if (!hierarchyCode) return;
            const isMermaidStartEntry = isMermaidStart(page);

            const levelDepth = Math.max(0, hierarchyCode.split(".").length - (START_LEVEL - 1));
            if (levelDepth <= 0 || levelDepth > viewState.maxLevel || isAncestorFolded(hierarchyCode)) return;

            const row = document.createElement("div");
            row.className = "tree-item tree-item-link";

            if (page?.yaml?.["Ê†ëÁä∂ÂõæÂàíÈáçÁÇπ"] === true) row.classList.add("supermemo-entry");
            if (isMermaidStartEntry) row.classList.add("mermaid-start-entry");
            if (viewState.highlightLevel > 0) {
                if (levelDepth === viewState.highlightLevel) row.classList.add("tree-item-highlighted");
                else if (viewState.highlightSubLevels && levelDepth > viewState.highlightLevel) row.classList.add("tree-item-subhighlighted");
            }
            if (absoluteIndex === currentIndex) row.classList.add("tree-item-current");

            const foldControl = document.createElement("span");
            if (parentHierarchyCodes.has(hierarchyCode)) {
                foldControl.className = "fold-button";
                foldControl.textContent = foldedNodes.has(hierarchyCode) ? "‚ñ∂" : "‚ñº";
                foldControl.onclick = (event) => {
                    event.stopPropagation();
                    if (foldedNodes.has(hierarchyCode)) foldedNodes.delete(hierarchyCode);
                    else foldedNodes.add(hierarchyCode);
                    renderTree();
                };
            } else {
                foldControl.className = "fold-placeholder";
                foldControl.innerHTML = "&nbsp;";
            }
            row.appendChild(foldControl);

            const prefix = document.createElement("span");
            prefix.className = "tree-prefix";
            prefix.textContent = levelDepth > 1 ? "‚îÇ ".repeat(levelDepth - 1) + "‚îú‚îÄ " : (isMermaidStartEntry ? "‚óÜ " : "‚óè ");
            row.appendChild(prefix);

            row.appendChild(processKeywords(fileName));
            if (isMermaidStartEntry) {
                const badge = document.createElement("span");
                badge.className = "mermaid-start-badge";
                badge.textContent = "MermaidËµ∑ÁÇπ";
                row.appendChild(badge);
            }

            row.addEventListener("click", (event) => {
                event.preventDefault();
                app.workspace.openLinkText(filePath, activeFile.path, false);
            });

            row.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                viewState.highlightLevel = levelDepth;
                viewState.highlightSubLevels = true;
                renderTree();
            });

            container.appendChild(row);
        });

        if (centerCurrent) {
            requestAnimationFrame(() => centerCurrentRow());
        }
    }

    async function rebuildData() {
        const jsonFile = app.vault.getFiles().find(file => file.name === JSON_FILENAME);
        if (!jsonFile) {
            new Notice(`‚ö†Ô∏è ÂÖ®Â∫ìÊú™ÊâæÂà∞ ${JSON_FILENAME}`);
            return false;
        }

        let data;
        try {
            data = JSON.parse(await app.vault.read(jsonFile));
        } catch (error) {
            new Notice(`‚ùå JSON ËØªÂèñÂ§±Ë¥•: ${error.message}`);
            return false;
        }

        const notes = Object.values(data?.notes || {});
        let treeCandidates = notes
            .filter(note => note?.yaml?.["Ê†ëÁöÑÁªìÊûÑ"] === true)
            .filter(note => String(note?.file_name || "").startsWith(FILE_PREFIX_FILTER))
            .filter(note => !!getHierarchyCode(note.file_name))
            .sort((a, b) => String(a.file_name || "").localeCompare(String(b.file_name || ""), undefined, { numeric: true, sensitivity: "base" }));

        if (ONLY_CURRENT_BRANCH && branchRoot) {
            treeCandidates = treeCandidates.filter(note => {
                const code = getHierarchyCode(note.file_name);
                return code === branchRoot || code.startsWith(`${branchRoot}.`);
            });
        }

        const mermaidStartCodes = Array.from(new Set(
            treeCandidates
                .filter(note => isMermaidStart(note))
                .map(note => getHierarchyCode(note.file_name))
                .filter(Boolean)
        ));

        const candidateCount = treeCandidates.length;
        pages = treeCandidates.filter(note => !resolveMermaidHidden(note, mermaidStartCodes));
        mermaidStartCount = mermaidStartCodes.length;
        mermaidHiddenCount = Math.max(0, candidateCount - pages.length);

        maxExistingLevel = 1;
        pages.forEach(page => {
            const code = getHierarchyCode(page.file_name);
            if (!code) return;
            const depth = Math.max(0, code.split(".").length - (START_LEVEL - 1));
            maxExistingLevel = Math.max(maxExistingLevel, depth);
        });
        precomputeParentNodes();
        return true;
    }

    let refreshTimer = null;
    const vaultRefs = [];

    function scheduleRefresh(delay = 140) {
        if (refreshTimer) window.clearTimeout(refreshTimer);
        refreshTimer = window.setTimeout(async () => {
            const ok = await rebuildData();
            if (ok) renderTree({ centerCurrent: true });
        }, delay);
    }

    const keydownHandler = (event) => {
        const key = event.key.toLowerCase();
        let changed = false;
        if (key === "k") {
            viewState.maxLevel = Math.min(viewState.maxLevel + 1, Math.max(maxExistingLevel, 1));
            changed = true;
        }
        if (key === "j") {
            viewState.maxLevel = Math.max(1, viewState.maxLevel - 1);
            if (viewState.highlightLevel > viewState.maxLevel) viewState.highlightLevel = viewState.maxLevel;
            changed = true;
        }
        if (key === "n") {
            viewState.highlightLevel = Math.max(0, viewState.highlightLevel - 1);
            viewState.highlightSubLevels = false;
            changed = true;
        }
        if (key === "m") {
            if (viewState.highlightLevel < getCurrentMaxVisibleLevel()) viewState.highlightLevel++;
            viewState.highlightSubLevels = false;
            changed = true;
        }
        if (changed) renderTree();
    };
    document.addEventListener("keydown", keydownHandler);

    refreshBtn.onclick = () => scheduleRefresh(0);
    closeBtn.onclick = () => {
        if (widget.cleanup) widget.cleanup();
        widget.remove();
    };

    vaultRefs.push(app.vault.on("modify", file => { if (file?.name === JSON_FILENAME) scheduleRefresh(); }));
    vaultRefs.push(app.vault.on("create", file => { if (file?.name === JSON_FILENAME) scheduleRefresh(); }));
    vaultRefs.push(app.vault.on("delete", file => { if (file?.name === JSON_FILENAME) scheduleRefresh(); }));
    vaultRefs.push(app.vault.on("rename", (file, oldPath) => {
        const oldName = String(oldPath || "").split("/").pop();
        if (file?.name === JSON_FILENAME || oldName === JSON_FILENAME) scheduleRefresh();
    }));

    const cleanupFns = [];
    cleanupFns.push(() => {
        if (refreshTimer) window.clearTimeout(refreshTimer);
        vaultRefs.forEach(ref => app.vault.offref(ref));
        document.removeEventListener("keydown", keydownHandler);
        if (styleEl.isConnected) styleEl.remove();
    });
    widget.cleanup = () => cleanupFns.forEach(fn => { try { fn(); } catch (_) {} });

    widget.style.visibility = "hidden";
    document.body.appendChild(widget);
    const ok = await rebuildData();
    if (!ok) {
        if (widget.cleanup) widget.cleanup();
        widget.remove();
        return;
    }
    renderTree({ centerCurrent: true });
    requestAnimationFrame(() => {
        widget.style.visibility = "visible";
    });
    new Notice(`‚úÖ EVA Ê†ëÁä∂ÂõæÂºπÁ™óÂ∑≤ÊâìÂºÄÔºàÂâçÂêéÂêÑ ${RENDER_WINDOW} Êù°Ôºâ`);

    let isDragging = false;
    let dragX = 0;
    let dragY = 0;
    const onMouseMove = (event) => {
        if (!isDragging) return;
        widget.style.left = `${event.clientX - dragX}px`;
        widget.style.top = `${event.clientY - dragY}px`;
    };
    const onMouseUp = () => {
        isDragging = false;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
    };
    header.onmousedown = (event) => {
        if (event.target === closeBtn || event.target === refreshBtn) return;
        isDragging = true;
        const rect = widget.getBoundingClientRect();
        dragX = event.clientX - rect.left;
        dragY = event.clientY - rect.top;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
        event.preventDefault();
    };
    cleanupFns.push(() => {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
    });
})();
%>
