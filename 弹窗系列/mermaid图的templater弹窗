<%*
(async () => {
  const { Notice } = tp.obsidian;
  const WIDGET_ID = "mermaid-floating-widget";
  const existing = document.getElementById(WIDGET_ID);
  if (existing) {
    if (existing.cleanup) existing.cleanup();
    existing.remove();
    return;
  }

  const dv = app.plugins?.plugins?.dataview?.api;
  if (!dv) {
    new Notice("æœªæ£€æµ‹åˆ° Dataview æ’ä»¶ï¼Œæ— æ³•ç”Ÿæˆ Mermaid å¼¹çª—ã€‚");
    return;
  }

  const widget = document.createElement("div");
  widget.id = WIDGET_ID;
  widget.style.cssText = `
    position: fixed;
    top: 8vh;
    left: 5vw;
    width: 90vw;
    height: 90vh;
    max-width: 1600px;
    max-height: 1200px;
    min-width: 520px;
    min-height: 420px;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    box-shadow: 0 10px 36px rgba(0,0,0,0.45);
    border-radius: 10px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-family: var(--font-text);
    animation: mermaidPopupFade 0.2s ease;
  `;

  const styleTag = document.createElement("style");
  styleTag.textContent = `
    @keyframes mermaidPopupFade { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    #${WIDGET_ID} .mermaid-header { padding: 8px 12px; background: var(--background-secondary); border-bottom: 1px solid var(--background-modifier-border); cursor: move; display: flex; justify-content: space-between; align-items: center; user-select: none; flex-shrink: 0; }
    #${WIDGET_ID} .mermaid-close:hover { color: var(--text-error) !important; }
    #${WIDGET_ID} .mermaid-content { flex: 1; overflow: auto; padding: 12px 14px 18px; }
  `;
  widget.appendChild(styleTag);

  const header = document.createElement("div");
  header.className = "mermaid-header";
  const headerTitle = document.createElement("span");
  headerTitle.style.fontWeight = "600";
  headerTitle.textContent = "ğŸ§­ Mermaid çŠ¶æ€è½¬ç§»å›¾";
  header.appendChild(headerTitle);
  const headerActions = document.createElement("div");
  headerActions.style.cssText = "display:flex; align-items:center; gap:6px;";
  const closeBtn = document.createElement("div");
  closeBtn.className = "mermaid-close";
  closeBtn.innerHTML = "âœ•";
  closeBtn.style.cssText = "cursor:pointer; padding:0 6px; color:var(--text-muted); font-size:14px;";
  headerActions.appendChild(closeBtn);
  header.appendChild(headerActions);
  widget.appendChild(header);

  const content = document.createElement("div");
  content.className = "mermaid-content";
  widget.appendChild(content);
  document.body.appendChild(widget);

  const cleanupFns = [];
  const cleanup = () => {
    cleanupFns.forEach(fn => {
      try { fn(); } catch (e) { console.error("cleanup error", e); }
    });
  };
  widget.cleanup = cleanup;
  const closeWidget = () => {
    cleanup();
    if (widget.isConnected) widget.remove();
  };
  closeBtn.onclick = closeWidget;

  const ensureElementHelpers = (el) => {
    if (!el.empty) {
      el.empty = () => { el.innerHTML = ""; };
    }
    if (!el.createEl) {
      el.createEl = (tag, opts = {}) => {
        const child = document.createElement(tag);
        if (opts.cls) child.className = opts.cls;
        if (opts.text !== undefined) child.textContent = opts.text;
        if (opts.attr) {
          Object.entries(opts.attr).forEach(([k, v]) => child.setAttribute(k, v));
        }
        Object.keys(opts).forEach(key => {
          if (key == "cls" || key == "text" || key == "attr") return;
          try { child[key] = opts[key]; } catch (e) { child.setAttribute(key, opts[key]); }
        });
        el.appendChild(child);
        ensureElementHelpers(child);
        return child;
      };
    }
    return el;
  };
  ensureElementHelpers(content);

  const setupDrag = () => {
    let isDragging = false;
    let dragX = 0;
    let dragY = 0;
    const onMouseMove = (e) => {
      if (!isDragging) return;
      widget.style.left = `${e.clientX - dragX}px`;
      widget.style.top = `${e.clientY - dragY}px`;
      widget.style.right = "auto";
      widget.style.bottom = "auto";
    };
    const onMouseUp = () => {
      isDragging = false;
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    header.onmousedown = (e) => {
      if (e.target === closeBtn) return;
      isDragging = true;
      const rect = widget.getBoundingClientRect();
      dragX = e.clientX - rect.left;
      dragY = e.clientY - rect.top;
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    cleanupFns.push(() => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    });
  };
  setupDrag();

  const resolveTargetNodeFromFrontmatter = () => {
    const activeFile = app.workspace.getActiveFile();
    if (!activeFile) return { error: "æœªæ‰¾åˆ°å½“å‰ç¬”è®°" };
    const cache = app.metadataCache.getFileCache(activeFile);
    const activeNodeId = activeFile?.name ? activeFile.name.split("-")[0].trim() : "";
    const rawField = cache?.frontmatter?.["æ‰€å±å—"];
    const rawValue = Array.isArray(rawField) ? rawField[0] : rawField;
    if (!rawValue) return { error: "å½“å‰ç¬”è®°ç¼ºå°‘æ‰€å±å—å­—æ®µ" };
    const rawText = String(rawValue).trim();
    const linkMatch = rawText.match(/\[\[([^\]]+)\]\]/);
    const linkText = linkMatch ? linkMatch[1] : rawText;
    const linkPath = linkText.split("|")[0].trim();
    if (!linkPath) return { error: "æ‰€å±å—å­—æ®µæœªåŒ…å«æœ‰æ•ˆé“¾æ¥" };
    const targetFile = app.metadataCache.getFirstLinkpathDest(linkPath, activeFile.path);
    const fileName = targetFile ? targetFile.name : linkPath;
    const nodeId = fileName.split("-")[0].trim();
    if (!nodeId) return { error: "æ— æ³•ä»æ‰€å±å—é“¾æ¥æå–èŠ‚ç‚¹ç¼–å·" };
    return { nodeId, fileName, activeFile, activeNodeId };
  };

  const resolved = resolveTargetNodeFromFrontmatter();
  if (resolved?.nodeId) {
    headerTitle.textContent = `ğŸ§­ Mermaid çŠ¶æ€è½¬ç§»å›¾ (${resolved.nodeId})`;
  } else if (resolved?.error) {
    new Notice(`æ‰€å±å—è§£æå¤±è´¥: ${resolved.error}`);
  }

const ACTIVE_NODE_ID = resolved?.activeNodeId || "";
const CONFIG = {
  targetNode: resolved?.nodeId || "", // ç›®æ ‡èŠ‚ç‚¹
  maxDepth: 19,               // æœ€å¤§æ˜¾ç¤ºæ·±åº¦
  layout: "LR",               // å›¾è¡¨å¸ƒå±€: TB(ä¸Šåˆ°ä¸‹), LR(å·¦åˆ°å³)
  debug: false,               // è°ƒè¯•æ¨¡å¼
  addInvisibleNodes: true,    // æ·»åŠ ä¸å¯è§èŠ‚ç‚¹æ§åˆ¶å±‚çº§
  showAllDescendants: true,   // æ˜¾ç¤ºæ‰€æœ‰å­å­™èŠ‚ç‚¹
  showFullIds: true,          // æ˜¾ç¤ºå®Œæ•´çš„èŠ‚ç‚¹ID
  enableZoom: true,           // å¯ç”¨ç¼©æ”¾åŠŸèƒ½
  initialZoom: 2.0,           // åˆå§‹ç¼©æ”¾çº§åˆ«
  zoomStep: 0.5               // ç¼©æ”¾æ­¥é•¿
};

// ===== å·¥å…·å‡½æ•° =====
// è°ƒè¯•æ—¥å¿— - æ”¹ä¸ºç©ºå‡½æ•°ä»¥æé«˜æ€§èƒ½
function debugLog(...args) {
  // åŠŸèƒ½å·²ç§»é™¤ä»¥æé«˜æ€§èƒ½
}
/**
 * ç²¾ç¡®åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºâ€œå¤´é¢†èŠ‚ç‚¹â€.
 * å¤´é¢†èŠ‚ç‚¹çš„IDå¿…é¡»ä»¥â€œ+XXXâ€æ®µç»“å°¾.
 * @param {string} id - èŠ‚ç‚¹ID.
 * @returns {boolean}
 */
function isLeaderNode(id) {
  if (!id || !id.includes('+')) {
    return false;
  }
  const pureId = id.split('-')[0];
  const lastPlusIndex = pureId.lastIndexOf('+');
  const lastDotIndex = pureId.lastIndexOf('.');
  // å…³é”®ï¼šæœ€åä¸€ä¸ª'+'å¿…é¡»å‡ºç°åœ¨æœ€åä¸€ä¸ª'.'ä¹‹å
  return lastDotIndex < lastPlusIndex;
}


// å­å›¾ç”Ÿæˆè°ƒè¯•æ—¥å¿— - æ”¹ä¸ºç©ºå‡½æ•°ä»¥æé«˜æ€§èƒ½
function subgraphDebugLog(message) {
  // åŠŸèƒ½å·²ç§»é™¤ä»¥æé«˜æ€§èƒ½
}
function getPureId(id) {
  const dashIndex = id.indexOf("-");
  return dashIndex > 0 ? id.substring(0, dashIndex) : id;
}

function buildHeadChildrenMap(heads, nodeById) {
  const map = new Map();
  // æ¯ä¸ªå¤´é¢†åˆå§‹åŒ– children æ•°ç»„
  heads.forEach(h => map.set(h.id, []));
  // é¢„ç½® parent å ä½ï¼ˆçœŸå®çš„ parent subgraph id åœ¨è£…é…é˜¶æ®µå†å¡«ï¼‰
  heads.forEach(h => map.set("parent:" + h.id, null));

  heads.forEach(h => {
    const pid = getStateTransitionParentId(h.id);
    // åªæœ‰å½“ pid å­˜åœ¨ä¸”å¯¹åº”èŠ‚ç‚¹ä¹Ÿæ˜¯â€œå¤´é¢†â€æ—¶ï¼Œæ‰å»ºç«‹çˆ¶å­å…³ç³»
    if (pid && nodeById.has(pid)) {
      const pNode = nodeById.get(pid);
      if (pNode && pNode.hasStateTransition && map.has(pid)) {
        map.get(pid).push(h.id);
        // å…·ä½“çš„ parent å­å›¾IDç¨ååœ¨ buildStateTransitionGraph ä¸­å†™å…¥
        map.set("parent:" + h.id, null);
      } else {
        // çˆ¶èŠ‚ç‚¹ä¸æ˜¯å¤´é¢†ï¼Œåˆ™è¯¥ head ä½œä¸ºé¡¶å±‚å­å›¾
        map.set("parent:" + h.id, null);
      }
    } else {
      // æ— çˆ¶ï¼ˆæˆ–çˆ¶ä¸åœ¨ç›¸å…³é›†åˆï¼‰ä¹Ÿä½œä¸ºé¡¶å±‚å­å›¾
      map.set("parent:" + h.id, null);
    }
  });

  return map;
}

function computeSubgraphNodes(headId, allNodes, childHeadIds) {
  const res = new Set();
  const headPure = getPureId(headId);
  const headPlus = getPlusLevel(headPure);

  // å­å¤´é¢†å‰ç¼€é›†åˆï¼ˆçº¯IDï¼‰
  const childPrefixes = childHeadIds.map(cid => getPureId(cid));

  // æŠŠ head æœ¬äººæ”¾å…¥
  res.add(headId);

  allNodes.forEach(n => {
    const pure = getPureId(n.id);
    if (pure.startsWith(headPure + ".")) {
      // åŒ plus å±‚çº§
      if (getPlusLevel(pure) === headPlus) {
        // ä¸è½å…¥ä»»ä¸€å­å¤´é¢†å‰ç¼€
        const underAnyChild = childPrefixes.some(cp => pure === cp || pure.startsWith(cp + "."));
        if (!underAnyChild) {
          res.add(n.id);
        }
      }
    }
  });

  return res;
}
// æ–°å¢ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºç›´æ¥å­èŠ‚ç‚¹å…³ç³»ï¼ˆä»…é€šè¿‡æ·»åŠ  "." å½¢æˆï¼Œä¸”ä¸ºç›´æ¥ä¸€å±‚ï¼‰
function isChildRelation(parentId, childId) {
  if (!parentId || !childId) return false;
  if (parentId === childId) return false;

  // ä»…å½“ child ä»¥ parent + "." å¼€å¤´æ‰å¯èƒ½æ˜¯å­èŠ‚ç‚¹
  if (!childId.startsWith(parentId + ".")) return false;

  // å– parent åé¢çš„å‰©ä½™éƒ¨åˆ†ï¼Œä¸èƒ½å†åŒ…å«é¢å¤–çš„ "."
  const remaining = childId.substring(parentId.length + 1);
  return !remaining.includes(".");
}
/**
 * æŸ¥æ‰¾ä¸€ä¸ªå¤´é¢†èŠ‚ç‚¹çš„â€œç»“æ„æ€§çˆ¶å¤´é¢†â€
 * @param {string} headId - å½“å‰å¤´é¢†èŠ‚ç‚¹çš„ID
 * @param {Map} subgraphMap - æ‰€æœ‰å¤´é¢†å­å›¾çš„æ˜ å°„
 * @returns {string | null} - çˆ¶å¤´é¢†çš„å­å›¾IDï¼Œæˆ–null
 */
function findStructuralParentHead(headId, subgraphMap) {
    let currentId = getStateTransitionParentId(headId);
    while (currentId) {
        if (isLeaderNode(currentId) && subgraphMap.has(currentId)) {
            return subgraphMap.get(currentId).id;
        }
        currentId = getParentId(currentId); // å‘ä¸Šè¿½æº¯
    }
    return null;
}


function getStateTransitionLevel(id) {
  if (!id) return 0;
  const pureId = id.split('-')[0]; // å»é™¤æè¿°éƒ¨åˆ†
  let level = 0;
  let lastCharType = null; // 'dot' æˆ– 'plus'
  let i = 0;
  while (i < pureId.length) {
    if (pureId[i] === '+') {
      // è¿ç»­+æ®µ
      if (lastCharType !== 'plus') {
        if (lastCharType === 'dot') level++;
        lastCharType = 'plus';
      }
      while (pureId[i] === '+') i++;
    } else if (pureId[i] === '.') {
      // è¿ç»­.æ®µ
      if (lastCharType !== 'dot') {
        lastCharType = 'dot';
      }
      while (pureId[i] === '.') i++;
    } else {
      i++;
    }
  }
  return level;
}

// è·å–èŠ‚ç‚¹ç‚¹å·å±‚çº§
function getDotLevel(id) { 
  if (!id) return 0; 
  return (id.match(/\./g) || []).length; 
}

// è·å–èŠ‚ç‚¹åŠ å·å±‚çº§
function getPlusLevel(id) { 
  if (!id) return 0; 
  return (id.match(/\+/g) || []).length; 
}

// å®‰å…¨çš„èŠ‚ç‚¹IDè½¬æ¢
function safeNodeId(id) {
  return "node_" + id.replace(/[@\.+]/g, function(match) {
    if (match === '+') return "_plus_";
    if (match === '.') return "_";
    if (match === '@') return "_";
    return "_";
  });
}

// ä»æ–‡ä»¶åè§£æèŠ‚ç‚¹ä¿¡æ¯
function parseFileInfo(fileName) {
  const match = fileName.match(/ATOM@(.*?)- (.+)/);
  
  if (!match) {
    return { id: fileName, name: fileName, hasStateTransition: false };
  }
  
  const id = "ATOM@" + match[1].trim();
  const name = match[2].trim();
  
  // æ£€æŸ¥æ˜¯å¦åŒ…å«çŠ¶æ€è½¬ç§»ç¬¦å·"+"
  const hasStateTransition = id.includes("+");
  
  // è§£æçŠ¶æ€è½¬ç§»
  let baseState = null;
  if (hasStateTransition) {
    const plusIndex = id.indexOf("+");
    baseState = id.substring(0, plusIndex);
  }
  
  return { id, name, hasStateTransition, baseState };
}

// ä¿®æ­£åçš„çŠ¶æ€è½¬ç§»å…³ç³»åˆ¤æ–­å‡½æ•°
function isStateTransitionRelation(sourceId, targetId) {
  // å¦‚æœä¸¤ä¸ªIDç›¸åŒï¼Œåˆ™ä¸æ˜¯çŠ¶æ€è½¬ç§»å…³ç³»
  if (sourceId === targetId) return false;
  
  // è·å–çº¯IDï¼ˆç§»é™¤å¯èƒ½çš„æè¿°éƒ¨åˆ†ï¼‰
  const dashSourceIndex = sourceId.indexOf('-');
  const pureSourceId = dashSourceIndex > 0 ? sourceId.substring(0, dashSourceIndex) : sourceId;
  
  const dashTargetIndex = targetId.indexOf('-');
  const pureTargetId = dashTargetIndex > 0 ? targetId.substring(0, dashTargetIndex) : targetId;
  
  // æƒ…å†µ1: ç›´æ¥çŠ¶æ€è½¬ç§»å…³ç³» (å¦‚ ATOM@027F.001.002 -> ATOM@027F.001.002+001)
  if (pureTargetId.startsWith(pureSourceId + "+")) {
    const remainingPart = pureTargetId.substring(pureSourceId.length + 1);
    // ç¡®ä¿"+"åé¢çš„éƒ¨åˆ†ä¸åŒ…å«"+"æˆ–"." - å…³é”®ä¿®æ”¹ç‚¹
    return !remainingPart.includes("+") && !remainingPart.includes(".");
  }
  
  // æƒ…å†µ2: å¤šçº§çŠ¶æ€è½¬ç§»å…³ç³» (å¦‚ ATOM@027F.001.002+001 -> ATOM@027F.001.002+001+001)
  if (pureSourceId.includes("+") && pureTargetId.includes("+")) {
    // æºIDä¸­çš„åŠ å·æ•°é‡
    const sourcePlusCount = (pureSourceId.match(/\+/g) || []).length;
    // ç›®æ ‡IDä¸­çš„åŠ å·æ•°é‡
    const targetPlusCount = (pureTargetId.match(/\+/g) || []).length;
    
    // å¦‚æœç›®æ ‡æ¯”æºå¤šä¸€ä¸ªåŠ å·ï¼Œä¸”ç›®æ ‡IDæ˜¯ä»¥æºID+"+"å¼€å¤´çš„
    if (targetPlusCount === sourcePlusCount + 1 && pureTargetId.startsWith(pureSourceId + "+")) {
      const remainingPart = pureTargetId.substring(pureSourceId.length + 1);
      // ç¡®ä¿"+"åé¢çš„éƒ¨åˆ†ä¸åŒ…å«"." - å…³é”®ä¿®æ”¹ç‚¹
      return !remainingPart.includes(".");
    }
  }
  
  return false;
}

/**
 * Gets the source parent ID for a state transition node. (Corrected Version: Added robustness check)
 * This finds the ID of the node from which the state transition originated.
 * @param {string | null | undefined} id - The node ID.
 * @returns {string | null} The source parent ID, or null if not a state transition.
 */
function getStateTransitionParentId(id) {
    // CRITICAL FIX: Immediately return null if the id is invalid.
    if (!id || typeof id !== 'string') {
        return null;
    }
    
    const dashIndex = id.indexOf('-');
    const pureId = dashIndex > 0 ? id.substring(0, dashIndex) : id;

    if (!pureId.includes("+")) {
        return null;
    }
    
    // This logic correctly finds the part of the ID *before* the last "+XXX" segment.
    const segments = [];
    let i = 0;
    while (i < pureId.length) {
        if (pureId[i] === '+') {
            let start = i;
            while (i < pureId.length && pureId[i] === '+') i++;
            segments.push(pureId.substring(start, i));
        } else if (pureId[i] === '.') {
            let start = i;
            while (i < pureId.length && pureId[i] === '.') i++;
            segments.push(pureId.substring(start, i));
        } else {
            let start = i;
            while (i < pureId.length && pureId[i] !== '+' && pureId[i] !== '.') i++;
            segments.push(pureId.substring(start, i));
        }
    }
    
    let lastPlusIndex = -1;
    for (let j = segments.length - 1; j >= 0; j--) {
        if (segments[j].startsWith('+')) {
            lastPlusIndex = j;
            break;
        }
    }

    if (lastPlusIndex <= 0) {
        return null;
    }

    let parentId = "";
    for (let k = 0; k < lastPlusIndex; k++) {
        parentId += segments[k];
    }

    if (parentId.endsWith('.') || parentId.endsWith('+')) {
        parentId = parentId.slice(0, -1);
    }
    
    return parentId;
}


// è·å–èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ID
/**
 * Gets the parent ID of a node. (Corrected Version: Added robustness check)
 * This function handles all types of parent-child relationships defined in your ID system.
 * @param {string | null | undefined} id - The node ID.
 * @returns {string | null} The parent ID, or null if it has no parent.
 */
function getParentId(id) {
    // CRITICAL FIX: Immediately return null if the id is invalid.
    if (!id || typeof id !== 'string') {
        return null;
    }

    // Remove the description part ("- ...") to get the pure ID for structural analysis.
    const dashIndex = id.indexOf('-');
    const pureId = dashIndex > 0 ? id.substring(0, dashIndex) : id;

    // Handle multi-level dot paths after a state transition (e.g., ...+001.002.001)
    if (pureId.includes("+") && pureId.substring(pureId.indexOf("+")).includes(".")) {
        const afterPlusPart = pureId.substring(pureId.indexOf("+"));
        const lastDotIndex = afterPlusPart.lastIndexOf(".");
        if (lastDotIndex > 0) {
            return pureId.substring(0, pureId.indexOf("+") + lastDotIndex);
        } else {
            return pureId.substring(0, pureId.indexOf("+") + afterPlusPart.indexOf("."));
        }
    }

    // Handle multiple plus signs (e.g., ...+002+001)
    if (pureId.split("+").length > 2) {
        const lastPlusIndex = pureId.lastIndexOf("+");
        return pureId.substring(0, lastPlusIndex);
    }

    // Handle a single plus sign (e.g., ...001+001)
    if (pureId.includes("+")) {
        return pureId.substring(0, pureId.indexOf("+"));
    }

    // Handle standard hierarchical relationships (dot-separated)
    if (pureId.includes(".")) {
        const lastDotIndex = pureId.lastIndexOf(".");
        const lastPart = pureId.substring(lastDotIndex + 1);
        
        // This handles your rule for peer relationships (e.g., ...001A) vs. child relationships.
        if (/[A-Za-z]/.test(lastPart) && !lastPart.match(/^[0-9]+[A-Za-z]$/)) {
            return pureId.substring(0, lastDotIndex);
        }
        
        return pureId.substring(0, lastDotIndex);
    }

    // If none of the above conditions are met, the node has no parent.
    return null;
}


// è·å–èŠ‚ç‚¹å±‚çº§
function getNodeLevel(id) {
  if (!id) return 0;
  
  // åˆ†åˆ«è®¡ç®—ç‚¹å·å’ŒåŠ å·çš„æ•°é‡
  const dotCount = (id.match(/\./g) || []).length;
  const plusCount = (id.match(/\+/g) || []).length;
  
  // æ€»å±‚çº§æ˜¯ä¸¤è€…ä¹‹å’Œ
  return dotCount + plusCount;
}

// è·å–çŠ¶æ€è½¬ç§»çš„ç¼–å·éƒ¨åˆ†ï¼ˆæœ€åä¸€ä¸ª+æˆ–.åé¢çš„éƒ¨åˆ†ï¼‰
function getNodeNumber(id) {
  if (!id) return "";
  
  // å¯¹äºåŒ…å«+çš„ID
  if (id.includes("+")) {
    const lastPlusParts = id.split("+");
    const lastPart = lastPlusParts[lastPlusParts.length - 1];
    
    // å¦‚æœæœ€åéƒ¨åˆ†è¿˜åŒ…å«ç‚¹å·ï¼Œå–ç‚¹å·åé¢çš„éƒ¨åˆ†
    if (lastPart.includes(".")) {
      const lastDotParts = lastPart.split(".");
      return lastDotParts[lastDotParts.length - 1];
    } else {
      // å¦åˆ™è¿”å›æœ€åä¸€ä¸ª+åé¢çš„éƒ¨åˆ†
      return lastPart;
    }
  }
  
  // å¯¹äºåªåŒ…å«.çš„ID
  if (id.includes(".")) {
    const parts = id.split(".");
    return parts[parts.length - 1];
  }
  
  // æ— æ³•ç¡®å®šç¼–å·
  return id;
}


// ===== èŠ‚ç‚¹ç‚¹å‡»æ»šåŠ¨åŠŸèƒ½ =====
// æŸ¥æ‰¾å¹¶æ»šåŠ¨åˆ°å³ä¾§è§†å›¾ä¸­çš„æŒ‡å®šæ–‡ä»¶
function findAndScrollToFileInAOTM(fileName) {
  setTimeout(() => {
    try {
      const potentialTables = document.querySelectorAll(
        '.workspace-leaf:not(.mod-active) .view-content table tbody, .workspace-leaf:not(.mod-active) .view-content .custom-table tbody'
      );
      if (!potentialTables || potentialTables.length === 0) {
        throw new Error('æœªæ‰¾åˆ°å¯èƒ½åŒ…å«æ–‡ä»¶åˆ—è¡¨çš„è¡¨æ ¼');
      }

      let targetRow = null;
      let containingTable = null;

      for (const tableBody of potentialTables) {
        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        const foundRow = allRows.find(row => row.textContent.includes(fileName));
        if (foundRow) {
          targetRow = foundRow;
          containingTable = tableBody;
          break;
        }
      }

      if (!targetRow) {
        const allElements = document.querySelectorAll(
          '.workspace-leaf:not(.mod-active) .view-content *'
        );
        for (const element of allElements) {
          if (element.textContent.includes(fileName)) {
            targetRow = element.closest('tr') || element;
            break;
          }
        }
      }

      if (!targetRow) {
        if (window.Notice) {
          new Notice(`åœ¨å³ä¾§è§†å›¾ä¸­æœªæ‰¾åˆ°ç¬”è®°: ${fileName}`);
        } else {
          console.log(`åœ¨å³ä¾§è§†å›¾ä¸­æœªæ‰¾åˆ°ç¬”è®°: ${fileName}`);
        }
        return;
      }

      const scrollContainer =
        targetRow.closest('.workspace-leaf-content') ||
        targetRow.closest('.view-content') ||
        document.querySelector('.workspace-split.mod-vertical.mod-root');

      if (!scrollContainer) {
        throw new Error('æœªæ‰¾åˆ°å¯æ»šåŠ¨å®¹å™¨');
      }

      targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });

      const originalBackground = targetRow.style.backgroundColor;
      const originalTransition = targetRow.style.transition;
      targetRow.style.transition = 'background-color 0.8s';
      targetRow.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';

      setTimeout(() => {
        targetRow.style.backgroundColor = originalBackground;
        targetRow.style.transition = originalTransition;
      }, 3000);

      let noticeMessage;
      if (containingTable) {
        const allRows = Array.from(containingTable.querySelectorAll('tr'));
        const rowIndex = allRows.indexOf(targetRow) + 1;
        noticeMessage = `å·²æ‰¾åˆ°å¹¶æ»šåŠ¨åˆ°ç¬”è®°ï¼š${fileName}ï¼ˆç¬¬ ${rowIndex} è¡Œ / å…± ${allRows.length} è¡Œï¼‰`;
      } else {
        noticeMessage = `å·²æ‰¾åˆ°å¹¶æ»šåŠ¨åˆ°ç¬”è®°ï¼š${fileName}`;
      }

      if (window.Notice) {
        new Notice(noticeMessage);
      } else {
        console.log(noticeMessage);
      }
    } catch (error) {
      console.error('æ»šåŠ¨å®šä½é”™è¯¯:', error);
      const errorMessage = `æŸ¥æ‰¾æˆ–æ»šåŠ¨è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š${error.message}`;
      if (window.Notice) {
        new Notice(errorMessage);
      } else {
        console.error(errorMessage);
      }
    }
  }, 300);
}

// ===== èŠ‚ç‚¹ç‚¹å‡»æ»šåŠ¨åŠŸèƒ½ =====
// æŸ¥æ‰¾å¹¶æ»šåŠ¨åˆ°å³ä¾§è§†å›¾ä¸­çš„æŒ‡å®šæ–‡ä»¶
/**
 * [å·²ä¿®æ­£] æŸ¥æ‰¾å¹¶æ»šåŠ¨åˆ°å³ä¾§è§†å›¾ä¸­çš„æŒ‡å®šæ–‡ä»¶
 * - ä¿®æ­£äº†çª—æ ¼é€‰æ‹©é€»è¾‘ï¼Œä¸å†ä½¿ç”¨ :not(.mod-active)
 * - å¢å¼ºäº†å¯¹ä¸åŒåˆ—è¡¨ç±»å‹çš„å…¼å®¹æ€§ï¼ˆè¡¨æ ¼æˆ–Divåˆ—è¡¨ï¼‰
 */
/**
 * [æœ€ç»ˆå¥å£®ç‰ˆ] æŸ¥æ‰¾å¹¶æ»šåŠ¨åˆ°å³ä¾§è§†å›¾ä¸­çš„æŒ‡å®šæ–‡ä»¶
 * - ç»Ÿä¸€ä½¿ç”¨æœ€å¯é çš„çª—æ ¼å’Œè¡Œé¡¹ç›®å®šä½é€»è¾‘ã€‚
 */
/**
 * [æœ€ç»ˆä¿®æ­£ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - å¢åŠ äº†å¯¹ç›®æ ‡çª—æ ¼çš„â€œå¯è§æ€§â€æ£€æŸ¥ï¼Œç¡®ä¿åªåœ¨æ´»åŠ¨çš„åˆ†å±ä¸­æŸ¥æ‰¾ã€‚
 */
/**
 * [ç»ˆææ··åˆç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - ç»“åˆäº†ä¸¤ç§ç­–ç•¥ï¼šä¼˜å…ˆä½¿ç”¨ [data-path]ï¼Œå¤±è´¥åˆ™å›é€€åˆ°æŸ¥æ‰¾è¡¨æ ¼è¡Œ <tr>ã€‚
 * - å¢å¼ºäº†IDæå–é€»è¾‘ï¼Œç¡®ä¿èƒ½ä»é“¾æ¥æˆ–æ–‡æœ¬ä¸­è·å–IDã€‚
 */





// ===== æ•°æ®æ”¶é›†ä¸å¤„ç† =====
// è·å–æ‰€æœ‰æ–‡ä»¶
function getFiles() {
  try {
    if (!CONFIG.targetNode || !String(CONFIG.targetNode).trim()) return [];
    if (!dv) return [];
    // ä½¿ç”¨çœŸå®æ•°æ® - æŸ¥è¯¢æŒ‡å®šå‰ç¼€çš„èŠ‚ç‚¹
    return dv.pages()
      .where(p => p.file.name.startsWith(CONFIG.targetNode))
      .sort(p => p.file.name, 'asc')
      .map(p => {
        return {
          file: p.file,
          mermaidViewComplete: p["mermaidåº”ç”¨çš„èŒƒå¼"] === true, // è¿™æ˜¯æˆ‘ä»¬ä¸Šæ¬¡åŠ çš„
          mermaidViewBayes: p["mermaidè´å¶æ–¯"] === true, // æ–°å¢è´å¶æ–¯èŠ‚ç‚¹
          mermaidViewStandard: p["mermaidæ‰¹åˆ¤å¼æ ‡å‡†"] === true, // æ–°å¢æ‰¹åˆ¤å¼æ ‡å‡†èŠ‚ç‚¹
          mermaidViewPending: p["mermaidæœªé—­ç¯"] === true, // æ–°å¢æœªé—­ç¯èŠ‚ç‚¹
          mermaidViewAI: p["mermaidå…³é”®è¯"] === true, // æ–°å¢å…³é”®è¯è§£é‡ŠèŠ‚ç‚¹
          mermaidViewHighlight: p["mermaidè§†å›¾é‡ç‚¹"] === true, // <<< å¢åŠ è¿™ä¸€è¡Œï¼Œç”¨äºé‡ç‚¹æ ‡è®°
          // --- æ–°å¢ä»£ç  ---
          isFolded: p['å›¾æŠ˜å '] === true // è¯»å–"å›¾æŠ˜å "å±æ€§ï¼Œç”¨äºæ§åˆ¶æŠ˜å 
          // --- æ–°å¢ä»£ç ç»“æŸ ---
        };
      })
      .array();
  } catch (error) {
    return [];
  }
}



// è·å–ç›´æ¥çŠ¶æ€è½¬ç§»èŠ‚ç‚¹
function getDirectStateTransitions(node, allNodes) {
  return allNodes.filter(n => {
    // è·³è¿‡è‡ªèº«
    if (n.id === node.id) return false;
    
    // ä½¿ç”¨æ”¹è¿›åçš„å‡½æ•°åˆ¤æ–­çŠ¶æ€è½¬ç§»å…³ç³»
    return isStateTransitionRelation(node.id, n.id);
  });
}

// è·å–æ‰€æœ‰ç›´æ¥å­èŠ‚ç‚¹ - é€šè¿‡"."è¿æ¥çš„
function getDirectChildren(node, allNodes) {
  return allNodes.filter(potentialChild => {
    // è·³è¿‡è‡ªèº«
    if (potentialChild.id === node.id) return false;
    
    // åªæ£€æŸ¥é€šè¿‡"."è¿æ¥çš„å­èŠ‚ç‚¹
    if (potentialChild.id.startsWith(node.id + ".")) {
      const remainingPart = potentialChild.id.substring(node.id.length + 1);
      // ç¡®ä¿è¿™æ˜¯ç›´æ¥å­èŠ‚ç‚¹
      return !remainingPart.includes(".");
    }
    
    return false;
  });
}

// è·å–æ‰€æœ‰ç›´æ¥ç‚¹å·å­èŠ‚ç‚¹
function getDirectDotChildren(node, allNodes) {
  return allNodes.filter(n => {
    // è·³è¿‡è‡ªèº«
    if (n.id === node.id) return false;
    
    // ç¡®ä¿æ˜¯é€šè¿‡æ·»åŠ "."å½¢æˆçš„ç›´æ¥å­èŠ‚ç‚¹
    if (n.id.startsWith(node.id + ".")) {
      const remainingPart = n.id.substring(node.id.length + 1);
      // ç¡®ä¿è¿™æ˜¯ç›´æ¥å­èŠ‚ç‚¹
      return !remainingPart.includes(".");
    }
    
    return false;
  });
}

// è·å–æ‰€æœ‰ç‚¹å·å­å­™èŠ‚ç‚¹
function getAllDotDescendants(node, allNodes) {
  const descendants = [];
  const queue = [node];
  const processed = new Set([node.id]);
  
  while (queue.length > 0) {
    const currentNode = queue.shift();
    
    // æŸ¥æ‰¾å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰ç›´æ¥ç‚¹å·å­èŠ‚ç‚¹
    const dotChildren = getDirectDotChildren(currentNode, allNodes);
    
    // å°†æ‰¾åˆ°çš„å­èŠ‚ç‚¹æ·»åŠ åˆ°ç»“æœé›†ä¸­
    dotChildren.forEach(child => {
      if (!processed.has(child.id)) {
        descendants.push(child);
        processed.add(child.id);
        queue.push(child); // å°†å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼Œç»§ç»­å¤„ç†å…¶å­èŠ‚ç‚¹
      }
    });
  }
  
  return descendants;
}

// æ”¶é›†ç›¸å…³èŠ‚ç‚¹
function collectRelevantNodes(targetNode, allNodes, maxDepth) {
  const result = new Set([targetNode]);
  
  // è¾…åŠ©å‡½æ•°ï¼šé€’å½’æ”¶é›†çˆ¶èŠ‚ç‚¹
  function collectParents(node, depth) {
    if (depth >= maxDepth) return;
    if (!node.parentId) return;
    
    const parent = allNodes.find(n => n.id === node.parentId);
    if (parent) {
      result.add(parent);
      collectParents(parent, depth + 1);
    }
  }
  
  // è¾…åŠ©å‡½æ•°ï¼šé€’å½’æ”¶é›†å­èŠ‚ç‚¹
  function collectChildren(nodeId, depth) {
    if (depth >= maxDepth) return;
    
    // æ‰¾å‡ºæ‰€æœ‰ç›´æ¥å­èŠ‚ç‚¹
    const directChildren = allNodes.filter(n => 
      isChildRelation(nodeId, n.id)
    );
    
    // æ·»åŠ å­èŠ‚ç‚¹å¹¶ç»§ç»­é€’å½’
    directChildren.forEach(child => {
      result.add(child);
      
      // å¦‚æœé…ç½®ä¸ºæ˜¾ç¤ºæ‰€æœ‰å­å­™èŠ‚ç‚¹ï¼Œåˆ™é€’å½’æ”¶é›†
      if (CONFIG.showAllDescendants) {
        collectChildren(child.id, depth + 1);
      }
    });
  }
  
  // æ”¶é›†çˆ¶èŠ‚ç‚¹
  collectParents(targetNode, 0);
  
  // æ”¶é›†å­èŠ‚ç‚¹
  collectChildren(targetNode.id, 0);
  
  // æ”¶é›†çŠ¶æ€è½¬ç§»èŠ‚ç‚¹åŠç›¸å…³èŠ‚ç‚¹
  function collectStateTransitions() {
    const currentSize = result.size;
    
    // æ„å»ºç›´æ¥çŠ¶æ€è½¬ç§»å…³ç³»æ˜ å°„
    const directTransitionMap = new Map();
    allNodes.filter(node => node.hasStateTransition).forEach(node => {
      const sourceId = getStateTransitionParentId(node.id);
      if (sourceId) {
        if (!directTransitionMap.has(sourceId)) {
          directTransitionMap.set(sourceId, []);
        }
        directTransitionMap.get(sourceId).push(node);
      }
    });
    
    // éå†å½“å‰ç»“æœé›†ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
    Array.from(result).forEach(node => {
      // å¦‚æœèŠ‚ç‚¹æœ‰çŠ¶æ€è½¬ç§»å­èŠ‚ç‚¹ï¼Œæ·»åŠ å®ƒä»¬
      if (directTransitionMap.has(node.id)) {
        directTransitionMap.get(node.id).forEach(stateNode => {
          result.add(stateNode);
          
          // æ”¶é›†è¿™ä¸ªçŠ¶æ€è½¬ç§»èŠ‚ç‚¹çš„ç‚¹å·å­å­™èŠ‚ç‚¹
          getAllDotDescendants(stateNode, allNodes).forEach(desc => {
            result.add(desc);
          });
        });
      }
      
      // å¦‚æœæ˜¯çŠ¶æ€è½¬ç§»èŠ‚ç‚¹ï¼Œç¡®ä¿å…¶åŸºç¡€çŠ¶æ€èŠ‚ç‚¹ä¹Ÿè¢«æ”¶é›†
      if (node.hasStateTransition) {
        const sourceId = getStateTransitionParentId(node.id);
        if (sourceId) {
          const sourceNode = allNodes.find(n => n.id === sourceId);
          if (sourceNode) {
            result.add(sourceNode);
            
            // æ”¶é›†æºèŠ‚ç‚¹çš„ç‚¹å·å­å­™èŠ‚ç‚¹
            getAllDotDescendants(sourceNode, allNodes).forEach(desc => {
              result.add(desc);
            });
          }
        }
      }
    });
    
    // å¦‚æœé›†åˆå¤§å°æœ‰å˜åŒ–ï¼Œç»§ç»­è¿­ä»£
    if (currentSize !== result.size) {
      collectStateTransitions();
    }
  }
  
  // é€’å½’æ”¶é›†æ‰€æœ‰çŠ¶æ€è½¬ç§»å…³ç³»
  collectStateTransitions();
  
  return Array.from(result);
}

// åˆ›å»ºå­å›¾ - ä¿®æ”¹åæ­£ç¡®å¤„ç†å­å­™èŠ‚ç‚¹
function createSubgraph(nodeId, relevantNodes, graph, graphData) {
  console.log(`createSubgraph called with nodeId: ${nodeId}`);

  const dashIndex = nodeId.indexOf('-');
  const pureNodeId = dashIndex > 0 ? nodeId.substring(0, dashIndex) : nodeId;
  const subgraphId = `state_${pureNodeId.replace(/[@\.+]/g, "_")}`;

  if (graph.processedSubgraphs.has(subgraphId)) {
    console.log(`Subgraph ${subgraphId} already processed`);
    return false;
  }

  const currentNode = relevantNodes.find(node => node.id === nodeId);
  if (!currentNode) {
    console.warn(`Cannot find currentNode for nodeId: ${nodeId}`);
    return false;
  }

  const subgraphNodeIds = [currentNode.id];
  relevantNodes.forEach(node => {
    const childDashIndex = node.id.indexOf('-');
    const pureChildId = childDashIndex > 0 ? node.id.substring(0, childDashIndex) : node.id;

    if (node.id !== currentNode.id && pureChildId.startsWith(pureNodeId + ".")) {
      const childPlusLevel = getPlusLevel(pureChildId);
      const nodePlusLevel = getPlusLevel(pureNodeId);
      if (childPlusLevel === nodePlusLevel) {
        subgraphNodeIds.push(node.id);
      }
    }
  });

  console.log(`Subgraph ${subgraphId} will have ${subgraphNodeIds.length} nodes`);

  const nodeLevelMap = new Map();
  subgraphNodeIds.forEach(id => {
    const idDashIndex = id.indexOf('-');
    const pureId = idDashIndex > 0 ? id.substring(0, idDashIndex) : id;
    const dotLevel = getDotLevel(pureId) - getDotLevel(pureNodeId);
    nodeLevelMap.set(id, dotLevel + 1);
  });

  const internalEdges = [];
  const sortedNodes = [...subgraphNodeIds].sort((a, b) => nodeLevelMap.get(a) - nodeLevelMap.get(b));

  for (const id of sortedNodes) {
    if (id === nodeId) continue;
    const parentId = getParentId(id);
    if (parentId && subgraphNodeIds.includes(parentId)) {
      const sourceSafeId = safeNodeId(parentId);
      const targetSafeId = safeNodeId(id);
      const globalEdgeKey = `${sourceSafeId}->${targetSafeId}`;

      if (!graph.processedEdges) graph.processedEdges = new Set();

      if (!graph.processedEdges.has(globalEdgeKey)) {
        internalEdges.push({ source: parentId, target: id });
        graph.processedEdges.add(globalEdgeKey);
      }
    }
  }

  graphData.subgraphs.push({
    id: subgraphId,
    label: `${nodeId} çŠ¶æ€`,
    nodes: subgraphNodeIds,
    edges: internalEdges,
    baseNode: nodeId,
    nodeLevels: nodeLevelMap
  });

  graph.processedSubgraphs.add(subgraphId);
  console.log(`Subgraph ${subgraphId} created with ${internalEdges.length} internal edges`);
  return true;
}

/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆä¿®æ­£ç‰ˆ)
 * å¢åŠ å±‚çº§æ¯”è¾ƒï¼Œä»¥æ­£ç¡®å¤„ç†å¹¶åˆ—çš„å¤´é¢†èŠ‚ç‚¹ã€‚
 * @param {object} targetNode - èµ·å§‹èŠ‚ç‚¹
 * @param {Array} allNodes - æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹
 * @param {number} maxDepth - æœ€å¤§æ·±åº¦
 * @returns {object} - åŒ…å«èŠ‚ç‚¹ã€å­å›¾å’Œè¾¹çš„å›¾æ•°æ®
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆä¿®æ­£ç‰ˆ)
 * é€šè¿‡ç²¾ç¡®çš„çˆ¶å­å…³ç³»åˆ¤æ–­å’Œå±‚çº§æ¯”è¾ƒï¼Œæ­£ç¡®å¤„ç†å¹¶åˆ—å¤´é¢†å’Œæ·±åº¦åµŒå¥—ã€‚
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆä¿®æ­£ç‰ˆ)
 * é€šè¿‡ç²¾ç¡®çš„çˆ¶å­å…³ç³»åˆ¤æ–­å’Œå±‚çº§æ¯”è¾ƒï¼Œæ­£ç¡®å¤„ç†å¹¶åˆ—å¤´é¢†å’Œæ·±åº¦åµŒå¥—ã€‚
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆä¿®æ­£ç‰ˆ)
 * é€šè¿‡ç²¾ç¡®çš„çˆ¶å­å…³ç³»åˆ¤æ–­å’Œå±‚çº§æ¯”è¾ƒï¼Œæ­£ç¡®å¤„ç†å¹¶åˆ—å¤´é¢†å’Œæ·±åº¦åµŒå¥—ã€‚
 * @param {object} targetNode - èµ·å§‹èŠ‚ç‚¹
 * @param {Array} allNodes - æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹
 * @param {number} maxDepth - æœ€å¤§æ·±åº¦
 * @returns {object} - åŒ…å«èŠ‚ç‚¹ã€å­å›¾å’Œè¾¹çš„å›¾æ•°æ®
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * ä½¿ç”¨â€œç»“æ„æ€§çˆ¶å¤´é¢†â€æŸ¥æ‰¾ï¼Œå®ç°å®Œç¾çš„å±‚çº§åµŒå¥—ã€‚
 */
/**
 * Builds the state transition graph structure. (Final, Complete Version)
 * This version correctly handles peer leaders, nested subgraphs, and calculates the nesting level for each subgraph.
 * @param {object} targetNode - The starting node for the graph.
 * @param {Array} allNodes - An array of all node objects.
 * @param {number} [maxDepth=10] - The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * é›†æˆäº†â€œç»“æ„æ€§çˆ¶å¤´é¢†â€æŸ¥æ‰¾å’Œâ€œéšå½¢èŠ‚ç‚¹å¸ƒå±€â€é€»è¾‘ã€‚
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * é›†æˆäº†â€œç»“æ„æ€§çˆ¶å¤´é¢†â€æŸ¥æ‰¾å’Œâ€œéšå½¢èŠ‚ç‚¹å¸ƒå±€â€é€»è¾‘ã€‚
 * @param {object} targetNode - èµ·å§‹èŠ‚ç‚¹
 * @param {Array} allNodes - æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹
 * @param {number} maxDepth - æœ€å¤§æ·±åº¦
 * @returns {object} - åŒ…å«èŠ‚ç‚¹ã€å­å›¾å’Œè¾¹çš„å›¾æ•°æ®
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * é›†æˆäº†å¯¹â€œçŠ¶æ€è½¬ç§»æ ‘çˆ¶å­å…³ç³»â€çš„éšå½¢èŠ‚ç‚¹å¸ƒå±€ã€‚
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * é›†æˆäº†æœ€ç²¾ç¡®çš„â€œéšå½¢èŠ‚ç‚¹â€å¸ƒå±€é€»è¾‘ï¼Œä»â€œè·³æ¿èŠ‚ç‚¹â€å‘èµ·è¿æ¥ã€‚
 */
/**
 * æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾ (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * é›†æˆäº†å¯¹â€œçŠ¶æ€è½¬ç§»æ ‘çˆ¶å­å…³ç³»â€çš„éšå½¢èŠ‚ç‚¹å¸ƒå±€ã€‚
 */
/**
 * buildStateTransitionGraph (Final Version with Dual-Connection Logic)
 * Implements the definitive "State Transition Tree" layout, creating both
 * invisible layout links and a direct solid indicator link.
 */
/**
 * buildStateTransitionGraph (Final, Corrected Version)
 * Implements the definitive logic for ST-Tree and nested relationships,
 * including the dual-connection strategy for ST-Tree layout.
 * @param {object} targetNode The starting node for the graph.
 * @param {Array} allNodes An array of all node objects.
 * @param {number} [maxDepth=10] The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
/**
 * buildStateTransitionGraph (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * é‡‡ç”¨æœ€ä¸¥æ ¼çš„å±‚çº§æ¯”è¾ƒï¼Œå½»åº•è§£å†³æ‰€æœ‰é”™è¯¯çš„åµŒå¥—é—®é¢˜ã€‚
 * @param {object} targetNode The starting node for the graph.
 * @param {Array} allNodes An array of all node objects.
 * @param {number} [maxDepth=10] The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
/**
 * buildStateTransitionGraph (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * é‡‡ç”¨æœ€ä¸¥æ ¼çš„å±‚çº§æ¯”è¾ƒå’Œçˆ¶çº§ç»§æ‰¿ï¼Œå½»åº•è§£å†³æ‰€æœ‰é”™è¯¯çš„åµŒå¥—å’Œåˆ†ç¦»é—®é¢˜ã€‚
 * @param {object} targetNode The starting node for the graph.
 * @param {Array} allNodes An array of all node objects.
 * @param {number} [maxDepth=10] The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
/**
 * buildStateTransitionGraph (Final Version with ID Simplification)
 * Generates simplified, human-readable IDs for Mermaid code while
 * maintaining a full map for interactivity.
 */
/**
 * buildStateTransitionGraph (Final, Definitive Version)
 * Implements the "deepest node" logic for perfect layout link origination.
 * @param {object} targetNode The starting node for the graph.
 * @param {Array} allNodes An array of all node objects.
 * @param {number} [maxDepth=10] The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
/**
 * buildStateTransitionGraph (Final, Definitive Version)
 * Implements the recursive "deepest node" logic for perfect layout link origination,
 * ensuring the most robust and visually stable ST-Tree layout.
 * @param {object} targetNode The starting node for the graph.
 * @param {Array} allNodes An array of all node objects.
 * @param {number} [maxDepth=10] The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
/**
 * buildStateTransitionGraph (Final, Definitive Version)
 * Implements the "deepest node" logic for perfect layout link origination by
 * recursively searching through nested subgraphs and ST-Children.
 * @param {object} targetNode The starting node for the graph.
 * @param {Array} allNodes An array of all node objects.
 * @param {number} [maxDepth=10] The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
/**
 * buildStateTransitionGraph (Final, Definitive Version)
 * Implements the ultimate "deepest node" logic by recursively searching
 * through all nested ST-Children to find the true visual bottom of a subgraph,
 * ensuring perfect layout link origination.
 *
 * @param {object} targetNode - The starting node for the graph.
 * @param {Array} allNodes - An array of all node objects.
 * @param {number} [maxDepth=10] - The maximum depth for node collection.
 * @returns {object} The complete graph data structure for rendering.
 */
/**
 * buildStateTransitionGraph (The Absolute Final Version)
 * Implements the definitive "true deepest node" logic by calculating
 * a composite depth score for perfect layout link origination.
 * @param {object} targetNode The starting node for the graph.
 * @param {Array} allNodes An array of all node objects.
 * @param {number} [maxDepth=10] The maximum depth for node collection.
 * @returns {object} The complete graph data structure.
 */
function buildStateTransitionGraph(targetNode, allNodes, maxDepth = 10) {
    const relevantNodes = collectRelevantNodes(targetNode, allNodes, maxDepth);
    const nodeById = new Map(relevantNodes.map(n => [n.id, n]));
    const heads = relevantNodes.filter(n => isLeaderNode(n.id));

    // --- ID Simplification Logic (no changes needed) ---
    const idMap = new Map();
    const simpleIdCounter = { L: 0, M: 0, B: 0 };
    function getSimpleId(node) {
        if (idMap.has(node.id)) return idMap.get(node.id);
        let prefix = isLeaderNode(node.id) ? 'L' : (node.parentId || getStateTransitionParentId(node.id) ? 'M' : 'B');
        const simpleId = prefix + simpleIdCounter[prefix]++;
        idMap.set(node.id, simpleId);
        node.simpleId = simpleId;
        return simpleId;
    }
    relevantNodes.forEach(n => getSimpleId(n));
    // --- End of ID Simplification ---

    const subgraphs = [];
    const subgraphMap = new Map();
    heads.forEach(head => {
        const sg = {
            id: `sg_${head.simpleId}`,
            label: `${head.id} çŠ¶æ€`,
            baseNode: head.id,
            nodes: [], 
            edges: [], 
            parent: null
        };
        subgraphMap.set(head.id, sg);
        subgraphs.push(sg);
    });

    // Parent-child subgraph logic (no changes needed)
    subgraphs.forEach(sg => {
        const sourceId = getStateTransitionParentId(sg.baseNode);
        if (!sourceId || !nodeById.has(sourceId)) return;
        if (!isLeaderNode(sourceId)) {
            let parentCandidateId = sourceId;
            while (parentCandidateId) {
                if (isLeaderNode(parentCandidateId) && subgraphMap.has(parentCandidateId)) {
                    sg.parent = subgraphMap.get(parentCandidateId).id;
                    break;
                }
                parentCandidateId = getParentId(parentCandidateId);
            }
        } else {
            const parentSubgraph = subgraphMap.get(sourceId);
            if (parentSubgraph) {
                sg.parent = parentSubgraph.parent;
            }
        }
    });

    // Populate subgraphs with members (no changes needed)
    heads.forEach(head => {
        const sg = subgraphMap.get(head.id);
        const childHeadIds = subgraphs.filter(csg => csg.parent === sg.id).map(csg => csg.baseNode);
        const sgNodes = computeSubgraphNodes(head.id, relevantNodes, childHeadIds);
        sg.nodes = Array.from(sgNodes);
        sgNodes.forEach(id => {
            const parentId = getParentId(id);
            if (parentId && sgNodes.has(parentId)) {
                sg.edges.push({ source: parentId, target: id });
            }
        });
    });

    // **THE DEFINITIVE HELPER FUNCTION: Get True Deepest Node**
    function getTrueDeepestNode(subgraph) {
        if (!subgraph) return null;

        let deepestNodeId = subgraph.baseNode;
        let maxDepthScore = -1;

        const processedNodes = new Set();

        // Recursive function to traverse and score all nodes within a subgraph's hierarchy
        function traverseAndScore(currentSg) {
            // Score all direct member nodes of this subgraph
            currentSg.nodes.forEach(nodeId => {
                if (processedNodes.has(nodeId)) return;
                
                // The "True Depth Score" is a combination of its own ID depth
                // and the nesting level of its containing subgraph.
                const nodeDotLevel = getDotLevel(nodeId);
                const subgraphNestingLevel = getSubgraphNestingLevel(currentSg);
                const totalScore = nodeDotLevel + subgraphNestingLevel * 10; // Weight nesting heavily

                if (totalScore > maxDepthScore) {
                    maxDepthScore = totalScore;
                    deepestNodeId = nodeId;
                }
                processedNodes.add(nodeId);
            });

            // Recurse into nested child subgraphs
            subgraphs.forEach(childSg => {
                if (childSg.parent === currentSg.id) {
                    traverseAndScore(childSg);
                }
            });
        }

        function getSubgraphNestingLevel(sg) {
            let level = 0;
            let current = sg;
            while (current && current.parent) {
                level++;
                current = subgraphs.find(s => s.id === current.parent);
            }
            return level;
        }

        traverseAndScore(subgraph);
        return deepestNodeId;
    }

    // Create global connections using the definitive logic
    const invisibleNodes = [];
    const edges = [];
    let invisibleCounter = 1;

    heads.forEach(head => {
        const sourceId = getStateTransitionParentId(head.id);
        if (sourceId && nodeById.has(sourceId)) {
            // ST-Tree Relationship
            if (isLeaderNode(sourceId)) {
                const parentSubgraph = subgraphMap.get(sourceId);
                
                // **CRUCIAL CHANGE**: Use the new, perfect helper function
                const layoutSourceNodeId = getTrueDeepestNode(parentSubgraph);
                
                if (layoutSourceNodeId) { // Ensure we found a node
                    const invisibleId = `invisible${invisibleCounter++}`;
                    invisibleNodes.push(invisibleId);
                    edges.push({ source: layoutSourceNodeId, target: invisibleId, type: 'invisible' });
                    edges.push({ source: invisibleId, target: head.id, type: 'invisible' });
                    edges.push({ source: sourceId, target: head.id, type: 'st-indicator' });
                } else {
                    // Fallback to direct connection if no deepest node is found
                    edges.push({ source: sourceId, target: head.id, type: 'st-indicator' });
                }

            } 
            // Nested Relationship
            else {
                edges.push({ source: sourceId, target: head.id, type: 'stateTransition' });
            }
        }
    });

    return {
        nodes: relevantNodes,
        subgraphs: subgraphs,
        edges: edges,
        invisibleNodes: invisibleNodes
    };
}





















// ===== Mermaidä»£ç ç”Ÿæˆ =====
// ç”ŸæˆMermaidå›¾è¡¨ä»£ç 
/**
 * ç”Ÿæˆæœ€ç»ˆçš„Mermaidå›¾è¡¨ä»£ç 
 * @param {object} graph - ç”±buildStateTransitionGraphç”Ÿæˆçš„å›¾è¡¨æ•°æ®ç»“æ„
 * @param {function} clickCallback - èŠ‚ç‚¹ç‚¹å‡»æ—¶çš„å›è°ƒå‡½æ•°
 * @returns {string} - å®Œæ•´çš„Mermaidä»£ç 
 */
/**
 * Generates the final Mermaid code for the diagram.
 * This function recursively renders nested subgraphs and ensures correct node and edge definitions.
 * @param {object} graph - The graph data structure from buildStateTransitionGraph.
 * @param {function} clickCallback - The callback function for node clicks.
 * @returns {string} - The complete Mermaid code.
 */
/**
 * ç”Ÿæˆæœ€ç»ˆçš„Mermaidå›¾è¡¨ä»£ç  (æœ€ç»ˆç‰ˆ)
 * @param {object} graph - ç”±buildStateTransitionGraphç”Ÿæˆçš„å›¾è¡¨æ•°æ®ç»“æ„
 * @param {function} clickCallback - èŠ‚ç‚¹ç‚¹å‡»æ—¶çš„å›è°ƒå‡½æ•°
 * @returns {string} - å®Œæ•´çš„Mermaidä»£ç 
 */
/**
 * ç”Ÿæˆæœ€ç»ˆçš„Mermaidå›¾è¡¨ä»£ç  (æœ€ç»ˆå®Œæ•´ç‰ˆ)
 * èƒ½å¤Ÿå¤„ç†å¹¶åˆ—å¤´é¢†ã€æ·±åº¦åµŒå¥—å’Œæ‰€æœ‰ç±»å‹çš„è¿æ¥ã€‚
 * @param {object} graph - ç”±buildStateTransitionGraphç”Ÿæˆçš„å›¾è¡¨æ•°æ®ç»“æ„
 * @param {function} clickCallback - èŠ‚ç‚¹ç‚¹å‡»æ—¶çš„å›è°ƒå‡½æ•°
 * @returns {string} - å®Œæ•´çš„Mermaidä»£ç 
 */
/**
 * ç”Ÿæˆæœ€ç»ˆçš„Mermaidå›¾è¡¨ä»£ç  (æœ€ç»ˆé‡æ„ç‰ˆ)
 * èƒ½å¤Ÿå¤„ç†å¹¶åˆ—å¤´é¢†ã€æ·±åº¦åµŒå¥—å’Œæ‰€æœ‰ç±»å‹çš„è¿æ¥ã€‚
 */
/**
 * ç”Ÿæˆæœ€ç»ˆçš„Mermaidå›¾è¡¨ä»£ç  (æœ€ç»ˆé‡æ„ç‰ˆ)
 * èƒ½å¤Ÿå¤„ç†å¹¶åˆ—å¤´é¢†ã€æ·±åº¦åµŒå¥—å’Œæ‰€æœ‰ç±»å‹çš„è¿æ¥ã€‚
 */
/**
 * ç”Ÿæˆæœ€ç»ˆçš„Mermaidå›¾è¡¨ä»£ç  (æœ€ç»ˆå®Œç¾ç‰ˆ)
 * èƒ½å¤Ÿæ¸²æŸ“éšå½¢èŠ‚ç‚¹ä»¥å®ç°ç²¾ç¡®çš„å±‚çº§å¯¹é½ã€‚
 * @param {object} graph - å›¾è¡¨æ•°æ®ç»“æ„
 * @param {function} clickCallback - èŠ‚ç‚¹ç‚¹å‡»å›è°ƒ
 * @returns {string} - å®Œæ•´çš„Mermaidä»£ç 
 */
/**
 * ç”Ÿæˆæœ€ç»ˆçš„Mermaidå›¾è¡¨ä»£ç  (æœ€ç»ˆå®Œæ•´ç‰ˆ)
 * èƒ½å¤Ÿæ¸²æŸ“éšå½¢èŠ‚ç‚¹ä»¥å®ç°ç²¾ç¡®çš„å±‚çº§å¯¹é½ã€‚
 * @param {object} graph - å›¾è¡¨æ•°æ®ç»“æ„
 * @param {function} clickCallback - èŠ‚ç‚¹ç‚¹å‡»å›è°ƒ
 * @returns {string} - å®Œæ•´çš„Mermaidä»£ç 
 */
/**
 * generateMermaidCode (Final Version for Simple IDs)
 * Uses simplified IDs for a clean diagram and correctly maps them for interactivity.
 */
function generateMermaidCode(graph, clickCallback, foldedPrefixes = []) {
    let code = `flowchart ${CONFIG.layout}\n`;
    
    // Style definitions
    code += "  %% æ ·å¼å®šä¹‰\n";
    code += "  classDef base fill:#dfd,stroke:#393\n";
    code += "  classDef leader fill:#ffeb99,stroke:#933,stroke-width:1.5px\n";
    code += "  classDef member fill:#ddf,stroke:#333\n";
    code += "  classDef highlighted fill:#F37021,stroke:#C05000,stroke-width:1.5px,color:white\n";
    code += "  classDef bayes fill:#008000,stroke:#C05000,stroke-width:1.5px,color:white\n";
    code += "  classDef Standard fill:#8B5CF6,stroke:#C05000,stroke-width:1.5px,color:white\n";
    code += "  classDef completed fill:#5383AA,stroke:#C05000,stroke-width:1.5px,color:white\n";
    code += "  classDef pending fill:#002FA7,stroke:#C05000,stroke-width:1.5px,color:white\n";
    code += "  classDef AI fill:#E34234,stroke:#C05000,stroke-width:1.5px,color:white\n";
    code += "  classDef invisible fill:none,stroke:none\n";
    // --- æ–°å¢: æŠ˜å èŠ‚ç‚¹çš„æ ·å¼ ---
    code += "  classDef foldedNode fill:#e9ecef,stroke:#adb5bd,stroke-dasharray: 4 4\n";

    // Build indexes
    const nodeIndex = new Map(graph.nodes.map(n => [n.id, n]));
    const subgraphMap = new Map(graph.subgraphs.map(sg => [sg.id, sg]));
    const childrenByParent = new Map([[null, []]]);
    graph.subgraphs.forEach(sg => {
        const parentId = sg.parent || null;
        if (!childrenByParent.has(parentId)) childrenByParent.set(parentId, []);
        childrenByParent.get(parentId).push(sg.id);
    });

    const definedNodes = new Set();
    const renderedEdges = new Set();
    
    // --- æ–°å¢: è¾…åŠ©å‡½æ•° ---
    function getPureId(id) {
        const dashIndex = id.indexOf('-');
        return dashIndex >= 0 ? id.substring(0, dashIndex) : id;
    }

    function isHidden(nodeId) {
        if (!foldedPrefixes || foldedPrefixes.length === 0) return false;
        const pureNodeId = getPureId(nodeId);
        // å¦‚æœèŠ‚ç‚¹çš„ pureId ä»¥ä»»ä½•æŠ˜å å‰ç¼€å¼€å¤´ï¼Œå¹¶ä¸”å®ƒä¸ç­‰äºé‚£ä¸ªå‰ç¼€æœ¬èº«ï¼Œåˆ™éšè—å®ƒ
        return foldedPrefixes.some(prefix => pureNodeId.startsWith(prefix) && pureNodeId !== prefix);
    }
    // --- è¾…åŠ©å‡½æ•°ç»“æŸ ---

    function getLabel(nodeId) {
        const node = nodeIndex.get(nodeId);
        if (!node) return nodeId;
        let text = `${node.id}<br>${node.name || ""}`;
        if (text.length > 20) {
            text = text.replace(/(.{15,20})([\s,\.ï¼Œã€‚;ï¼›:ï¼š!ï¼ï¼Ÿ?])/g, '$1$2<br>');
            if (!text.includes('<br>') && text.length > 20) {
                const chunks = [];
                for (let i = 0; i < text.length; i += 20) {
                    chunks.push(text.substring(i, Math.min(i + 20, text.length)));
                }
                text = chunks.join('<br>');
            }
        }
        return text;
    }

    function renderSubgraphRecursive(subgraphId) {
        const sg = subgraphMap.get(subgraphId);
        if (!sg || isHidden(sg.id)) return ""; // å¦‚æœå­å›¾æœ¬èº«è¢«éšè—ï¼Œåˆ™ä¸æ¸²æŸ“
        let subCode = `  subgraph "${sg.label}"\n`;
        
        (sg.nodes || []).forEach(nodeId => {
            if (isHidden(nodeId)) return; // ä¿®æ”¹: è·³è¿‡è¢«éšè—çš„èŠ‚ç‚¹
            const node = nodeIndex.get(nodeId);
            if (node && !definedNodes.has(node.simpleId)) {
                subCode += `    ${node.simpleId}["${getLabel(nodeId)}"]\n`;
                definedNodes.add(node.simpleId);
            }
        });

        (sg.edges || []).forEach(edge => {
            if (isHidden(edge.source) || isHidden(edge.target)) return; // ä¿®æ”¹: è·³è¿‡ä¸éšè—èŠ‚ç‚¹ç›¸å…³çš„è¾¹
            const sourceNode = nodeIndex.get(edge.source);
            const targetNode = nodeIndex.get(edge.target);
            if (sourceNode && targetNode) {
                const edgeKey = `${sourceNode.simpleId}-->${targetNode.simpleId}`;
                if (!renderedEdges.has(edgeKey)) {
                    subCode += `    ${sourceNode.simpleId} --> ${targetNode.simpleId}\n`;
                    renderedEdges.add(edgeKey);
                }
            }
        });

        (childrenByParent.get(subgraphId) || []).forEach(childId => {
            subCode += renderSubgraphRecursive(childId);
        });
        subCode += `  end\n`;
        return subCode;
    }

    // --- Begin Rendering ---
    
    code += "\n  %% èŠ‚ç‚¹å®šä¹‰\n";
    (graph.invisibleNodes || []).forEach(id => {
        if (isHidden(id)) return; // ä¿®æ”¹: è·³è¿‡è¢«éšè—çš„èŠ‚ç‚¹
        code += `  ${id}[" "]\n`;
        definedNodes.add(id);
    });
    
    const allSubgraphNodes = new Set(graph.subgraphs.flatMap(sg => sg.nodes));

    graph.nodes.forEach(node => {
        if (!allSubgraphNodes.has(node.id) && !definedNodes.has(node.simpleId)) {
            if (isHidden(node.id)) return; // ä¿®æ”¹: è·³è¿‡è¢«éšè—çš„èŠ‚ç‚¹
            code += `  ${node.simpleId}["${getLabel(node.id)}"]\n`;
            definedNodes.add(node.simpleId);
        }
    });
    
    (childrenByParent.get(null) || []).forEach(sgId => {
        code += renderSubgraphRecursive(sgId);
    });

    // Render Connections
    code += "\n  %% è¿æ¥çº¿å®šä¹‰\n";
    graph.nodes.forEach(node => {
        const parentId = getParentId(node.id);
        if (parentId && nodeIndex.has(parentId) && !allSubgraphNodes.has(node.id) && !allSubgraphNodes.has(parentId)) {
            if (isHidden(node.id) || isHidden(parentId)) return; // ä¿®æ”¹: è·³è¿‡ä¸éšè—èŠ‚ç‚¹ç›¸å…³çš„è¾¹
            const parentNode = nodeIndex.get(parentId);
            const edgeKey = `${parentNode.simpleId}-->${node.simpleId}`;
            if (!renderedEdges.has(edgeKey)) {
                code += `  ${parentNode.simpleId} --> ${node.simpleId}\n`;
                renderedEdges.add(edgeKey);
            }
        }
    });

    (graph.edges || []).forEach(edge => {
        if (isHidden(edge.source) || isHidden(edge.target)) return; // ä¿®æ”¹: è·³è¿‡ä¸éšè—èŠ‚ç‚¹ç›¸å…³çš„è¾¹
        const sourceNode = nodeIndex.get(edge.source) || { simpleId: edge.source };
        const targetNode = nodeIndex.get(edge.target) || { simpleId: edge.target };
        const edgeKey = `${sourceNode.simpleId}-->${targetNode.simpleId}`;
        if (renderedEdges.has(edgeKey) && edge.type !== 'invisible') return;
        
        if (edge.type === 'invisible') {
            code += `  ${sourceNode.simpleId} -.-> ${targetNode.simpleId}\n`;
        } else {
            code += `  ${sourceNode.simpleId} --> ${targetNode.simpleId}\n`;
        }
        renderedEdges.add(edgeKey);
    });

    // ===== Corrected Style Application Logic =====

    code += "\n  %% æ ·å¼åº”ç”¨\n";
    graph.nodes.forEach(n => {
        if (isHidden(n.id)) return; // ä¿®æ”¹: ä¸ä¸ºéšè—èŠ‚ç‚¹åº”ç”¨æ ·å¼
        const sId = n.simpleId;
        const pureId = getPureId(n.id); // è·å–çº¯IDç”¨äºåˆ¤æ–­æŠ˜å 

        // ä¼˜å…ˆçº§ï¼šé«˜äº® > æŠ˜å  > å…¶ä»–
        if (n.mermaidViewHighlight) {
            code += `  class ${sId} highlighted\n`;
        } else if (foldedPrefixes.includes(pureId)) { // ä¿®æ”¹: åº”ç”¨æŠ˜å æ ·å¼
            code += `  class ${sId} foldedNode\n`;
        } else if (n.mermaidViewBayes) {
            code += `  class ${sId} bayes\n`;
        } else if (n.mermaidViewPending) {
            code += `  class ${sId} pending\n`;
        } else if (n.mermaidViewAI) {
            code += `  class ${sId} AI\n`;
        } else if (n.mermaidViewStandard) {
            code += `  class ${sId} Standard\n`;
        } else if (n.mermaidViewComplete) {
            code += `  class ${sId} completed\n`;
        } else if (isLeaderNode(n.id)) {
            code += `  class ${sId} leader\n`;
        } else if (allSubgraphNodes.has(n.id)) {
            code += `  class ${sId} member\n`;
        } else {
            code += `  class ${sId} base\n`;
        }
    });

    (graph.invisibleNodes || []).forEach(id => {
        if (isHidden(id)) return;
        code += `  class ${id} invisible\n`;
    });

    // Bind Click Events
    if (typeof clickCallback === 'function') {
        code += "\n  %% ç»‘å®šç‚¹å‡»äº‹ä»¶\n";
        window.stateTransitionNodeIdMap = {};
        graph.nodes.forEach(n => {
            window.stateTransitionNodeIdMap[n.simpleId] = n;
        });
        
        // ä¿®æ”¹: åªä¸ºæœªè¢«éšè—çš„èŠ‚ç‚¹ç»‘å®šç‚¹å‡»äº‹ä»¶
        const clickableNodes = graph.nodes
            .filter(n => n.fileName && !isHidden(n.id)) 
            .map(n => n.simpleId);

        if (clickableNodes.length > 0) {
            window.stateTransitionNodeClickCallback = clickCallback;
            code += `  click ${clickableNodes.join(',')} stateTransitionNodeClickCallback\n`;
            code += "  classDef clickable cursor:pointer\n";
            code += `  class ${clickableNodes.join(',')} clickable\n`;
        }
    }

    return code;
}












// ===== UI å’Œä¸»ç¨‹åº =====
// åˆ›å»ºç”¨æˆ·ç•Œé¢
function createUI(container) {
  // æ¸…é™¤ç°æœ‰å†…å®¹
  container.empty();
  
  // æ ‡é¢˜
  container.createEl("h3", { text: "çŠ¶æ€è½¬ç§»èŠ‚ç‚¹å…³ç³»å›¾" });
  
  // è®¾ç½®é¢æ¿
  const settingsDiv = container.createEl("div", { cls: "settings-panel" });
  settingsDiv.style.marginBottom = "15px";
  settingsDiv.style.padding = "10px";
  settingsDiv.style.backgroundColor = "#f5f5f5";
  settingsDiv.style.borderRadius = "5px";
  
  // ç›®æ ‡èŠ‚ç‚¹è¾“å…¥
  const nodeInput = settingsDiv.createEl("input", { 
    type: "text",
    value: CONFIG.targetNode,
    placeholder: "è¾“å…¥ç›®æ ‡èŠ‚ç‚¹ID"
  });
  nodeInput.style.width = "200px";
  nodeInput.style.marginRight = "15px";
  
  // æ·±åº¦è®¾ç½®
  const depthInput = settingsDiv.createEl("input", {
    type: "number",
    value: CONFIG.maxDepth,
    attr: { min: 1, max: 30 }
  });
  depthInput.style.width = "50px";
  depthInput.style.marginRight = "15px";
  
  // å¸ƒå±€é€‰æ‹©
  const layoutSelect = settingsDiv.createEl("select");
  ["TB", "LR", "RL", "BT"].forEach(dir => {
    const option = layoutSelect.createEl("option", { text: dir });
    if (dir === CONFIG.layout) option.selected = true;
  });
  layoutSelect.style.marginRight = "15px";
  
  // æ·»åŠ æ ‡ç­¾
  settingsDiv.insertBefore(document.createTextNode("ç›®æ ‡èŠ‚ç‚¹: "), nodeInput);
  settingsDiv.insertBefore(document.createTextNode(" æœ€å¤§æ·±åº¦: "), depthInput);
  settingsDiv.insertBefore(document.createTextNode(" å¸ƒå±€: "), layoutSelect);
  
  // åˆ›å»ºæ–°è¡Œ
  settingsDiv.createEl("br");
  
  // æ·»åŠ ä¸å¯è§èŠ‚ç‚¹é€‰é¡¹
  const invisibleCheck = settingsDiv.createEl("input", { 
    type: "checkbox",
    checked: CONFIG.addInvisibleNodes
  });
  invisibleCheck.style.marginRight = "5px";
  
  // æ˜¾ç¤ºæ‰€æœ‰å­å­™èŠ‚ç‚¹é€‰é¡¹
  const showAllCheck = settingsDiv.createEl("input", { 
    type: "checkbox",
    checked: CONFIG.showAllDescendants
  });
  showAllCheck.style.marginRight = "5px";
  
  // æ˜¾ç¤ºå®Œæ•´IDé€‰é¡¹
  const showFullIdsCheck = settingsDiv.createEl("input", { 
    type: "checkbox",
    checked: CONFIG.showFullIds
  });
  showFullIdsCheck.style.marginRight = "5px";
  
  // å¯ç”¨ç¼©æ”¾é€‰é¡¹
  const zoomCheck = settingsDiv.createEl("input", { 
    type: "checkbox",
    checked: CONFIG.enableZoom
  });
  zoomCheck.style.marginRight = "5px";
  
  // è°ƒè¯•æ¨¡å¼é€‰é¡¹
  const debugCheck = settingsDiv.createEl("input", { 
    type: "checkbox",
    checked: CONFIG.debug
  });
  debugCheck.style.marginRight = "5px";
  
  // æ·»åŠ æ ‡ç­¾
  settingsDiv.insertBefore(document.createTextNode("æ·»åŠ ä¸å¯è§èŠ‚ç‚¹: "), invisibleCheck);
  settingsDiv.insertBefore(document.createTextNode(" æ˜¾ç¤ºæ‰€æœ‰å­å­™èŠ‚ç‚¹: "), showAllCheck);
  settingsDiv.insertBefore(document.createTextNode(" æ˜¾ç¤ºå®Œæ•´ID: "), showFullIdsCheck);
  settingsDiv.insertBefore(document.createTextNode(" å¯ç”¨ç¼©æ”¾: "), zoomCheck);
  settingsDiv.insertBefore(document.createTextNode(" è°ƒè¯•æ¨¡å¼: "), debugCheck);
  
  // åˆ›å»ºæ–°è¡Œ
  settingsDiv.createEl("br");
  
  // æ›´æ–°æŒ‰é’®
  const updateButton = settingsDiv.createEl("button", { text: "æ›´æ–°å›¾è¡¨" });
  updateButton.style.marginTop = "10px";
  
  // è¯´æ˜ä¿¡æ¯
  const infoDiv = container.createEl("div", { cls: "info-panel" });
  infoDiv.style.marginBottom = "10px";
  infoDiv.style.fontSize = "0.9em";
  infoDiv.style.color = "#666";
  infoDiv.innerHTML = `
    <details>
      <summary style="cursor:pointer;color:#0074d9;">æŸ¥çœ‹ä½¿ç”¨è¯´æ˜</summary>
      <p><b>èŠ‚ç‚¹äº¤äº’åŠŸèƒ½:</b></p>
      <ul>
        <li><b>ç‚¹å‡»èŠ‚ç‚¹</b>: ç‚¹å‡»å›¾è¡¨ä¸­çš„ä»»ä½•èŠ‚ç‚¹ï¼Œä¼šè‡ªåŠ¨æ»šåŠ¨å³ä¾§è¾¹æ åˆ°å¯¹åº”çš„ç¬”è®°ä½ç½®</li>
        <li><b>é«˜äº®æ˜¾ç¤º</b>: æ‰¾åˆ°çš„ç¬”è®°è¡Œä¼šæš‚æ—¶é«˜äº®æ˜¾ç¤ºï¼Œæ–¹ä¾¿è¯†åˆ«</li>
        <li><b>çŠ¶æ€æç¤º</b>: ç‚¹å‡»åä¼šæ˜¾ç¤ºæ“ä½œç»“æœçš„æç¤ºä¿¡æ¯</li>
      </ul>
      <p>æœ¬å›¾è¡¨ä½¿ç”¨å¾ªç¯è¿­ä»£æ–¹å¼ç»˜åˆ¶çŠ¶æ€è½¬ç§»å…³ç³»ï¼Œç»˜åˆ¶é€»è¾‘ä¸ºï¼š</p>
      <ol>
        <li>é¦–å…ˆç»˜åˆ¶æ‰€æœ‰ä¸åŒ…å«"+"çš„æ™®é€šèŠ‚ç‚¹</li>
        <li>ç„¶åæŒ‰ç…§å¾ªç¯è¿­ä»£å¤„ç†å¸¦"+"çš„çŠ¶æ€è½¬ç§»èŠ‚ç‚¹:
          <ul>
            <li>a. æ‰¾åˆ°å±‚çº§æœ€å°çš„å°šæœªç»˜åˆ¶çš„å¸¦"+"çš„èŠ‚ç‚¹</li>
            <li>b. æ‰¾åˆ°å®ƒçš„ç›´æ¥æ¥æºèŠ‚ç‚¹ï¼ˆæœ€åä¸€ä¸ª"+"å‰çš„éƒ¨åˆ†ï¼‰</li>
            <li>c. å°†æ¥æºèŠ‚ç‚¹åŠå…¶æ‰€æœ‰å­å­™èŠ‚ç‚¹ï¼ˆä½¿ç”¨"."è¿æ¥çš„ï¼‰æ”¾å…¥ä¸€ä¸ªsubgraphä¸­</li>
            <li>d. ç”¨è™šçº¿ç®­å¤´è¿æ¥æ¥æºèŠ‚ç‚¹åˆ°çŠ¶æ€è½¬ç§»èŠ‚ç‚¹</li>
            <li>e. ä¸ºçŠ¶æ€è½¬ç§»èŠ‚ç‚¹åˆ›å»ºå­å›¾ï¼ŒåŒ…å«å…¶ç‚¹å·å­èŠ‚ç‚¹</li>
            <li>f. é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼Œç›´åˆ°æ‰€æœ‰å¸¦"+"çš„èŠ‚ç‚¹éƒ½è¢«å¤„ç†</li>
          </ul>
        </li>
      </ol>
      <p>èŠ‚ç‚¹å…³ç³»è¯´æ˜:</p>
      <ul>
        <li>åªæœ‰åœ¨ç¼–å·æœ«å°¾æ·»åŠ <b>æ–°çš„"."</b>æ‰äº§ç”Ÿå­çº§èŠ‚ç‚¹</li>
        <li>åœ¨ç¼–å·æœ«å°¾æ·»åŠ <b>å­—æ¯A</b>æˆ–<b>é€’å¢æ•°å­—</b>éƒ½æ˜¯åˆ›å»º<b>å¹¶åˆ—èŠ‚ç‚¹</b>ï¼Œä¸æ˜¯å­èŠ‚ç‚¹</li>
        <li>æ·»åŠ <b>"+"</b>è¡¨ç¤º<b>çŠ¶æ€è½¬ç§»å…³ç³»</b></li>
      </ul>
      <p>å›¾ä¾‹è¯´æ˜:</p>
      <ul>
        <li><b>è“è‰²èƒŒæ™¯èŠ‚ç‚¹</b>: æ™®é€šèŠ‚ç‚¹</li>
        <li><b>ç»¿è‰²èƒŒæ™¯èŠ‚ç‚¹</b>: åŸºç¡€çŠ¶æ€èŠ‚ç‚¹</li>
        <li><b>é»„è‰²èƒŒæ™¯èŠ‚ç‚¹</b>: çŠ¶æ€è½¬ç§»èŠ‚ç‚¹(æ˜¾ç¤ºä¸º"ç¼–å·â†’åç§°"æ ¼å¼)</li>
        <li><b>å®çº¿ç®­å¤´</b>: æ™®é€šå±‚çº§å…³ç³»</li>
        <li><b>è™šçº¿ç®­å¤´</b>: çŠ¶æ€è½¬ç§»å…³ç³»</li>
        <li><b>ç»¿è‰²æ–¹æ¡†</b>: åŒ…å«åŸºç¡€çŠ¶æ€åŠå…¶ç‚¹å·å­èŠ‚ç‚¹çš„å­å›¾</li>
        <li><b>å¯ç‚¹å‡»èŠ‚ç‚¹</b>: é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºä¸ºæ‰‹å‹å…‰æ ‡ï¼Œç‚¹å‡»å¯å¯¼èˆªåˆ°å¯¹åº”ç¬”è®°</li>
      </ul>
      <p>ç¼©æ”¾æ“ä½œè¯´æ˜:</p>
      <ul>
        <li><b>æ”¾å¤§/ç¼©å°æŒ‰é’®</b>: ç‚¹å‡»æŒ‰é’®æ”¾å¤§æˆ–ç¼©å°å›¾è¡¨</li>
        <li><b>é‡ç½®æŒ‰é’®</b>: æ¢å¤åŸå§‹å¤§å°</li>
        <li><b>é”®ç›˜+é¼ æ ‡</b>: Ctrl+æ»šè½®è¿›è¡Œå›¾è¡¨ç¼©æ”¾</li>
        <li><b>æ‹–æ‹½</b>: Alt+å·¦é”®æ‹–æ‹½æˆ–ä¸­é”®æ‹–æ‹½è¿›è¡Œå¹³ç§»</li>
      </ul>
    </details>
  `;
  
  // çŠ¶æ€ä¿¡æ¯
  const statusDiv = container.createEl("div", { cls: "status-info" });
  statusDiv.style.marginBottom = "10px";
  statusDiv.style.fontSize = "0.9em";
  
  // å›¾è¡¨å®¹å™¨
  const diagramContainer = container.createEl("div", { cls: "diagram-container" });
  diagramContainer.style.border = "1px solid #ccc";
  diagramContainer.style.padding = "10px";
  diagramContainer.style.minHeight = "500px";
  diagramContainer.style.position = "relative";
  diagramContainer.style.overflowX = "auto";
  diagramContainer.style.overflowY = "visible";
  diagramContainer.style.maxHeight = "none";

  const outerContainer = container.closest('.mermaid-content') || container;
  if (outerContainer) {
    outerContainer.addEventListener('scroll', () => {
      const state = ensureMermaidGraphState();
      state.outerScrollLeft = outerContainer.scrollLeft;
      state.outerScrollTop = outerContainer.scrollTop;
      persistMermaidGraphState();
    });
  }
  
  // ä»£ç åˆ‡æ¢æŒ‰é’®
  const toggleButton = container.createEl("button", { text: "æ˜¾ç¤º/éšè—Mermaidä»£ç " });
  toggleButton.style.marginTop = "10px";
  
  // ä»£ç å®¹å™¨
  const codeContainer = container.createEl("div", { cls: "code-container" });
  codeContainer.style.display = "none";
  codeContainer.style.border = "1px solid #ccc";
  codeContainer.style.padding = "10px";
  codeContainer.style.marginTop = "10px";
  codeContainer.style.backgroundColor = "#f8f8f8";
  codeContainer.style.fontFamily = "monospace";
  codeContainer.style.fontSize = "0.9em";
  codeContainer.style.overflow = "auto";
  codeContainer.style.maxHeight = "300px";
  codeContainer.style.whiteSpace = "pre";
  
  // ä»£ç å¤åˆ¶æŒ‰é’®
  const copyButton = container.createEl("button", { text: "å¤åˆ¶ä»£ç " });
  copyButton.style.marginTop = "5px";
  copyButton.style.display = "none";
  
  // æ·»åŠ ç¼©æ”¾æ§åˆ¶
  const zoomControls = CONFIG.enableZoom ? setupZoomControls(container, diagramContainer) : null;
  
  // æ›´æ–°æŒ‰é’®äº‹ä»¶
  updateButton.addEventListener("click", () => {
    CONFIG.targetNode = nodeInput.value;
    CONFIG.maxDepth = parseInt(depthInput.value);
    CONFIG.layout = layoutSelect.value;
    CONFIG.addInvisibleNodes = invisibleCheck.checked;
    CONFIG.showAllDescendants = showAllCheck.checked;
    CONFIG.showFullIds = showFullIdsCheck.checked;
    CONFIG.enableZoom = zoomCheck.checked;
    CONFIG.debug = debugCheck.checked;
    
    renderDiagram(container, statusDiv, diagramContainer, codeContainer, zoomControls);
  });
  
  // åˆ‡æ¢ä»£ç æ˜¾ç¤º
  toggleButton.addEventListener("click", () => {
    if (codeContainer.style.display === "none") {
      codeContainer.style.display = "block";
      copyButton.style.display = "inline-block";
    } else {
      codeContainer.style.display = "none";
      copyButton.style.display = "none";
    }
  });
  
  // å¤åˆ¶ä»£ç 
  copyButton.addEventListener("click", () => {
    const code = codeContainer.textContent;
    try {
      // ä½¿ç”¨clipboard APIå¤åˆ¶
      navigator.clipboard.writeText(code).then(() => {
        statusDiv.textContent = "ä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿";
        setTimeout(() => {
          if (statusDiv.textContent === "ä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿") {
            statusDiv.textContent = "";
          }
        }, 2000);
      });
    } catch (err) {
      statusDiv.textContent = "å¤åˆ¶å¤±è´¥: " + err.message;
    }
  });
  
  return { statusDiv, diagramContainer, codeContainer, zoomControls };
}

// æ·»åŠ ç¼©æ”¾åŠŸèƒ½
// ===== UI å’Œä¸»ç¨‹åº =====
// ... (Your other functions remain the same)

/**
 * setupZoomControls (Final Version with State Saving)
 * Sets up zoom and pan controls, and now saves the view state
 * to a global object on every interaction.
 * @param {HTMLElement} container The main container element.
 * @param {HTMLElement} diagramContainer The container for the Mermaid SVG.
 * @returns {object} An object with control functions.
 */
/**
 * setupZoomControls (Final Version)
 * Sets up zoom/pan and saves the view state to a global object.
 * This version is enhanced to correctly initialize from the global state.
 */
/**
 * setupZoomControls (Final, Perfected Version)
 * Implements a smooth, center-focused zoom by dynamically adjusting
 * scroll positions to keep the viewport's center stationary.
 */
function setupZoomControls(container, diagramContainer) {
    // ç¡®ä¿å…¨å±€çŠ¶æ€å¯¹è±¡å­˜åœ¨,å¹¶ä½¿ç”¨æŒä¹…åŒ–å­˜å‚¨
    if (!window.mermaidGraphState) {
        // å°è¯•ä» localStorage æ¢å¤çŠ¶æ€
        const storedState = localStorage.getItem('mermaidGraphState');
        if (storedState) {
            try {
                window.mermaidGraphState = JSON.parse(storedState);
                console.log('[çŠ¶æ€æ¢å¤] ä» localStorage æ¢å¤çŠ¶æ€:', window.mermaidGraphState);
            } catch (e) {
                console.warn('[çŠ¶æ€æ¢å¤] localStorage è§£æå¤±è´¥,ä½¿ç”¨é»˜è®¤å€¼');
                window.mermaidGraphState = {
                    zoom: CONFIG.initialZoom,
                    scrollLeft: 0,
                    scrollTop: 0,
                    panX: 0,
                    panY: 0,
                    outerScrollLeft: 0,
                    outerScrollTop: 0
                };
            }
        } else {
            window.mermaidGraphState = {
                zoom: CONFIG.initialZoom,
                scrollLeft: 0,
                scrollTop: 0,
                panX: 0,
                panY: 0,
                outerScrollLeft: 0,
                outerScrollTop: 0
            };
        }
    }
    if (window.mermaidGraphState.panX == null) window.mermaidGraphState.panX = 0;
    if (window.mermaidGraphState.panY == null) window.mermaidGraphState.panY = 0;
    if (window.mermaidGraphState.outerScrollLeft == null) window.mermaidGraphState.outerScrollLeft = 0;
    if (window.mermaidGraphState.outerScrollTop == null) window.mermaidGraphState.outerScrollTop = 0;
    if (window.mermaidGraphState.scrollLeft == null) window.mermaidGraphState.scrollLeft = 0;
    if (window.mermaidGraphState.scrollTop == null) window.mermaidGraphState.scrollTop = 0;
    if (window.mermaidGraphState.zoom == null) window.mermaidGraphState.zoom = CONFIG.initialZoom;

    // ä»ä¿å­˜çš„çŠ¶æ€å¼€å§‹
    let currentZoom = window.mermaidGraphState.zoom || CONFIG.initialZoom;

    // --- UI Element Creation (no changes here) ---
    const zoomControls = container.createEl("div", { cls: "zoom-controls" });
    zoomControls.style.marginTop = "10px";
    zoomControls.style.marginBottom = "10px";
    zoomControls.style.display = "flex";
    zoomControls.style.alignItems = "center";
    const zoomOutBtn = zoomControls.createEl("button", { text: "â–" });
    const zoomResetBtn = zoomControls.createEl("button", { text: "é‡ç½®" });
    const zoomInBtn = zoomControls.createEl("button", { text: "â•" });
    const zoomDisplay = zoomControls.createEl("span");
    zoomOutBtn.style.margin = "0 5px";
    zoomResetBtn.style.margin = "0 5px";
    zoomInBtn.style.margin = "0 5px";
    zoomDisplay.style.minWidth = "60px";
    zoomDisplay.style.textAlign = "center";

    // This function now *only* handles the visual update of the scale and text
    function updateZoomVisuals() {
        zoomDisplay.textContent = `${Math.round(currentZoom * 100)}%`;
        const svgElement = diagramContainer.querySelector("svg");
        if (svgElement) {
            const panX = window.mermaidGraphState?.panX || 0;
            const panY = window.mermaidGraphState?.panY || 0;
            // The transform-origin is now handled by scroll adjustments,
            // but setting it to top-left ensures consistency.
            svgElement.style.transformOrigin = "top left";
            svgElement.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
            
            // Adjust container height to prevent scrollbars from jumping
            const newHeight = svgElement.getBoundingClientRect().height;
            if (newHeight > 0) {
                 diagramContainer.style.height = `${newHeight + 40}px`;
            }
        }
    }

    /**
     * **THE CORE LOGIC FOR CENTERED ZOOM**
     * This function applies the new zoom level and calculates the
     * required scroll offset to keep the view centered.
     */
    function applyZoom(newZoom) {
        // 1. Get viewport center and current scroll position (before zooming)
        const viewportCenterX = diagramContainer.clientWidth / 2;
        const viewportCenterY = diagramContainer.clientHeight / 2;
        const scrollLeftBefore = diagramContainer.scrollLeft;
        const scrollTopBefore = diagramContainer.scrollTop;

        // 2. Calculate which point on the un-scaled SVG is currently at the viewport center
        const pointX = (scrollLeftBefore + viewportCenterX) / currentZoom;
        const pointY = (scrollTopBefore + viewportCenterY) / currentZoom;

        // 3. Update to the new zoom level
        currentZoom = Math.max(0.1, newZoom);
        window.mermaidGraphState.zoom = currentZoom; // Save state
        // ä¿å­˜åˆ° localStorage
        saveStateToLocalStorage();

        // 4. Apply the visual scale change
        updateZoomVisuals();

        // 5. Calculate the new scroll positions needed to bring the target point back to the center
        const newScrollLeft = (pointX * currentZoom) - viewportCenterX;
        const newScrollTop = (pointY * currentZoom) - viewportCenterY;

        // 6. Apply the new scroll positions
        diagramContainer.scrollLeft = newScrollLeft;
        diagramContainer.scrollTop = newScrollTop;

        // ä¿å­˜æ»šåŠ¨çŠ¶æ€
        window.mermaidGraphState.scrollLeft = newScrollLeft;
        window.mermaidGraphState.scrollTop = newScrollTop;
        saveStateToLocalStorage();
    }

    function zoomIn() { applyZoom(currentZoom + CONFIG.zoomStep); }
    function zoomOut() { applyZoom(currentZoom - CONFIG.zoomStep); }
    function resetZoom() { applyZoom(CONFIG.initialZoom); }

    zoomInBtn.addEventListener("click", zoomIn);
    zoomOutBtn.addEventListener("click", zoomOut);
    zoomResetBtn.addEventListener("click", resetZoom);

    // --- Event Listeners (Mouse Wheel, Drag, and Scroll Saving) ---
    // The mouse wheel now uses the same advanced applyZoom logic
    diagramContainer.addEventListener("wheel", (event) => {
        if (event.ctrlKey) {
            event.preventDefault();
            const newZoom = event.deltaY < 0 
                ? currentZoom + CONFIG.zoomStep 
                : currentZoom - CONFIG.zoomStep;
            applyZoom(newZoom);
        }
    }, { passive: false });

    // ä¿å­˜æ»šåŠ¨çŠ¶æ€å¹¶æŒä¹…åŒ–åˆ° localStorage
    diagramContainer.addEventListener('scroll', () => {
        window.mermaidGraphState.scrollLeft = diagramContainer.scrollLeft;
        window.mermaidGraphState.scrollTop = diagramContainer.scrollTop;
        // ä¿å­˜åˆ° localStorage
        saveStateToLocalStorage();
    });

    // è¾…åŠ©å‡½æ•°: ä¿å­˜çŠ¶æ€åˆ° localStorage
    function saveStateToLocalStorage() {
        try {
            localStorage.setItem('mermaidGraphState', JSON.stringify(window.mermaidGraphState));
        } catch (e) {
            console.warn('[çŠ¶æ€ä¿å­˜] æ— æ³•ä¿å­˜åˆ° localStorage:', e);
        }
    }

    // Panning logic remains unchanged
    let isDragging = false, lastX, lastY;
    diagramContainer.addEventListener("mousedown", (event) => { /* ... */ });
    container.addEventListener("mousemove", (event) => { /* ... */ });
    const stopDragging = () => { /* ... */ };
    container.addEventListener("mouseup", stopDragging);
    container.addEventListener("mouseleave", stopDragging);

    // Final UI setup
    const helpText = zoomControls.createEl("span", { text: "(æç¤º: Ctrl+æ»šè½®ç¼©æ”¾, Alt+æ‹–æ‹½ç§»åŠ¨)" });
    helpText.style.cssText = "font-size: 0.8em; color: #666; margin-left: 15px;";

    // Expose the visual update function for the main renderDiagram call
    return { updateZoomDisplay: updateZoomVisuals };
}




function showToast(message, type = "info") {
  // ç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§æç¤º
  const existingToast = document.getElementById('mermaid-toast');
  if (existingToast) {
    existingToast.remove();
  }
  
  // åˆ›å»ºæç¤ºå…ƒç´ 
  const toast = document.createElement('div');
  toast.id = 'mermaid-toast';
  toast.textContent = message;
  
  // æ ·å¼è®¾ç½®
  toast.style.cssText = `
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    background-color: ${type === 'error' ? '#ff3366' : '#333'};
    color: white;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    z-index: 10000;
    font-size: 14px;
    opacity: 0;
    transition: opacity 0.3s ease;
  `;
  
  // æ·»åŠ åˆ°DOM
  document.body.appendChild(toast);
  
  // æ˜¾ç¤ºæç¤º
  setTimeout(() => {
    toast.style.opacity = '1';
    
    // 3ç§’åæ·¡å‡º
    setTimeout(() => {
      toast.style.opacity = '0';
      
      // å®Œå…¨æ·¡å‡ºåç§»é™¤
      setTimeout(() => {
        toast.remove();
      }, 300);
    }, 3000);
  }, 10);
}











/**
 * [æœ€ç»ˆä¿®æ­£ç‰ˆ] åœ¨å›¾è¡¨ä¸­æŸ¥æ‰¾å¹¶èšç„¦æŒ‡å®šèŠ‚ç‚¹ï¼ŒåŒ…å«å®Œæ•´çš„å®šä½å’Œé«˜äº®é€»è¾‘ã€‚
 * @param {string} nodeId - è¦èšç„¦çš„èŠ‚ç‚¹çš„ç®€åŒ–å DOM ID (ä¾‹å¦‚ 'L2', 'M67')ã€‚
 * @param {HTMLElement} container - Mermaid å›¾æ‰€åœ¨çš„ .diagram-container å…ƒç´ ã€‚
 */
/**
 * [æœ€ç»ˆä¿®å¤ç‰ˆ] åœ¨å›¾è¡¨ä¸­æŸ¥æ‰¾å¹¶èšç„¦æŒ‡å®šèŠ‚ç‚¹
 * - ä½¿ç”¨æ›´å¥å£®çš„å¤šç­–ç•¥å±æ€§é€‰æ‹©å™¨æ¥æŸ¥æ‰¾èŠ‚ç‚¹ï¼Œä»¥åº”å¯¹Mermaidåº“å¯èƒ½ä¿®æ”¹IDçš„æƒ…å†µã€‚
 */
/**
 * [æœ€ç»ˆä¿®å¤ç‰ˆ] åœ¨å›¾è¡¨ä¸­æŸ¥æ‰¾å¹¶èšç„¦æŒ‡å®šèŠ‚ç‚¹
 * - æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨çµæ´»çš„å±æ€§é€‰æ‹©å™¨ [id*="..."] æ¥æŸ¥æ‰¾è¢«Mermaidä¿®æ”¹è¿‡çš„èŠ‚ç‚¹IDã€‚
 * - å®ç°äº†ç¨³å®šã€å±…ä¸­çš„æ»šåŠ¨é€»è¾‘ã€‚
 * - åŒ…å«ä¸€ä¸ªç®€æ´ä½†æœ‰æ•ˆçš„é«˜äº®æ•ˆæœã€‚
 */
/**
 * [ç»ˆæå†…å®¹æŸ¥æ‰¾ç‰ˆ] åœ¨å›¾è¡¨ä¸­æŸ¥æ‰¾å¹¶èšç„¦æŒ‡å®šèŠ‚ç‚¹
 * - æ¥æ”¶å®Œæ•´çš„èŠ‚ç‚¹å¯¹è±¡ã€‚
 * - ä¼˜å…ˆå°è¯•IDæŸ¥æ‰¾ï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œé€šè¿‡åŒ¹é…å…¶æ˜¾ç¤ºçš„æ–‡æœ¬å†…å®¹ï¼ˆé•¿IDï¼‰æ¥æŸ¥æ‰¾ã€‚
 * - å®ç°äº†ç¨³å®šã€å±…ä¸­çš„æ»šåŠ¨å’Œé«˜äº®ã€‚
 */
/**
 * [æœ€ç»ˆå†…å®¹æŸ¥æ‰¾ç‰ˆ] åœ¨å›¾è¡¨ä¸­æŸ¥æ‰¾å¹¶èšç„¦æŒ‡å®šèŠ‚ç‚¹
 * - æ¥æ”¶å®Œæ•´çš„èŠ‚ç‚¹å¯¹è±¡ã€‚
 * - ä¼˜å…ˆå°è¯•IDæŸ¥æ‰¾ï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œé€šè¿‡åŒ¹é…å…¶æ˜¾ç¤ºçš„æ–‡æœ¬å†…å®¹ï¼ˆé•¿IDï¼‰æ¥æŸ¥æ‰¾ã€‚
 * - å®ç°äº†ç¨³å®šã€å±…ä¸­çš„æ»šåŠ¨å’Œé«˜äº®ã€‚
 */
/**
 * [å®¹å™¨å†…å±…ä¸­ç‰ˆ] åœ¨å›¾è¡¨ä¸­æŸ¥æ‰¾å¹¶èšç„¦æŒ‡å®šèŠ‚ç‚¹
 * - ä»…åœ¨å›¾è¡¨å®¹å™¨å†…è®¡ç®—æ»šåŠ¨ï¼Œé¿å…è§¦å‘ä¸»çª—æ ¼æ»šåŠ¨å¯¼è‡´çœ©æ™•ã€‚
 * - ç›´æ¥å®šä½åˆ°å±å¹•ä¸­å¿ƒï¼ˆä¸ä½¿ç”¨ scrollIntoView å¹³æ»‘æ»šåŠ¨ï¼‰ã€‚
 */
function ensureMermaidGraphState() {
    if (!window.mermaidGraphState) {
        window.mermaidGraphState = {
            zoom: CONFIG.initialZoom,
            scrollLeft: 0,
            scrollTop: 0,
            panX: 0,
            panY: 0,
            outerScrollLeft: 0,
            outerScrollTop: 0
        };
    }
    if (window.mermaidGraphState.zoom == null) window.mermaidGraphState.zoom = CONFIG.initialZoom;
    if (window.mermaidGraphState.scrollLeft == null) window.mermaidGraphState.scrollLeft = 0;
    if (window.mermaidGraphState.scrollTop == null) window.mermaidGraphState.scrollTop = 0;
    if (window.mermaidGraphState.panX == null) window.mermaidGraphState.panX = 0;
    if (window.mermaidGraphState.panY == null) window.mermaidGraphState.panY = 0;
    if (window.mermaidGraphState.outerScrollLeft == null) window.mermaidGraphState.outerScrollLeft = 0;
    if (window.mermaidGraphState.outerScrollTop == null) window.mermaidGraphState.outerScrollTop = 0;
    return window.mermaidGraphState;
}

function persistMermaidGraphState() {
    try {
        localStorage.setItem('mermaidGraphState', JSON.stringify(window.mermaidGraphState));
    } catch (e) {
        console.warn('[çŠ¶æ€ä¿å­˜] æ— æ³•ä¿å­˜åˆ° localStorage:', e);
    }
}

function centerElementInDiagram(nodeElement, container, options = {}) {
    if (!nodeElement || !container) return;
    const behavior = options.behavior || "auto";
    const containerRect = container.getBoundingClientRect();
    const nodeRect = nodeElement.getBoundingClientRect();
    const outerContainer = container.closest('.mermaid-content');
    const outerRect = outerContainer ? outerContainer.getBoundingClientRect() : null;

    const targetLeft = nodeRect.left - containerRect.left + container.scrollLeft + (nodeRect.width / 2) - (container.clientWidth / 2);
    const targetTop = nodeRect.top - containerRect.top + container.scrollTop + (nodeRect.height / 2) - (container.clientHeight / 2);

    const maxScrollLeft = Math.max(0, container.scrollWidth - container.clientWidth);
    const maxScrollTop = Math.max(0, container.scrollHeight - container.clientHeight);
    const canScrollX = maxScrollLeft > 1;
    const canScrollY = maxScrollTop > 1;
    const outerCanScrollX = outerContainer ? (outerContainer.scrollWidth - outerContainer.clientWidth > 1) : false;
    const outerCanScrollY = outerContainer ? (outerContainer.scrollHeight - outerContainer.clientHeight > 1) : false;
    const clampedLeft = Math.min(Math.max(0, targetLeft), maxScrollLeft);
    const clampedTop = Math.min(Math.max(0, targetTop), maxScrollTop);

    if (canScrollX || canScrollY) {
        if (typeof container.scrollTo === "function") {
            container.scrollTo({
                left: canScrollX ? clampedLeft : container.scrollLeft,
                top: canScrollY ? clampedTop : container.scrollTop,
                behavior
            });
        } else {
            if (canScrollX) container.scrollLeft = clampedLeft;
            if (canScrollY) container.scrollTop = clampedTop;
        }
    }

    if ((!canScrollX || !canScrollY) && outerContainer && outerRect) {
        const outerTargetLeft = nodeRect.left - outerRect.left + outerContainer.scrollLeft + (nodeRect.width / 2) - (outerContainer.clientWidth / 2);
        const outerTargetTop = nodeRect.top - outerRect.top + outerContainer.scrollTop + (nodeRect.height / 2) - (outerContainer.clientHeight / 2);
        const outerMaxLeft = Math.max(0, outerContainer.scrollWidth - outerContainer.clientWidth);
        const outerMaxTop = Math.max(0, outerContainer.scrollHeight - outerContainer.clientHeight);
        const outerLeft = Math.min(Math.max(0, outerTargetLeft), outerMaxLeft);
        const outerTop = Math.min(Math.max(0, outerTargetTop), outerMaxTop);

        if (!canScrollX && outerCanScrollX) {
            outerContainer.scrollLeft = outerLeft;
        }
        if (!canScrollY && outerCanScrollY) {
            outerContainer.scrollTop = outerTop;
        }
    }

    const state = ensureMermaidGraphState();
    const deltaX = !canScrollX
        ? (containerRect.left + container.clientWidth / 2) - (nodeRect.left + nodeRect.width / 2)
        : 0;
    const deltaY = !canScrollY
        ? (containerRect.top + container.clientHeight / 2) - (nodeRect.top + nodeRect.height / 2)
        : 0;
    const canScrollXEffective = canScrollX || outerCanScrollX;
    const canScrollYEffective = canScrollY || outerCanScrollY;
    const nextPanX = canScrollXEffective ? 0 : state.panX + deltaX;
    const nextPanY = canScrollYEffective ? 0 : state.panY + deltaY;
    const panChanged = nextPanX !== state.panX || nextPanY !== state.panY;
    if (panChanged) {
        state.panX = nextPanX;
        state.panY = nextPanY;

        const svgElement = container.querySelector("svg");
        if (svgElement) {
            const zoom = state.zoom || CONFIG.initialZoom;
            svgElement.style.transformOrigin = "top left";
            svgElement.style.transform = `translate(${nextPanX}px, ${nextPanY}px) scale(${zoom})`;
        }
        persistMermaidGraphState();
    }
}

/**
 * [ç»ˆææ™ºèƒ½æ»šåŠ¨ç‰ˆ] åœ¨å›¾è¡¨ä¸­æŸ¥æ‰¾å¹¶èšç„¦æŒ‡å®šèŠ‚ç‚¹
 * - æ”¹ä¸ºä»…åœ¨å›¾è¡¨å®¹å™¨å†…æ»šåŠ¨ï¼Œé¿å…ä¸»çª—å£æ»šåŠ¨ã€‚
 */
function focusNodeInChart(nodeObject, container) {
    try {
        const simpleId = nodeObject.simpleId;
        const longId = nodeObject.id;
        console.log(`[focus] å°è¯•èšç„¦èŠ‚ç‚¹ï¼Œç®€åŒ–ID: ${simpleId}, é•¿ID: ${longId}`);
        
        let nodeElement = null;
        let svgContainer = container.querySelector('.mermaid') || container.querySelector('svg.mermaid');

        if (!svgContainer) {
            showToast("é”™è¯¯: åœ¨å›¾è¡¨å®¹å™¨ä¸­æ‰¾ä¸åˆ°SVGå…ƒç´ ", "error");
            return;
        }

        // æŸ¥æ‰¾èŠ‚ç‚¹çš„é€»è¾‘ä¿æŒä¸å˜ï¼Œå› ä¸ºå®ƒå·²ç»å¾ˆå¥å£®äº†
        nodeElement = svgContainer.querySelector(`[id*="${simpleId}"]`);
        if (!nodeElement) {
            console.warn(`[focus] IDæŸ¥æ‰¾å¤±è´¥ï¼Œå¯åŠ¨å†…å®¹æŸ¥æ‰¾ç­–ç•¥...`);
            const allGraphNodes = svgContainer.querySelectorAll('.node, .cluster');
            for (const graphNode of allGraphNodes) {
                if ((graphNode.textContent || "").includes(longId)) {
                    nodeElement = graphNode;
                    break;
                }
            }
        }
        
        if (!nodeElement) {
            console.error(`[focus] æ‰€æœ‰æŸ¥æ‰¾ç­–ç•¥å‡å¤±è´¥ï¼Œæ— æ³•åœ¨DOMä¸­å®šä½èŠ‚ç‚¹ ${simpleId}`);
            showToast(`æ— æ³•åœ¨å›¾è¡¨ä¸­å®šä½èŠ‚ç‚¹: ${simpleId}`, "error");
            return;
        }
        console.log('[focus] æˆåŠŸæ‰¾åˆ°DOMèŠ‚ç‚¹:', nodeElement);

        // åœ¨å›¾è¡¨å®¹å™¨å†…å±…ä¸­ï¼ˆä¸è§¦å‘ä¸»çª—å£æ»šåŠ¨ï¼‰
        console.log('[focus] åœ¨å›¾è¡¨å®¹å™¨å†…å±…ä¸­èŠ‚ç‚¹ï¼ˆæ— ä¸»çª—å£æ»šåŠ¨ï¼‰');
        centerElementInDiagram(nodeElement, container, { behavior: "auto" });

        // --- é«˜äº®æ•ˆæœä¿æŒä¸å˜ ---
        const shape = nodeElement.querySelector('rect, circle, polygon, ellipse, path');
        if (shape) {
            const originalStroke = shape.style.stroke;
            const originalStrokeWidth = shape.style.strokeWidth;
            
            shape.style.transition = 'all 0.3s ease-in-out';
            shape.style.stroke = '#F37021'; // é†’ç›®çš„æ©™è‰²
            shape.style.strokeWidth = '4px';
            
            setTimeout(() => {
                shape.style.stroke = originalStroke;
                shape.style.strokeWidth = originalStrokeWidth;
            }, 3000);
        }
        
    } catch (error) {
        console.error('èšç„¦èŠ‚ç‚¹æ—¶å‡ºé”™:', error);
    }
}

function highlightNodeOnce(nodeObject, container, durationMs = 5000) {
    if (!nodeObject || !container) return;
    try {
        const simpleId = nodeObject.simpleId;
        const longId = nodeObject.id;
        let nodeElement = null;
        const svgContainer = container.querySelector('.mermaid') || container.querySelector('svg.mermaid');
        if (!svgContainer) return;

        nodeElement = svgContainer.querySelector(`[id*="${simpleId}"]`);
        if (!nodeElement) {
            const allGraphNodes = svgContainer.querySelectorAll('.node, .cluster');
            for (const graphNode of allGraphNodes) {
                if ((graphNode.textContent || "").includes(longId)) {
                    nodeElement = graphNode;
                    break;
                }
            }
        }
        if (!nodeElement) return;

        const shape = nodeElement.querySelector('rect, circle, polygon, ellipse, path');
        if (!shape) return;

        const original = {
            fill: shape.style.fill,
            stroke: shape.style.stroke,
            strokeWidth: shape.style.strokeWidth,
            filter: shape.style.filter,
            transition: shape.style.transition
        };

        shape.style.transition = 'all 0.2s ease-in-out';
        shape.style.fill = '#FFF4B8';
        shape.style.stroke = '#D8A700';
        shape.style.strokeWidth = '3px';
        shape.style.filter = 'drop-shadow(0 0 6px rgba(255, 220, 100, 0.8))';

        setTimeout(() => {
            shape.style.fill = original.fill;
            shape.style.stroke = original.stroke;
            shape.style.strokeWidth = original.strokeWidth;
            shape.style.filter = original.filter;
            shape.style.transition = original.transition;
        }, durationMs);
    } catch (error) {
        console.error('é«˜äº®èŠ‚ç‚¹æ—¶å‡ºé”™:', error);
    }
}

function centerNodeInChart(nodeObject, container) {
    if (!nodeObject || !container) return;
    try {
        const simpleId = nodeObject.simpleId;
        const longId = nodeObject.id;
        let nodeElement = null;
        const svgContainer = container.querySelector('.mermaid') || container.querySelector('svg.mermaid');
        if (!svgContainer) return;

        nodeElement = svgContainer.querySelector(`[id*="${simpleId}"]`);
        if (!nodeElement) {
            const allGraphNodes = svgContainer.querySelectorAll('.node, .cluster');
            for (const graphNode of allGraphNodes) {
                if ((graphNode.textContent || "").includes(longId)) {
                    nodeElement = graphNode;
                    break;
                }
            }
        }
        if (!nodeElement) return;

        centerElementInDiagram(nodeElement, container, { behavior: "auto" });
    } catch (error) {
        console.error('å±…ä¸­èŠ‚ç‚¹æ—¶å‡ºé”™:', error);
    }
}







/**
 * æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 */
/**
 * [å·²ä¿®æ­£] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 */
/**
 * [æœ€ç»ˆä¿®æ­£ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 */
/**
 * [æœ€ç»ˆä¿®æ­£ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - ä¿®æ­£äº†IDæå–é€»è¾‘ï¼Œæ”¹ç”¨æ›´å¯é çš„ data-path å±æ€§ã€‚
 * - å¢å¼ºäº†æ—¥å¿—è¾“å‡ºï¼Œæ–¹ä¾¿è¿½è¸ªã€‚
 */
/**
 * [æœ€ç»ˆå†³å®šç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 *  - ä¿®æ­£äº†IDæå–é€»è¾‘ï¼Œç¡®ä¿ä» data-path ä¸­è·å–å®Œæ•´çš„é•¿IDã€‚
 *  - å®ç°äº†æ­£ç¡®çš„â€œç¿»è¯‘â€æ­¥éª¤ï¼Œä½¿ç”¨å…¨å±€è¯‘ç æœ¬å°†é•¿IDè½¬æ¢ä¸ºç®€åŒ–IDã€‚
 *  - å¢åŠ äº†è¯¦ç»†çš„æ—¥å¿—ï¼Œä¾¿äºè¿½è¸ªæ¯ä¸€æ­¥çš„æ‰§è¡Œæƒ…å†µã€‚
 */
/**
 * [æœ€ç»ˆä¿®æ­£ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - ä¿®æ­£äº†å®¹å™¨å’Œè¡Œé¡¹ç›®çš„é€‰æ‹©å™¨é€»è¾‘ï¼Œä½¿å…¶æ›´åŠ å¥å£®ã€‚
 * - å¢å¼ºäº†æ—¥å¿—è¾“å‡ºï¼Œæ–¹ä¾¿è¿½è¸ªã€‚
 * - ç¡®ä¿ä» data-path å±æ€§ä¸­å¯é åœ°æå–IDã€‚
 */
/**
 * [æœ€ç»ˆè°ƒè¯•ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - å¢åŠ äº†æå…¶è¯¦ç»†çš„æ—¥å¿—ï¼Œç”¨äºè¿½è¸ªIDæå–å’Œç¿»è¯‘çš„å…¨è¿‡ç¨‹ã€‚
 */
/**
 * [å·²ä¿®æ­£] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 */
/**
 * [å·²ä¿®æ­£] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 */
/**
 * [æœ€ç»ˆä¿®æ­£ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - ä¿®æ­£äº†IDæå–é€»è¾‘ï¼Œæ”¹ç”¨æ›´å¯é çš„ data-path å±æ€§ã€‚
 * - å¢å¼ºäº†æ—¥å¿—è¾“å‡ºï¼Œæ–¹ä¾¿è¿½è¸ªã€‚
 */
/**
 * [æœ€ç»ˆä¼˜åŒ–ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - åŸºäºæ‚¨çš„å¯ç”¨ç‰ˆæœ¬è¿›è¡Œä¿®æ”¹ã€‚
 * - å¼•å…¥äº†æ›´å¯é çš„â€œçª—æ ¼â€å’Œâ€œè¡Œé¡¹ç›®â€å®šä½é€»è¾‘ã€‚
 * - ä¿ç•™å¹¶å¢å¼ºäº†æ‚¨ç‰ˆæœ¬ä¸­å·²æœ‰çš„æ—¥å¿—å’Œé«˜äº®åŠŸèƒ½ã€‚
 */
/**
 * [ç»ˆæè°ƒè¯•ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - åœ¨æ¯ä¸€ä¸ªå…³é”®æ­¥éª¤éƒ½æ·»åŠ äº†è¯¦ç»†çš„æ—¥å¿—è¾“å‡ºã€‚
 */
/**
 * [ç»ˆæè¡¨æ ¼ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - æ ¸å¿ƒé€»è¾‘å·²ä¿®æ”¹ä¸ºä¸“é—¨æŸ¥æ‰¾è¡¨æ ¼è¡Œ <tr>ï¼Œä¸å†ä½¿ç”¨ data-pathã€‚
 * - ID æå–é€»è¾‘åŒæ­¥ä¿®æ”¹ä¸ºä»è¡Œå†…çš„é“¾æ¥ <a> æ–‡æœ¬ä¸­è·å–ã€‚
 * - ä¿ç•™äº†æ‰€æœ‰è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—ã€‚
 */
/**
 * [æœ€ç»ˆæ™ºèƒ½ç‰ˆ] æŸ¥æ‰¾å³ä¾§åˆ—è¡¨çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­æ˜¾ç¤ºã€‚
 * - æ— éœ€ä¿®æ”¹ç¬”è®°ï¼Œæ— éœ€æ·»åŠ  cssclassesã€‚
 * - æ™ºèƒ½åœ°æŸ¥æ‰¾å¦ä¸€ä¸ªâ€œå¯è§çš„â€çª—æ ¼ä½œä¸ºåˆ—è¡¨ç›®æ ‡ï¼Œé¿å…é€‰ä¸­éšè—çš„æ ‡ç­¾é¡µã€‚
 */
/**
 * [æœ€ç»ˆç²¾ç¡®åˆ¶å¯¼ç‰ˆ] æŸ¥æ‰¾æŒ‡å®šç¬”è®°è§†å›¾çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­ã€‚
 * - é€šè¿‡ç¡¬ç¼–ç çš„æ–‡ä»¶è·¯å¾„ç›´æ¥å®šä½åˆ—è¡¨çª—æ ¼ï¼Œä¸å†è¿›è¡Œä»»ä½•è‡ªåŠ¨æ£€æµ‹ã€‚
 * - è¿™æ˜¯æœ€ç¨³å®šã€æœ€å¯é çš„å®ç°æ–¹å¼ã€‚
 */
/**
 * [æœ€ç»ˆç²¾ç¡®åˆ¶å¯¼ç‰ˆ] æŸ¥æ‰¾æŒ‡å®šç¬”è®°è§†å›¾çš„ä¸­å¿ƒèŠ‚ç‚¹ï¼Œå¹¶åœ¨ Mermaid è§†å›¾ä¸­å±…ä¸­ã€‚
 * - é€šè¿‡ç¡¬ç¼–ç çš„æ–‡ä»¶è·¯å¾„ç›´æ¥å®šä½åˆ—è¡¨çª—æ ¼ã€‚
 * - æŸ¥æ‰¾é€»è¾‘åŸºäº <tr>ï¼Œå¹¶ä» <a> æ ‡ç­¾ä¸­æå–IDã€‚
 * - è°ƒç”¨èšç„¦å‡½æ•°æ—¶ä¼ é€’å®Œæ•´çš„èŠ‚ç‚¹å¯¹è±¡ï¼Œä»¥æ”¯æŒå†…å®¹æŸ¥æ‰¾ã€‚
 */
/**
 * [æœ€ç»ˆæ™ºèƒ½å…³è”ç‰ˆ] æŸ¥æ‰¾å¹¶èšç„¦èŠ‚ç‚¹
 * - æ ¸å¿ƒä¿®æ­£ï¼šåœ¨é€šè¿‡æ–‡ä»¶è·¯å¾„æ‰¾åˆ°åˆ—è¡¨çª—æ ¼åï¼Œå†å»å¯»æ‰¾ä¸€ä¸ªâ€œå¯è§çš„ã€éåˆ—è¡¨çš„â€å›¾è¡¨çª—æ ¼ï¼Œç¡®ä¿ä¸¤è€…æ­£ç¡®é…å¯¹ã€‚
 */
function findCenterNoteAndFocus() {
    console.log('[è°ƒè¯•] findCenterNoteAndFocus å‡½æ•°è¢«è°ƒç”¨');
    try {
        // ==================== é…ç½®åŒº ====================
        // è¯·ç¡®ä¿è¿™ä¸ªè·¯å¾„ä¸æ‚¨çš„åˆ—è¡¨ç¬”è®°åœ¨ä¿é™©åº“ä¸­çš„å®Œæ•´è·¯å¾„å®Œå…¨ä¸€è‡´ï¼
        const TARGET_LIST_FILE_PATH = 'é¡¹ç›®/18-æˆ˜ç•¥è§†å›¾è¿­ä»£/18E-GTDå¤¹å­/18E1-ä¸‹ä¸€æ­¥ä»£åŠäº‹é¡¹æ¸…å•æ–‡ä»¶å¤¹/ä¸‹ä¸€æ­¥ä»£åŠçš„liner chain/ATOMè§†å›¾å•¦.md';
        // ==============================================

        // --- ç²¾å‡†å®šä½åˆ—è¡¨çª—æ ¼ ---
        let listLeaf = null;
        app.workspace.getLeavesOfType('markdown').forEach(leaf => {
            if (leaf.view.file && leaf.view.file.path === TARGET_LIST_FILE_PATH) {
                listLeaf = leaf;
            }
        });

        if (!listLeaf) {
            showToast("é”™è¯¯: ç›®æ ‡åˆ—è¡¨ç¬”è®°æœªæ‰“å¼€æˆ–è·¯å¾„ä¸åŒ¹é…", "error");
            console.error(`[è°ƒè¯•å¤±è´¥] æœªèƒ½æ‰¾åˆ°æ­£åœ¨æ˜¾ç¤º "${TARGET_LIST_FILE_PATH}" çš„çª—æ ¼ã€‚`);
            return;
        }
        console.log('[è°ƒè¯•æˆåŠŸ] 1. ç²¾å‡†å®šä½äº†åˆ—è¡¨çª—æ ¼ã€‚');

        // --- æ ¸å¿ƒä¿®æ­£ï¼šæ™ºèƒ½æŸ¥æ‰¾ä¸åˆ—è¡¨é…å¯¹çš„â€œå¯è§â€å›¾è¡¨çª—æ ¼ ---
        let diagramContainer = null;
        const allLeaves = Array.from(document.querySelectorAll('.workspace-leaf'));
        for (const leaf of allLeaves) {
            const container = leaf.querySelector('.diagram-container');
            const isVisible = leaf.offsetParent !== null;
            // å…³é”®ï¼šæ£€æŸ¥ leaf.containerEl æ˜¯å¦ä¸æˆ‘ä»¬æ‰¾åˆ°çš„åˆ—è¡¨çª—æ ¼çš„å®¹å™¨å…ƒç´ ç›¸åŒ
            const isNotListLeaf = leaf !== listLeaf.containerEl;

            if (container && isVisible && isNotListLeaf) {
                diagramContainer = container;
                break; 
            }
        }

        if (!diagramContainer) {
            showToast("é”™è¯¯: æœªèƒ½æ‰¾åˆ°ä¸€ä¸ªå¯è§çš„å›¾è¡¨çª—æ ¼ä¸åˆ—è¡¨é…å¯¹", "error");
            console.error('[è°ƒè¯•å¤±è´¥] A. è¯·ç¡®ä¿å›¾è¡¨å’Œåˆ—è¡¨åœ¨ä¸åŒçš„ã€ä¸”éƒ½å¯è§çš„çª—æ ¼ä¸­ã€‚');
            return;
        }
        console.log('[è°ƒè¯•æˆåŠŸ] A. æ™ºèƒ½å…³è”åˆ°äº†å¯è§çš„å›¾è¡¨å®¹å™¨ã€‚');
        
        // --- åç»­æ‰€æœ‰é€»è¾‘ç°åœ¨éƒ½åœ¨100%æ­£ç¡®çš„å®¹å™¨å†…æ‰§è¡Œ ---
        const listContainer = listLeaf.containerEl.querySelector('.view-content') || listLeaf.containerEl;
        const allRows = Array.from(listContainer.querySelectorAll('tr'));
        
        if (allRows.length === 0) {
            showToast("é”™è¯¯: åœ¨åˆ—è¡¨çª—æ ¼ä¸­æœªæ‰¾åˆ°ä»»ä½•è¡¨æ ¼è¡Œ(tr)", "error");
            return;
        }
        console.log(`[è°ƒè¯•æˆåŠŸ] 2. åœ¨ç›®æ ‡çª—æ ¼ä¸­æ‰¾åˆ°äº† ${allRows.length} ä¸ª <tr> å…ƒç´ ã€‚`);
        
        const containerRect = listContainer.getBoundingClientRect();
        const containerCenter = containerRect.top + containerRect.height / 2;
        let closestRow = null; 
        let minDistance = Infinity;
        for (const row of allRows) {
            const rowRect = row.getBoundingClientRect();
            if (rowRect.height === 0) continue;
            const rowCenter = rowRect.top + rowRect.height / 2;
            const distance = Math.abs(rowCenter - containerCenter);
            if (distance < minDistance) { 
                minDistance = distance; 
                closestRow = row; 
            }
        }

        if (!closestRow) {
            showToast("é”™è¯¯: æ— æ³•ç¡®å®šåˆ—è¡¨ä¸­çš„ä¸­å¿ƒè¡Œ", "error");
            return;
        }
        console.log('[è°ƒè¯•æˆåŠŸ] 3. æ‰¾åˆ°äº†ä¸­å¿ƒè¡Œã€‚');

        let fullNodeId = null;
        const linkElement = closestRow.querySelector('a');
        if (linkElement) {
            const idMatch = (linkElement.textContent || "").match(/ATOM@[A-Z0-9\.\+]+/);
            if (idMatch) {
                fullNodeId = idMatch[0];
            }
        }

        if (!fullNodeId) {
            showToast("é”™è¯¯: æ— æ³•ä»ä¸­å¿ƒè¡Œçš„é“¾æ¥ä¸­æå–ID", "error");
            return;
        }
        console.log("[è°ƒè¯•æˆåŠŸ] 4. æå–çš„é•¿IDæ˜¯:", fullNodeId);

        let nodeToFocus = null;
        for (const nodeObject of Object.values(window.stateTransitionNodeIdMap)) {
            if (nodeObject.id === fullNodeId) { 
                nodeToFocus = nodeObject; 
                break; 
            }
        }

        if (!nodeToFocus) {
            showToast(`é”™è¯¯: åœ¨æ˜ å°„è¡¨ä¸­æ‰¾ä¸åˆ°èŠ‚ç‚¹å¯¹è±¡: ${fullNodeId}`, "error");
            return;
        }
        console.log("[è°ƒè¯•æˆåŠŸ] 5. æ‰¾åˆ°äº†å®Œæ•´çš„èŠ‚ç‚¹å¯¹è±¡ã€‚");

        showToast(`æ­£åœ¨èšç„¦: ${nodeToFocus.simpleId}`);
        focusNodeInChart(nodeToFocus, diagramContainer);

    } catch (error) {
        console.error("[findCenterNoteAndFocus] æ•è·åˆ°æœªçŸ¥é”™è¯¯:", error);
        showToast(`å‘ç”Ÿè‡´å‘½é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚`);
    }
}















/**
 * è®¾ç½®å…¨å±€é”®ç›˜å¿«æ·é”®ã€‚
 */
/**
 * è®¾ç½®å…¨å±€é”®ç›˜å¿«æ·é”®ï¼ˆå¿«æ·é”®å·²æ”¹ä¸º 'V'ï¼‰
 */
function setupGlobalKeyboardShortcuts() {
  // é˜²æ­¢é‡å¤æ·»åŠ ç›‘å¬å™¨
  if (window.globalMermaidKeyListenerAdded && window.globalMermaidKeyHandler) {
    return () => {
      document.removeEventListener('keydown', window.globalMermaidKeyHandler);
      window.globalMermaidKeyListenerAdded = false;
      window.globalMermaidKeyHandler = null;
    };
  }
  if (window.globalMermaidKeyListenerAdded && !window.globalMermaidKeyHandler) {
    window.globalMermaidKeyListenerAdded = false;
  }

  const handleKeyDown = (event) => {
    // å½“æŒ‰ä¸‹ 'v' æˆ– 'V' é”®æ—¶è§¦å‘
    if (event.key.toLowerCase() === 'v') {
      // ç¡®ä¿äº‹ä»¶ä¸æ˜¯åœ¨è¾“å…¥æ¡†ã€æ–‡æœ¬åŸŸæˆ–å¯ç¼–è¾‘å…ƒç´ ä¸­è§¦å‘çš„
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable) {
        return;
      }
      
      // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼ˆä¾‹å¦‚åœ¨é¡µé¢ä¸Šè¾“å…¥'v'ï¼‰
      event.preventDefault();
      
      // è°ƒç”¨æ ¸å¿ƒçš„èšç„¦å‡½æ•°
      findCenterNoteAndFocus();
    }
  };

  // å°†ç›‘å¬å™¨ç»‘å®šåˆ° document ä¸Š
  document.addEventListener('keydown', handleKeyDown);
  
  // è®¾ç½®ä¸€ä¸ªå…¨å±€æ ‡å¿—ï¼Œè¡¨ç¤ºå¿«æ·é”®å·²æˆåŠŸè®¾ç½®
  window.globalMermaidKeyListenerAdded = true;
  window.globalMermaidKeyHandler = handleKeyDown;
  
  console.log("å…¨å±€å¿«æ·é”® 'V' å·²æˆåŠŸæ¿€æ´»ã€‚");

  return () => {
    document.removeEventListener('keydown', handleKeyDown);
    window.globalMermaidKeyListenerAdded = false;
    window.globalMermaidKeyHandler = null;
  };
}











// æ¸²æŸ“å›¾è¡¨
async function renderDiagram(container, statusDiv, diagramContainer, codeContainer, zoomControls) {
  statusDiv.textContent = "æ­£åœ¨åŠ è½½æ–‡ä»¶...";

  if (!CONFIG.targetNode || !String(CONFIG.targetNode).trim()) {
    statusDiv.textContent = "æœªæ£€æµ‹åˆ°æ‰€å±å—ï¼Œæ— æ³•ç¡®å®šç›®æ ‡èŠ‚ç‚¹";
    diagramContainer.innerHTML = "<div style=\"color:#d33;padding:10px;\">è¯·åœ¨å½“å‰ç¬”è®° YAML ä¸­è®¾ç½®æ‰€å±å—ï¼Œä¾‹å¦‚ï¼š<br>æ‰€å±å—: \"[[ATOM@xxx- æ ‡é¢˜]]\"</div>";
    return;
  }

  // --- æ–°å¢: åœ¨æ¸²æŸ“å‰ä¿å­˜å½“å‰çŠ¶æ€ ---
  const outerContainer = diagramContainer.closest('.mermaid-content');
  const savedState = {
    zoom: window.mermaidGraphState?.zoom || CONFIG.initialZoom,
    scrollLeft: diagramContainer.scrollLeft || 0,
    scrollTop: diagramContainer.scrollTop || 0,
    panX: window.mermaidGraphState?.panX || 0,
    panY: window.mermaidGraphState?.panY || 0,
    outerScrollLeft: outerContainer ? outerContainer.scrollLeft : 0,
    outerScrollTop: outerContainer ? outerContainer.scrollTop : 0
  };

  try {
    // å‡è®¾ getFiles() å·²ç»è¢«ä¿®æ”¹ï¼Œä¼šè¿”å›åŒ…å« isFolded å±æ€§çš„å¯¹è±¡
    const files = getFiles();
    if (files.length === 0) {
      statusDiv.textContent = "æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶";
      return;
    }
    // æ³¨æ„ï¼šå·²å°†ä¸­æ–‡é€—å·ä¿®æ­£ä¸ºè‹±æ–‡é€—å·
    statusDiv.textContent = `æ‰¾åˆ° ${files.length} ä¸ªæ–‡ä»¶, æ­£åœ¨åˆ†æ...`;
    
    // --- Graph Building (å·²ä¿®æ”¹ä»¥åŒ…å« isFolded å±æ€§) ---
    const nodes = files.map(file => {
      const fileInfo = parseFileInfo(file.file.name);
      return {
        id: fileInfo.id,
        name: fileInfo.name,
        hasStateTransition: fileInfo.hasStateTransition,
        baseState: fileInfo.baseState,
        fileName: file.file.name,
        path: file.file.path,
        mermaidViewComplete: file.mermaidViewComplete,
        mermaidViewBayes: file.mermaidViewBayes,
        mermaidViewStandard: file.mermaidViewStandard,
        mermaidViewPending: file.mermaidViewPending,
        mermaidViewAI: file.mermaidViewAI,
        mermaidViewHighlight: file.mermaidViewHighlight,
        // --- æ–°å¢å±æ€§ ---
        isFolded: file.isFolded 
      };
    });

    nodes.forEach(node => {
      node.parentId = getParentId(node.id);
    });

    const targetNode = nodes.find(node => node.id === CONFIG.targetNode);
    if (!targetNode) {
      statusDiv.textContent = `é”™è¯¯: æ‰¾ä¸åˆ°èŠ‚ç‚¹ "${CONFIG.targetNode}"`;
      diagramContainer.innerHTML = `<div style="color:red;padding:10px;">ç›®æ ‡èŠ‚ç‚¹æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥èŠ‚ç‚¹IDæ˜¯å¦æ­£ç¡®</div>`;
      return;
    }
    const activeNode = ACTIVE_NODE_ID ? nodes.find(node => node.id === ACTIVE_NODE_ID) : null;

    statusDiv.textContent = "æ­£åœ¨æ„å»ºçŠ¶æ€è½¬ç§»å…³ç³»å›¾...";
    const graph = buildStateTransitionGraph(targetNode, nodes, CONFIG.maxDepth);

    // --- æ–°å¢: åˆ›å»ºæŠ˜å å‰ç¼€åˆ—è¡¨ ---
    const foldedPrefixes = nodes
        .filter(n => n.isFolded)
        .map(n => getPureId(n.id)); // å‡è®¾ getPureId() åœ¨æ­¤ä½œç”¨åŸŸå¯ç”¨

    // --- Click Handler (å·²ä¿®æ”¹ä¸ºç›´æ¥æ‰“å¼€ç¬”è®°) ---
    const handleNodeClick = function(nodeId) {
      if (window.stateTransitionNodeIdMap && window.stateTransitionNodeIdMap[nodeId]) {
        const node = window.stateTransitionNodeIdMap[nodeId];
        if (node.path) {
          console.log(`ç‚¹å‡»äº†èŠ‚ç‚¹: ${nodeId} -> æ‰“å¼€æ–‡ä»¶: ${node.path}`);
          // ä½¿ç”¨ Obsidian API ç›´æ¥æ‰“å¼€ç¬”è®°
          app.workspace.openLinkText(node.path, '', false);
          showToast(`æ­£åœ¨æ‰“å¼€: ${node.name || node.fileName}`, "info");
          closeWidget();
        } else if (node.fileName) {
          console.log(`ç‚¹å‡»äº†èŠ‚ç‚¹: ${nodeId} -> æ–‡ä»¶å: ${node.fileName}`);
          // å¦‚æœæ²¡æœ‰ path ä½†æœ‰ fileName,å°è¯•é€šè¿‡æ–‡ä»¶åæ‰“å¼€
          app.workspace.openLinkText(node.fileName, '', false);
          showToast(`æ­£åœ¨æ‰“å¼€: ${node.fileName}`, "info");
          closeWidget();
        } else {
          showToast(`èŠ‚ç‚¹ ${node.name || nodeId} æ²¡æœ‰å…³è”çš„æ–‡ä»¶`, "info");
        }
      } else {
        showToast(`æœªæ‰¾åˆ°èŠ‚ç‚¹ ${nodeId} çš„ç›¸å…³ä¿¡æ¯`, "error");
        console.warn(`æœªæ‰¾åˆ°èŠ‚ç‚¹ ${nodeId} çš„æ˜ å°„ä¿¡æ¯`);
      }
    };

    // --- Mermaid Code Generation and Rendering (å·²ä¿®æ”¹ä»¥ä¼ å…¥ foldedPrefixes) ---
    statusDiv.textContent = "æ­£åœ¨ç”Ÿæˆå›¾è¡¨...";
    // å°† foldedPrefixes ä¼ é€’ç»™ generateMermaidCode
    const mermaidCode = generateMermaidCode(graph, handleNodeClick, foldedPrefixes); 
    codeContainer.textContent = mermaidCode;
    diagramContainer.style.visibility = "hidden";
    diagramContainer.style.opacity = "0";
    diagramContainer.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;

    if (window.mermaid) {
      // æ‚¨çš„åŸå§‹ Mermaid åˆå§‹åŒ–ä»£ç , éå¸¸å®Œç¾
      window.mermaid.initialize({
        startOnLoad: false,
        theme: "default",
        securityLevel: "loose",
        flowchart: {
          useMaxWidth: true,
          htmlLabels: true,
          curve: "basis"
        }
      });
      
      // æ¸²æŸ“è°ƒç”¨ä¿æŒä¸å˜
      await window.mermaid.init(undefined, diagramContainer.querySelector(".mermaid"));
      
      // æ¸²æŸ“åæ›´æ–°çŠ¶æ€æ–‡æœ¬
      statusDiv.textContent = `å›¾è¡¨å·²ç”Ÿæˆï¼Œæ˜¾ç¤º ${graph.nodes.length} ä¸ªèŠ‚ç‚¹, ${graph.subgraphs.length} ä¸ªå­å›¾ï¼ˆå¯ç‚¹å‡»èŠ‚ç‚¹å¯¼èˆªåˆ°å¯¹åº”ç¬”è®°ï¼‰`;

      // **å¢å¼ºç‰ˆ: æ¢å¤è§†å›¾çŠ¶æ€ + æ— è·³åŠ¨å‘ˆç°**
      const finalizeView = () => {
          // 1. ç¡®ä¿å…¨å±€çŠ¶æ€å¯¹è±¡å­˜åœ¨
          if (!window.mermaidGraphState) {
              window.mermaidGraphState = savedState;
          }

          // 2. æ¢å¤ç¼©æ”¾: ä½¿ç”¨ä¿å­˜çš„ç¼©æ”¾çº§åˆ«
          if (CONFIG.enableZoom && zoomControls) {
              // æ›´æ–°å†…éƒ¨ç¼©æ”¾å˜é‡ï¼ˆåœ¨setupZoomControlsä½œç”¨åŸŸå†…ï¼‰
              const svgElement = diagramContainer.querySelector("svg");
              if (svgElement) {
                  svgElement.style.transformOrigin = "top left";
                  svgElement.style.transform = `translate(${savedState.panX || 0}px, ${savedState.panY || 0}px) scale(${savedState.zoom})`;
              }
              zoomControls.updateZoomDisplay();
          }

          // 3. æ¢å¤æ»šåŠ¨ä½ç½®: åº”ç”¨ä¿å­˜çš„å€¼
          diagramContainer.scrollLeft = savedState.scrollLeft;
          diagramContainer.scrollTop = savedState.scrollTop;
          if (outerContainer) {
              outerContainer.scrollLeft = savedState.outerScrollLeft || 0;
              outerContainer.scrollTop = savedState.outerScrollTop || 0;
          }

          // 4. æ›´æ–°å…¨å±€çŠ¶æ€ä¸ºå½“å‰å€¼
          window.mermaidGraphState.zoom = savedState.zoom;
          window.mermaidGraphState.scrollLeft = savedState.scrollLeft;
          window.mermaidGraphState.scrollTop = savedState.scrollTop;
          window.mermaidGraphState.panX = savedState.panX || 0;
          window.mermaidGraphState.panY = savedState.panY || 0;
          window.mermaidGraphState.outerScrollLeft = savedState.outerScrollLeft || 0;
          window.mermaidGraphState.outerScrollTop = savedState.outerScrollTop || 0;

          if (activeNode) {
              centerNodeInChart(activeNode, diagramContainer);
              highlightNodeOnce(activeNode, diagramContainer, 5000);
          }

          diagramContainer.style.visibility = "visible";
          diagramContainer.style.opacity = "1";

          console.log('[çŠ¶æ€æ¢å¤] å·²æ¢å¤è§†å›¾çŠ¶æ€:', savedState);
      };

      requestAnimationFrame(() => requestAnimationFrame(finalizeView));

    } else {
      statusDiv.textContent = "é”™è¯¯: Mermaidåº“æœªåŠ è½½";
      diagramContainer.style.visibility = "visible";
      diagramContainer.style.opacity = "1";
    }
  } catch (error) {
    statusDiv.textContent = `é”™è¯¯: ${error.message}`;
    if (CONFIG.debug) {
      diagramContainer.innerHTML += `<pre style="color:red;padding:10px;overflow:auto">${error.stack}</pre>`;
    }
    diagramContainer.style.visibility = "visible";
    diagramContainer.style.opacity = "1";
  }
}




// ===== ä¸»ç¨‹åºå…¥å£ =====
// åˆ›å»ºUIå¹¶æ¸²æŸ“åˆå§‹å›¾è¡¨
const ui = createUI(content);
renderDiagram(content, ui.statusDiv, ui.diagramContainer, ui.codeContainer, ui.zoomControls);
const keyboardCleanup = setupGlobalKeyboardShortcuts();
if (keyboardCleanup) cleanupFns.push(keyboardCleanup);

// --- æ–°å¢: ç›‘å¬æ ‡ç­¾é¡µåˆ‡æ¢ï¼Œæ¢å¤è§†å›¾çŠ¶æ€ ---
// å½“å½“å‰ç¬”è®°è¢«æ¿€æ´»æ—¶ï¼Œæ¢å¤ Mermaid å›¾çš„è§†å›¾çŠ¶æ€
const refreshOnLeafActive = () => {
    // æ£€æŸ¥å½“å‰æ¿€æ´»çš„ leaf æ˜¯å¦åŒ…å«æˆ‘ä»¬çš„å›¾è¡¨å®¹å™¨
    const activeLeaf = app.workspace.activeLeaf;
    if (activeLeaf && ui.diagramContainer) {
        // å»¶è¿Ÿæ‰§è¡Œä»¥ç¡®ä¿ DOM å·²æ›´æ–°
        setTimeout(() => {
            const storedState = localStorage.getItem('mermaidGraphState');
            if (storedState && ui.diagramContainer) {
                try {
                    const state = JSON.parse(storedState);
                    console.log('[æ ‡ç­¾é¡µåˆ‡æ¢] æ£€æµ‹åˆ°åˆ‡æ¢ï¼Œæ¢å¤çŠ¶æ€:', state);

                    // æ¢å¤æ»šåŠ¨ä½ç½®
                    ui.diagramContainer.scrollLeft = state.scrollLeft || 0;
                    ui.diagramContainer.scrollTop = state.scrollTop || 0;
                    const outerContainer = ui.diagramContainer.closest('.mermaid-content');
                    if (outerContainer) {
                        outerContainer.scrollLeft = state.outerScrollLeft || 0;
                        outerContainer.scrollTop = state.outerScrollTop || 0;
                    }

                    // æ¢å¤ç¼©æ”¾
                    const svgElement = ui.diagramContainer.querySelector("svg");
                    if (svgElement && ui.zoomControls) {
                        svgElement.style.transformOrigin = "top left";
                        svgElement.style.transform = `translate(${state.panX || 0}px, ${state.panY || 0}px) scale(${state.zoom || CONFIG.initialZoom})`;
                        ui.zoomControls.updateZoomDisplay();
                    }

                    // æ›´æ–°å…¨å±€çŠ¶æ€
                    if (window.mermaidGraphState) {
                        window.mermaidGraphState.zoom = state.zoom;
                        window.mermaidGraphState.scrollLeft = state.scrollLeft;
                        window.mermaidGraphState.scrollTop = state.scrollTop;
                        window.mermaidGraphState.panX = state.panX || 0;
                        window.mermaidGraphState.panY = state.panY || 0;
                        window.mermaidGraphState.outerScrollLeft = state.outerScrollLeft || 0;
                        window.mermaidGraphState.outerScrollTop = state.outerScrollTop || 0;
                    }
                } catch (e) {
                    console.warn('[æ ‡ç­¾é¡µåˆ‡æ¢] æ¢å¤çŠ¶æ€å¤±è´¥:', e);
                }
            }
        }, 200);
    }
};

// æ³¨å†Œå·¥ä½œåŒºäº‹ä»¶ç›‘å¬å™¨
if (app.workspace) {
    const activeLeafChangeRef = app.workspace.on('active-leaf-change', refreshOnLeafActive);
    cleanupFns.push(() => {
        if (activeLeafChangeRef && app.workspace.offref) {
            app.workspace.offref(activeLeafChangeRef);
        } else if (app.workspace.off) {
            app.workspace.off('active-leaf-change', refreshOnLeafActive);
        }
    });
    console.log('[çŠ¶æ€æ¢å¤] å·²æ³¨å†Œ active-leaf-change äº‹ä»¶ç›‘å¬å™¨');
}
})();
%>
