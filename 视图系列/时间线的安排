# Êó•ÊâßË°åËÆ°Âàí

[[supermemo planÊñ∞Áâà]]

# Timeline
```dataviewjs
// ============================================================
// üóìÔ∏è Timeline Êó∂Èó¥Á∫øËßÜÂõæÁ≥ªÁªü (v4.0 MermaidÁâà)
// ÂäüËÉΩÔºöMermaid GanttÊó∂Èó¥ËΩ¥ + Áº©Êîæ + Âë®Ê†áËÆ∞ + Áã¨Á´ãÊ†áÁ≠æÁ≥ªÁªü + Ê†áÁ≠æÁÆ°ÁêÜ + Á≠õÈÄâ
// Ê∏≤ÊüìÊñπÂºèÔºö‰ΩøÁî® window.mermaid Ê∏≤ÊüìÔºå‰∏é ATOM ËßÜÂõæÁ≥ªÁªü‰∏ÄËá¥
// ============================================================

(async () => {

    // ===== 1. ÈÖçÁΩÆ‰∏éÊï∞ÊçÆÁÆ°ÁêÜ =====
    const JSON_FILENAME = "Timeline_Data.json";
    const TAGS_FILENAME = "Timeline_Tags.json";  // Áã¨Á´ãÁöÑÊ†áÁ≠æÊñá‰ª∂
    const currentFolder = dv.current().file.folder;
    const DATA_PATH = currentFolder + "/" + JSON_FILENAME;
    const TAGS_PATH = currentFolder + "/" + TAGS_FILENAME;

    // ËßÜÂõæËåÉÂõ¥ÈªòËÆ§ÈÖçÁΩÆ
    const DEFAULT_VIEW_SETTINGS = {
        viewRange: {
            mode: "week",  // week | custom
            customStart: moment().startOf("isoWeek").format("YYYY-MM-DD"),
            customEnd: moment().endOf("isoWeek").format("YYYY-MM-DD")
        },
        ganttRangeMode: "auto" // auto | view
    };

    // ÈªòËÆ§Ê†áÁ≠æÂÆö‰πâ
    const DEFAULT_TAG_DEFINITIONS = {
        "work-type":     { label: "Â∑•‰ΩúÁ±ªÂûã", icon: "üìã", color: "#7f8c8d", parentId: null, isCategory: true, order: 0 },
        "system":        { label: "Êû∂ÊûÑËÆæËÆ°", icon: "üèóÔ∏è", color: "#9b59b6", parentId: "work-type", isCategory: false, order: 0 },
        "learning":      { label: "Â≠¶‰π†ÈíªÁ†î", icon: "üìö", color: "#3498db", parentId: "work-type", isCategory: false, order: 1 },
        "review":        { label: "Â§çÁõòÊ≤âÊ∑Ä", icon: "üí°", color: "#f1c40f", parentId: "work-type", isCategory: false, order: 2 },
        "urgent":        { label: "Á¥ßÊÄ•ÊïëÁÅ´", icon: "üî•", color: "#e74c3c", parentId: "work-type", isCategory: false, order: 3 },
        "waiting":       { label: "Â§ñÈÉ®Á≠âÂæÖ", icon: "‚è≥", color: "#95a5a6", parentId: "work-type", isCategory: false, order: 4 },
        "domain":        { label: "ËÉΩÂäõÂüü", icon: "üéØ", color: "#2c3e50", parentId: null, isCategory: true, order: 1 },
        "tech":          { label: "ÊäÄÊúØËÉΩÂäõ", icon: "‚öôÔ∏è", color: "#1abc9c", parentId: "domain", isCategory: false, order: 0 },
        "mgmt":          { label: "ÁÆ°ÁêÜËÉΩÂäõ", icon: "üëî", color: "#e67e22", parentId: "domain", isCategory: false, order: 1 },
        "personal":      { label: "‰∏™‰∫∫ÂèëÂ±ï", icon: "üå±", color: "#27ae60", parentId: "domain", isCategory: false, order: 2 },
        "priority":      { label: "Á¥ßÊÄ•Á®ãÂ∫¶", icon: "‚ö°", color: "#8e44ad", parentId: null, isCategory: true, order: 2 },
        "p1-critical":   { label: "P1-Á¥ßÊÄ•", icon: "üî¥", color: "#c0392b", parentId: "priority", isCategory: false, order: 0 },
        "p2-high":       { label: "P2-ÈáçË¶Å", icon: "üü†", color: "#d35400", parentId: "priority", isCategory: false, order: 1 },
        "p3-normal":     { label: "P3-Ê≠£Â∏∏", icon: "üü°", color: "#f39c12", parentId: "priority", isCategory: false, order: 2 },
        "p4-low":        { label: "P4-‰Ωé", icon: "üü¢", color: "#27ae60", parentId: "priority", isCategory: false, order: 3 }
    };

    // È¢úËâ≤Ê±†ÔºàÁî®‰∫é‰∫ãÈ°πËá™Âä®ÁùÄËâ≤ÔºåÊâ©Â±ïËá≥ 64 ÁªÑÔºåÂùáË°°ÂàÜÂ∏É HSLÔºâ
    const COLOR_POOL = Array.from({ length: 64 }, (_, i) => {
        const hue = Math.round((i * 360) / 64);
        return `hsl(${hue}, 65%, 55%)`;
    });

    // ‰∏ÉÂùóÊó∂Èó¥ÊÆµ
    const TIME_BLOCKS = [
        { id: "morning", label: "Êó©Êô®", range: "06:00-08:00" },
        { id: "am1", label: "‰∏äÂçà1", range: "08:00-10:00" },
        { id: "am2", label: "‰∏äÂçà2", range: "10:00-12:00" },
        { id: "pm1", label: "‰∏ãÂçà1", range: "13:00-15:00" },
        { id: "pm2", label: "‰∏ãÂçà2", range: "15:00-17:00" },
        { id: "eve1", label: "Êôö‰∏ä1", range: "18:00-20:00" },
        { id: "eve2", label: "Êôö‰∏ä2", range: "20:00-23:00" },
    ];

    // Áªü‰∏ÄÁöÑÂùóÁ¥¢ÂºïÔºöÊú™ÂàÜÈÖçËøîÂõûÊúÄÂ§ßÂÄºÔºåÊñπ‰æøËêΩÂ∫ï
    const blockIndex = (item, dateStr) => {
        if (!item) return TIME_BLOCKS.length + 1;
        const slot = (item.daySlots || {})[dateStr] || null;
        const idx = TIME_BLOCKS.findIndex(b => b.id === slot);
        return idx >= 0 ? idx : TIME_BLOCKS.length + 1;
    };

    // ÊûÑÂª∫‚ÄúÊØèÊó•È°∫Â∫è‚ÄùÊò†Â∞ÑÔºöÂ∑≤ÊéíÂùó‰ºòÂÖàÔºåÊú™ÊéíÂùóÁªßÊâøÂâç‰∏ÄÊó•È°∫Â∫è
    const buildDailyOrderMap = (dates, items) => {
        const orders = {};
        let prevOrder = [];

        const createdTs = (it) => {
            const candidate = it.created || it.startDate;
            const m = moment(candidate);
            return m.isValid() ? m.valueOf() : 0;
        };

        dates.forEach(dateStr => {
            const dayItems = items.filter(item =>
                moment(dateStr).isBetween(item.startDate, item.endDate, "day", "[]")
            );

            // ÁªßÊâøÂâç‰∏ÄÊó•È°∫Â∫èÔºåÂâîÈô§‰ªäÂ§©‰∏çÂ≠òÂú®ÁöÑÈ°π
            const baseFromPrev = prevOrder.filter(id => dayItems.some(it => it.id === id));

            // Êñ∞Âá∫Áé∞ÁöÑÈ°πÊåâÂàõÂª∫Êó∂Èó¥ËøΩÂä†ÔºõÊó†ÂàõÂª∫Êó∂Èó¥ÂàôÊåâÂêçÁß∞‰øùËØÅÁ®≥ÂÆö
            const newOnDay = dayItems
                .filter(it => !baseFromPrev.includes(it.id))
                .sort((a, b) => {
                    const diff = createdTs(a) - createdTs(b);
                    if (diff !== 0) return diff;
                    return (a.name || "").localeCompare(b.name || "");
                });

            const base = [...baseFromPrev, ...newOnDay.map(it => it.id)];

            const scheduledIds = base.filter(id => {
                const item = dayItems.find(i => i.id === id);
                const slot = (item?.daySlots || {})[dateStr];
                return !!slot;
            });

            const unscheduledIds = base.filter(id => !scheduledIds.includes(id));

            // Â∑≤ÊéíÂùóÔºöÂÖàÊåâÊó∂Èó¥ÂùóÈ°∫Â∫èÔºåÂÜçÊåâÁªßÊâøÈ°∫Â∫è
            const scheduledSorted = scheduledIds.sort((aId, bId) => {
                const aItem = dayItems.find(i => i.id === aId);
                const bItem = dayItems.find(i => i.id === bId);
                const ai = blockIndex(aItem, dateStr);
                const bi = blockIndex(bItem, dateStr);
                if (ai !== bi) return ai - bi;
                return base.indexOf(aId) - base.indexOf(bId);
            });

            const order = [...scheduledSorted, ...unscheduledIds];
            orders[dateStr] = order;
            prevOrder = order; // ‰æõÊ¨°Êó•ÁªßÊâø
        });

        return orders;
    };

    // Mermaid Gantt ÈÖçÁΩÆ
    const MERMAID_CONFIG = {
        zoom: {
            day: { axisFormat: "%m/%d (%a)", sectionSize: 3, minCellWidth: 50 },
            week: { axisFormat: "%m/%d (Á¨¨%WÂë®)", sectionSize: 5, minCellWidth: 80 },
            month: { axisFormat: "%Y/%m", sectionSize: 10, minCellWidth: 120 },
            quarter: { axisFormat: "%Y Q%q", sectionSize: 15, minCellWidth: 150 }
        }
    };

    // ÂÖ®Â±ÄÁä∂ÊÄÅ
    if (window.timelineZoom === undefined) window.timelineZoom = "week";
    if (window.timelineViewMode === undefined) window.timelineViewMode = "gantt";  // gantt | calendar | dayblock | wave
    if (window.timelineTagFilter === undefined) window.timelineTagFilter = null;
    if (window.timelineTagFilters === undefined) window.timelineTagFilters = [];
    if (window.timelineTagManagerMode === undefined) window.timelineTagManagerMode = false;
    if (window.timelineCurrentMonth === undefined) window.timelineCurrentMonth = moment();
    if (window.timelineMermaidState === undefined) window.timelineMermaidState = { zoom: 1.0, scrollLeft: 0, scrollTop: 0 };
    if (window.timelineRangeMode === undefined) window.timelineRangeMode = "week";
    if (window.timelineCustomStart === undefined) window.timelineCustomStart = moment().startOf("isoWeek").format("YYYY-MM-DD");
    if (window.timelineCustomEnd === undefined) window.timelineCustomEnd = moment().endOf("isoWeek").format("YYYY-MM-DD");
    if (window.timelineGanttRangeMode === undefined) window.timelineGanttRangeMode = "auto";
    if (window.timelineDayblockOnlyScheduled === undefined) window.timelineDayblockOnlyScheduled = false;

    // ===== 2. Â∑•ÂÖ∑ÂáΩÊï∞ =====

    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2, 5);

    const getColorForItem = (name, existingColors) => {
        const hash = name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
        // ÂÖàÂ∞ùËØïÊåâ hash ÂèñËâ≤ÔºåËã•ÊíûËâ≤ÂàôÊâæ‰∏éÂ∑≤Áî®Ëâ≤ÊúÄËøúÁöÑÈ¢úËâ≤
        let preferred = COLOR_POOL[hash % COLOR_POOL.length];
        if (!existingColors.includes(preferred)) return preferred;

        const hueOf = (c) => {
            // c ÂΩ¢Â¶Ç hsl(h, s%, l%)
            const m = /hsl\((\d+)/.exec(c);
            return m ? parseInt(m[1], 10) : 0;
        };
        const usedHues = existingColors.map(hueOf);
        let bestColor = preferred;
        let bestScore = -1;
        COLOR_POOL.forEach(c => {
            const h = hueOf(c);
            const minDiff = usedHues.length === 0 ? 360 : Math.min(...usedHues.map(u => {
                let d = Math.abs(h - u);
                return Math.min(d, 360 - d);
            }));
            if (minDiff > bestScore && !existingColors.includes(c)) {
                bestScore = minDiff;
                bestColor = c;
            }
        });
        return bestColor;
    };

    const getWeekNumber = (date) => moment(date).week();
    const getDayName = (date) => ["Âë®Êó•", "Âë®‰∏Ä", "Âë®‰∫å", "Âë®‰∏â", "Âë®Âõõ", "Âë®‰∫î", "Âë®ÂÖ≠"][moment(date).day()];
    const itemHasScheduledInRange = (item, start, end) => {
        const slots = item?.daySlots || {};
        const dates = Object.keys(slots);
        if (dates.length === 0) return false;
        return dates.some(d => {
            if (!slots[d]) return false;
            if (!start || !end) return true;
            return moment(d).isBetween(start, end, "day", "[]");
        });
    };

    // ÂΩìÂâçËßÜÂõæËåÉÂõ¥
    const getActiveRange = () => {
        if (window.timelineRangeMode === "custom" && window.timelineCustomStart && window.timelineCustomEnd) {
            return {
                start: moment(window.timelineCustomStart),
                end: moment(window.timelineCustomEnd)
            };
        }
        return {
            start: moment().startOf("isoWeek"),
            end: moment().endOf("isoWeek")
        };
    };

    const persistViewRange = async () => {
        await updateData((data) => {
            data.settings = data.settings || { ...DEFAULT_VIEW_SETTINGS };
            data.settings.viewRange = {
                mode: window.timelineRangeMode,
                customStart: window.timelineCustomStart,
                customEnd: window.timelineCustomEnd
            };
            data.settings.ganttRangeMode = window.timelineGanttRangeMode || "auto";
        });
    };

    const ensureDaySlots = (item) => {
        if (!item.daySlots) item.daySlots = {};
        return item.daySlots;
    };

    const getBlockById = (id) => TIME_BLOCKS.find(b => b.id === id);

    // Ëé∑ÂèñÊâÄÊúâÂ≠êÊ†áÁ≠æID
    const getDescendantTagIds = (tagId) => {
        const descendants = [];
        const findChildren = (parentId) => {
            Object.keys(TAG_DEFINITIONS).forEach(key => {
                if (TAG_DEFINITIONS[key] && TAG_DEFINITIONS[key].parentId === parentId) {
                    descendants.push(key);
                    findChildren(key);
                }
            });
        };
        findChildren(tagId);
        return descendants;
    };

    // Ëé∑ÂèñÁõ¥Êé•Â≠êÊ†áÁ≠æ
    const getChildTags = (parentId) => {
        return Object.keys(TAG_DEFINITIONS).filter(key =>
            TAG_DEFINITIONS[key] && TAG_DEFINITIONS[key].parentId === parentId
        );
    };

    const sortTagIdsByName = (ids) => {
        return ids.sort((a, b) => {
            const nameA = (TAG_DEFINITIONS[a]?.label || "").trim();
            const nameB = (TAG_DEFINITIONS[b]?.label || "").trim();
            const byName = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: "base" });
            if (byName !== 0) return byName;
            return a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" });
        });
    };

    const formatTagOptionValue = (id) => {
        const def = TAG_DEFINITIONS[id];
        if (!def) return id;
        const icon = def.icon ? `${def.icon} ` : "";
        return `${icon}${def.label} (${id})`;
    };

    // Ê†áÁ≠æÊòØÂê¶ÂåπÈÖçÁ≠õÈÄâÊù°‰ª∂
    const tagMatchesFilter = (itemTags, filterTagIds) => {
        if (!filterTagIds || filterTagIds.length === 0) return true;
        if (!itemTags || itemTags.length === 0) return false;
        const matchesOne = (filterId) => {
            if (itemTags.includes(filterId)) return true;
            return itemTags.some(t => getDescendantTagIds(filterId).includes(t));
        };
        return filterTagIds.some(matchesOne);
    };

    // Âä†ËΩΩÊ†áÁ≠æÂÆö‰πâ
    const loadTagDefinitions = async () => {
        try {
            if (await app.vault.adapter.exists(TAGS_PATH)) {
                const content = await app.vault.adapter.read(TAGS_PATH);
                const data = JSON.parse(content);
                return data.tags || DEFAULT_TAG_DEFINITIONS;
            }
        } catch (e) {
            console.error("Âä†ËΩΩÊ†áÁ≠æÂÆö‰πâÂ§±Ë¥•:", e);
        }
        await saveTagDefinitions(DEFAULT_TAG_DEFINITIONS);
        return DEFAULT_TAG_DEFINITIONS;
    };

    const saveTagDefinitions = async (tags) => {
        const data = {
            tags: tags,
            version: "1.0",
            lastModified: moment().format("YYYY-MM-DD HH:mm:ss")
        };
        const jsonString = JSON.stringify(data, null, 2);
        const file = app.vault.getAbstractFileByPath(TAGS_PATH);
        if (file) {
            await app.vault.modify(file, jsonString);
        } else {
            await app.vault.create(TAGS_PATH, jsonString);
        }
    };

    // Âä†ËΩΩÊó∂Èó¥Á∫øÊï∞ÊçÆ
    const loadTimelineData = async () => {
        try {
            if (await app.vault.adapter.exists(DATA_PATH)) {
                const content = await app.vault.adapter.read(DATA_PATH);
                const parsed = JSON.parse(content);
                // ÂÖºÂÆπÊóßÁâàÊï∞ÁªÑÁªìÊûÑ
                if (Array.isArray(parsed)) {
                    return { items: parsed, settings: { ...DEFAULT_VIEW_SETTINGS }, milestones: {} };
                }
                return {
                    items: parsed.items || [],
                    settings: {
                        ...DEFAULT_VIEW_SETTINGS,
                        ...(parsed.settings || {})
                    },
                    milestones: parsed.milestones || {}  // ÈáåÁ®ãÁ¢ëÂ≠óÂÖ∏
                };
            }
        } catch (e) {
            console.error("Âä†ËΩΩÊï∞ÊçÆÂ§±Ë¥•:", e);
        }
        const emptyData = { items: [], settings: { ...DEFAULT_VIEW_SETTINGS }, milestones: {} };
        await saveTimelineData(emptyData);
        return emptyData;
    };

    const saveTimelineData = async (data) => {
        const jsonString = JSON.stringify(data, null, 2);
        const file = app.vault.getAbstractFileByPath(DATA_PATH);
        if (file) {
            await app.vault.modify(file, jsonString);
        } else {
            await app.vault.create(DATA_PATH, jsonString);
        }
    };

    let TAG_DEFINITIONS = await loadTagDefinitions();
    let timelineData = await loadTimelineData();

    // ÂàùÂßãÂåñÂÖ®Â±ÄËåÉÂõ¥Áä∂ÊÄÅËá™Êï∞ÊçÆ
    const initRangeStateFromData = () => {
        const vr = timelineData.settings?.viewRange || DEFAULT_VIEW_SETTINGS.viewRange;
        window.timelineRangeMode = vr.mode || "week";
        window.timelineCustomStart = vr.customStart || moment().startOf("isoWeek").format("YYYY-MM-DD");
        window.timelineCustomEnd = vr.customEnd || moment().endOf("isoWeek").format("YYYY-MM-DD");
        window.timelineGanttRangeMode = timelineData.settings?.ganttRangeMode || "auto";
    };
    initRangeStateFromData();

    const updateData = async (operationFn) => {
        let currentData = await loadTimelineData();
        operationFn(currentData);
        await saveTimelineData(currentData);
        timelineData = currentData;
        initRangeStateFromData();
        if (renderViewFn) renderViewFn();
    };

    // ===== ÈáåÁ®ãÁ¢ëÊï∞ÊçÆÁªìÊûÑÔºàÊâÅÂπ≥Â≠óÂÖ∏Ôºâ =====
    // Êï∞ÊçÆÊ†ºÂºè: { "milestoneId": { id, itemId, date, name, completed, created } }
    const MILESTONE_TEMPLATE = {
        id: null,           // ÈáåÁ®ãÁ¢ëÂîØ‰∏ÄID
        itemId: null,       // ÊâÄÂ±û‰∫ãÈ°πID
        date: null,         // ÈáåÁ®ãÁ¢ëÊó•Êúü YYYY-MM-DD
        name: "",           // ÈáåÁ®ãÁ¢ëÂêçÁß∞
        comment: "",        // Â§áÊ≥®/ËØ¥Êòé
        completed: false,   // ÊòØÂê¶Â∑≤ÂÆåÊàê
        created: null       // ÂàõÂª∫Êó∂Èó¥
    };

    // Ëé∑ÂèñÊüê‰∫ãÈ°πÂú®ÊüêÊó•ÊúüÁöÑÊâÄÊúâÈáåÁ®ãÁ¢ë
    const getMilestonesForItemDate = (itemId, dateStr) => {
        const milestones = timelineData.milestones || {};
        return Object.values(milestones).filter(m =>
            m.itemId === itemId && m.date === dateStr
        );
    };

    // Ëé∑ÂèñÊüê‰∫ãÈ°πÁöÑÊâÄÊúâÈáåÁ®ãÁ¢ëÔºàÊåâÊó•ÊúüÊéíÂ∫èÔºâ
    const getMilestonesForItem = (itemId) => {
        const milestones = timelineData.milestones || {};
        return Object.values(milestones)
            .filter(m => m.itemId === itemId)
            .sort((a, b) => a.date.localeCompare(b.date));
    };

    // Ê†πÊçÆIDËé∑ÂèñÈáåÁ®ãÁ¢ë
    const getMilestoneById = (milestoneId) => {
        const milestones = timelineData.milestones || {};
        return milestones[milestoneId] || null;
    };

    // Ê∑ªÂä†/Êõ¥Êñ∞ÈáåÁ®ãÁ¢ë
    const saveMilestone = async (milestoneData) => {
        await updateData((data) => {
            data.milestones = data.milestones || {};
            const id = milestoneData.id || generateId();
            data.milestones[id] = {
                ...MILESTONE_TEMPLATE,
                ...milestoneData,
                id: id,
                created: milestoneData.created || moment().format("YYYY-MM-DD HH:mm:ss")
            };
        });
    };

    // Âà†Èô§ÈáåÁ®ãÁ¢ë
    const deleteMilestone = async (milestoneId) => {
        await updateData((data) => {
            if (data.milestones && data.milestones[milestoneId]) {
                delete data.milestones[milestoneId];
            }
        });
    };

    // ÈáåÁ®ãÁ¢ëÂºπÁ™ó
    class MilestoneModal extends obsidian.Modal {
        constructor(app, milestone, item, dateStr, onSave, onDelete) {
            super(app);
            this.milestone = milestone ? { ...milestone } : { ...MILESTONE_TEMPLATE };
            this.item = item;
            this.dateStr = dateStr;
            this.onSave = onSave;
            this.onDelete = onDelete;
        }
        onOpen() {
            const { contentEl } = this;
            contentEl.empty();
            const isEdit = !!this.milestone.id;
            contentEl.createEl("h3", { text: isEdit ? "üìç ÁºñËæëÈáåÁ®ãÁ¢ë" : "‚ú® Ê∑ªÂä†ÈáåÁ®ãÁ¢ë" });
            this.modalEl.style.width = "720px";
            this.modalEl.style.maxWidth = "92vw";

            const itemInfo = contentEl.createEl("div", {
                text: `‰∫ãÈ°π: ${this.item?.name || 'Êú™Áü•'}`,
                attr: { style: "padding:8px; background:var(--background-secondary); border-radius:6px; margin-bottom:12px; font-size:13px;" }
            });

            const form = contentEl.createEl("div", { attr: { style: "display:flex; flex-direction:column; gap:12px;" } });

            const nameInput = form.createEl("input", {
                type: "text",
                value: this.milestone.name || "",
                attr: { placeholder: "ÈáåÁ®ãÁ¢ëÂêçÁß∞ÔºàÂ¶ÇÔºöÂÆåÊàêÂàùÁ®ø„ÄÅËØÑÂÆ°ÈÄöËøáÔºâ", style: "width:100%; padding:10px;" }
            });

            const dateRow = form.createEl("div", { attr: { style: "display:flex; gap:10px; align-items:center;" } });
            dateRow.createEl("span", { text: "Êó•Êúü:", attr: { style: "font-weight:600;" } });
            const dateInput = dateRow.createEl("input", {
                type: "date",
                value: this.milestone.date || this.dateStr,
                attr: { style: "padding:8px;" }
            });

            const completedRow = form.createEl("div", { attr: { style: "display:flex; gap:10px; align-items:center;" } });
            const completedCheck = completedRow.createEl("input", { type: "checkbox" });
            completedCheck.checked = !!this.milestone.completed;
            completedRow.createEl("span", { text: "Â∑≤ÂÆåÊàê", attr: { style: "cursor:pointer;" } });

            // ‰ΩøÁî® change ‰∫ã‰ª∂‰ª£Êõø clickÔºåÁ°Æ‰øùÁä∂ÊÄÅÊ≠£Á°ÆÂàáÊç¢
            completedCheck.onchange = () => {
                // Áä∂ÊÄÅÂ∑≤ÁªèÁî±ÊµèËßàÂô®Ëá™Âä®Â§ÑÁêÜÔºåÊó†ÈúÄÊâãÂä®ÂàáÊç¢
            };
            // ÁÇπÂáªÊï¥Ë°å‰πüÂèØ‰ª•ÂàáÊç¢
            completedRow.style.cursor = "pointer";
            completedRow.onclick = (e) => {
                if (e.target !== completedCheck) {
                    completedCheck.checked = !completedCheck.checked;
                    // Ëß¶Âèë change ‰∫ã‰ª∂
                    completedCheck.dispatchEvent(new Event('change'));
                }
            };

            const commentLabel = form.createEl("div", { text: "Â§áÊ≥®/Comment", attr: { style: "font-weight:600;" } });
            const commentArea = form.createEl("textarea", {
                text: this.milestone.comment || "",
                attr: {
                    rows: 8,
                    placeholder: "Ë°•ÂÖÖËØ¥Êòé„ÄÅÈ™åÊî∂Ê†áÂáÜ„ÄÅÂ§çÁõòË¶ÅÁÇπÁ≠â...",
                    style: "width:100%; min-height:180px; padding:10px; resize:vertical;"
                }
            });

            // ÊòæÁ§∫Âêå‰∏™‰∫ãÈ°πÁöÑÂÖ∂‰ªñÈáåÁ®ãÁ¢ëÂàóË°®ÔºàÊåâÊó•ÊúüÊéíÂ∫èÔºâ
            if (this.item) {
                const existingList = contentEl.createEl("div", { attr: { style: "margin-top:15px; padding:10px; border:1px solid var(--background-modifier-border); border-radius:8px;" } });
                existingList.createEl("div", { text: "üìã Âêå‰∫ãÈ°πÈáåÁ®ãÁ¢ëÔºàÊåâÊó∂Èó¥È°∫Â∫èÔºâ:", attr: { style: "font-weight:600; margin-bottom:8px; font-size:12px;" } });
                const allMilestones = getMilestonesForItem(this.item.id);
                // ËøáÊª§ÊéâÂΩìÂâçÁºñËæëÁöÑÈáåÁ®ãÁ¢ë
                const otherMilestones = allMilestones.filter(m => m.id !== this.milestone.id);
                if (otherMilestones.length === 0) {
                    existingList.createEl("span", { text: "Êó†ÂÖ∂‰ªñÈáåÁ®ãÁ¢ë", attr: { style: "color:var(--text-muted); font-size:12px;" } });
                } else {
                    const listDiv = existingList.createEl("div", { attr: { style: "display:flex; flex-direction:column; gap:4px;" } });
                    otherMilestones.forEach(m => {
                        const chip = listDiv.createEl("div", {
                            text: `${m.completed ? "‚úÖ" : "üî≤"} [${m.date}] ${m.name}`,
                            attr: {
                                style: `
                                    padding:6px 10px;
                                    background:${m.completed ? "var(--background-primary)" : "var(--background-secondary)"};
                                    border-radius:4px;
                                    font-size:12px;
                                    cursor:pointer;
                                `
                            }
                        });
                        chip.onclick = () => {
                            this.milestone = m;
                            this.close();
                            new MilestoneModal(app, m, this.item, m.date, onSave, onDelete).open();
                        };
                    });
                }
            }

            const btnRow = form.createEl("div", { attr: { style: "display:flex; justify-content:flex-end; gap:10px; margin-top:15px;" } });
            const cancelBtn = btnRow.createEl("button", { text: "ÂèñÊ∂à" });
            cancelBtn.onclick = () => this.close();

            if (isEdit) {
                const deleteBtn = btnRow.createEl("button", {
                    text: "Âà†Èô§",
                    attr: { style: "color:#e74c3c; border:1px solid #e74c3c; padding:6px 12px; border-radius:6px;" }
                });
                deleteBtn.onclick = () => {
                    if (confirm("Á°ÆÂÆöÂà†Èô§Ê≠§ÈáåÁ®ãÁ¢ëÔºü")) {
                        this.onDelete(this.milestone.id);
                        this.close();
                    }
                };
            }

            const saveBtn = btnRow.createEl("button", { text: "‰øùÂ≠ò", cls: "mod-cta" });
            saveBtn.onclick = () => {
                if (!nameInput.value.trim()) { new Notice("ËØ∑ËæìÂÖ•ÈáåÁ®ãÁ¢ëÂêçÁß∞"); return; }
                if (!dateInput.value) { new Notice("ËØ∑ÈÄâÊã©Êó•Êúü"); return; }
                this.onSave({
                    ...this.milestone,
                    itemId: this.item?.id || this.milestone.itemId,
                    date: dateInput.value,
                    name: nameInput.value.trim(),
                    comment: commentArea.value || "",
                    completed: completedCheck.checked
                });
                this.close();
            };
        }
        onClose() { this.contentEl.empty(); }
    }

    const openMilestoneModal = (app, milestone, item, dateStr, onSave, onDelete) => {
        new MilestoneModal(app, milestone, item, dateStr, onSave, onDelete).open();
    };

    // ===== 4. UI‰∫§‰∫íÁªÑ‰ª∂ =====

    class QuickPrompt extends obsidian.Modal {
        constructor(app, title, placeholder, onSubmit, defaultValue = "") {
            super(app);
            this.titleStr = title;
            this.placeholder = placeholder;
            this.defaultValue = defaultValue;
            this.onSubmit = onSubmit;
        }
        onOpen() {
            const { contentEl } = this;
            contentEl.createEl("h3", { text: this.titleStr });
            const input = contentEl.createEl("input", { type: "text", value: this.defaultValue });
            input.placeholder = this.placeholder;
            input.style.width = "100%";
            input.style.padding = "10px";
            input.style.marginTop = "10px";
            input.focus();

            const btnRow = contentEl.createEl("div", { attr: { style: "display:flex; justify-content:flex-end; gap:10px; margin-top:15px;" } });
            const cancelBtn = btnRow.createEl("button", { text: "ÂèñÊ∂à" });
            cancelBtn.onclick = () => this.close();
            const submitBtn = btnRow.createEl("button", { text: "Á°ÆÂÆö", cls: "mod-cta" });
            submitBtn.onclick = () => {
                if (input.value) {
                    this.close();
                    this.onSubmit(input.value);
                }
            };
            input.addEventListener("keypress", (e) => {
                if (e.key === "Enter") submitBtn.click();
            });
        }
        onClose() { this.contentEl.empty(); }
    }

    // Êó∂Èó¥ÂùóÈÄâÊã©Âô®ÔºàÂçïÈÄâÔºâ
    class TimeBlockPickerModal extends obsidian.Modal {
        constructor(app, currentBlockId, onSubmit) {
            super(app);
            this.currentBlockId = currentBlockId;
            this.onSubmit = onSubmit;
        }
        onOpen() {
            const { contentEl } = this;
            contentEl.empty();
            contentEl.createEl("h3", { text: "ÈÄâÊã©Êó∂Èó¥Âùó" });

            const list = contentEl.createEl("div", { attr: { style: "display:flex; flex-direction:column; gap:8px; padding:10px;" } });

            // Ê∑ªÂä†"Ê∏ÖÈô§"ÈÄâÈ°π
            const clearRow = list.createEl("div", {
                attr: {
                    style: `
                        display:flex;
                        align-items:center;
                        gap:8px;
                        padding:8px 12px;
                        border-radius:6px;
                        cursor:pointer;
                        background:${this.currentBlockId === null ? 'var(--interactive-accent)' : 'var(--background-secondary)'};
                        color:${this.currentBlockId === null ? '#fff' : 'var(--text-normal)'};
                        font-weight:600;
                    `
                }
            });
            clearRow.createEl("span", { text: "üóëÔ∏è Ê∏ÖÈô§ÂàÜÈÖç" });
            clearRow.onclick = () => {
                this.close();
                this.onSubmit(null);
            };

            // Ê∑ªÂä†Êó∂Èó¥ÂùóÈÄâÈ°π
            TIME_BLOCKS.forEach(block => {
                const row = list.createEl("div", {
                    attr: {
                        style: `
                            display:flex;
                            align-items:center;
                            gap:8px;
                            padding:8px 12px;
                            border-radius:6px;
                            cursor:pointer;
                            background:${this.currentBlockId === block.id ? 'var(--interactive-accent)' : 'var(--background-secondary)'};
                            color:${this.currentBlockId === block.id ? '#fff' : 'var(--text-normal)'};
                            font-weight:600;
                        `
                    }
                });
                row.createEl("span", { text: block.label });
                row.createEl("span", { text: block.range, attr: { style: "color:var(--text-muted); font-size:0.9em;" } });
                row.onclick = () => {
                    this.close();
                    this.onSubmit(block.id);
                };
            });
        }
        onClose() { this.contentEl.empty(); }
    }

    const pickTimeBlockOnce = (currentBlockId = null) =>
        new Promise(res => new TimeBlockPickerModal(app, currentBlockId, res).open());

    // Êìç‰ΩúÈÄâÊã©Âô®ÔºàÁÇπÂáªÈÄâÊã©Êìç‰ΩúÁ±ªÂûãÔºâ
    class ActionPickerModal extends obsidian.Modal {
        constructor(app, itemName, onAction) {
            super(app);
            this.itemName = itemName;
            this.onAction = onAction; // 'timeblock' | 'milestone' | 'detail' | null
        }
        onOpen() {
            const { contentEl } = this;
            contentEl.empty();
            contentEl.createEl("h3", { text: `${this.itemName}` });
            contentEl.createEl("div", {
                text: "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
                attr: { style: "color:var(--text-muted); margin:10px 0;" }
            });
            contentEl.createEl("div", { text: "ÈÄâÊã©Êìç‰Ωú:", attr: { style: "font-weight:600; margin-bottom:15px;" } });

            const actions = [
                { id: 'timeblock', icon: 'üìÖ', label: 'ËÆæÁΩÆÊó∂Èó¥Âùó', desc: '‰∏∫‰∫ãÈ°πÂàÜÈÖçÂÖ∑‰ΩìÊó∂Èó¥ÊÆµ' },
                { id: 'milestone', icon: 'üéØ', label: 'Ê∑ªÂä†ÈáåÁ®ãÁ¢ë', desc: 'Ê†áËÆ∞ÂÖ≥ÈîÆËäÇÁÇπ‰∏éËøõÂ∫¶' },
                { id: 'detail', icon: '‚úèÔ∏è', label: 'Êü•ÁúãËØ¶ÊÉÖ', desc: 'ÁºñËæë‰∫ãÈ°πÂü∫Êú¨‰ø°ÊÅØÂíåÂ§áÊ≥®' }
            ];

            const list = contentEl.createEl("div", { attr: { style: "display:flex; flex-direction:column; gap:10px; padding:5px;" } });

            actions.forEach(action => {
                const row = list.createEl("div", {
                    attr: {
                        style: `
                            display:flex;
                            align-items:center;
                            gap:12px;
                            padding:12px 15px;
                            border-radius:8px;
                            cursor:pointer;
                            background:var(--background-secondary);
                            transition: all 0.2s;
                        `
                    }
                });
                row.createEl("span", { text: action.icon, attr: { style: "font-size:1.4em;" } });
                const textDiv = row.createEl("div");
                textDiv.createEl("div", { text: action.label, attr: { style: "font-weight:600; font-size:1em;" } });
                textDiv.createEl("div", { text: action.desc, attr: { style: "color:var(--text-muted); font-size:0.85em; margin-top:2px;" } });

                row.onclick = () => {
                    this.close();
                    this.onAction(action.id);
                };
                row.onmouseenter = () => { row.style.background = 'var(--background-modifier-border)'; };
                row.onmouseleave = () => { row.style.background = 'var(--background-secondary)'; };
            });
        }
        onClose() { this.contentEl.empty(); }
    }

    const pickActionOnce = (itemName) =>
        new Promise(res => new ActionPickerModal(app, itemName, res).open());

    // Ê†áÁ≠æÈÄâÊã©Âô®Ôºà‰∏ÄÊ¨°ÊÄßÂ§öÈÄâÔºåÂ∏¶"ÂÆåÊàê"ÊåâÈíÆÔºåÈÅøÂÖçÂèçÂ§çÂºπÁ™óÔºâ
    class TagPickerModal extends obsidian.Modal {
        constructor(app, currentTags, onFinish) {
            super(app);
            this.current = new Set(currentTags || []);
            this.onFinish = onFinish;
        }
        onOpen() {
            const { contentEl } = this;
            contentEl.empty();
            contentEl.createEl("h3", { text: "ÈÄâÊã©Ê†áÁ≠æÔºàÂèØÂ§öÈÄâÔºâ" });

            const searchInput = contentEl.createEl("input", {
                type: "text",
                attr: {
                    placeholder: "ËæìÂÖ•ÂÖ≥ÈîÆËØçÁ≠õÈÄâÊ†áÁ≠æÔºàÂêçÁß∞/IDÔºâ",
                    style: "width:100%; padding:6px 8px; border:1px solid var(--background-modifier-border); border-radius:6px; margin:6px 0;"
                }
            });

            const list = contentEl.createEl("div", {
                attr: {
                    style: "max-height:300px; overflow:auto; padding:8px; border:1px solid var(--background-modifier-border); border-radius:6px;"
                }
            });

            const normalize = (s) => (s || "").toString().trim().toLowerCase();
            const matchesQuery = (id, def, query) => {
                if (!query) return true;
                const label = def?.label || "";
                const hay = `${id} ${label}`.toLowerCase();
                return hay.includes(query);
            };
            const subtreeMatches = (id, query) => {
                const def = TAG_DEFINITIONS[id];
                if (matchesQuery(id, def, query)) return true;
                return getChildTags(id).some(childId => subtreeMatches(childId, query));
            };

            const render = () => {
                list.empty();
                const query = normalize(searchInput.value);
                let hasAny = false;

                const renderTree = (parentId, level = 0) => {
                    const children = sortTagIdsByName(getChildTags(parentId));
                    children.forEach(id => {
                        const def = TAG_DEFINITIONS[id];
                        if (!def) return;
                        if (query && !subtreeMatches(id, query)) return;
                        hasAny = true;

                        const row = list.createEl("div", {
                            attr: {
                                style: `
                                    display:flex;
                                    align-items:center;
                                    gap:8px;
                                    padding:4px;
                                    margin-left:${level * 12}px;
                                    border-radius:4px;
                                `
                            }
                        });
                        const checkbox = row.createEl("input", { type: "checkbox" });
                        checkbox.checked = this.current.has(id);
                        checkbox.onclick = () => {
                            if (checkbox.checked) this.current.add(id); else this.current.delete(id);
                        };
                        const label = row.createEl("span", { text: `${def.icon} ${def.label}`, attr: { style: "font-size:13px;" } });
                        label.onclick = () => { checkbox.click(); };
                        renderTree(id, level + 1);
                    });
                };

                renderTree(null, 0);

                if (!hasAny) {
                    list.createEl("div", {
                        text: "Êó†ÂåπÈÖçÊ†áÁ≠æ",
                        attr: { style: "padding:8px; color:var(--text-muted); text-align:center;" }
                    });
                }
            };

            searchInput.addEventListener("input", render);
            render();

            const actions = contentEl.createEl("div", { attr: { style: "display:flex; justify-content:flex-end; gap:10px; margin-top:12px;" } });
            const cancelBtn = actions.createEl("button", { text: "ÂèñÊ∂à" });
            const okBtn = actions.createEl("button", { text: "ÂÆåÊàê", cls: "mod-cta" });
            cancelBtn.onclick = () => { this.close(); this.onFinish(null); };
            okBtn.onclick = () => { this.close(); this.onFinish(Array.from(this.current)); };
        }
        onClose() { this.contentEl.empty(); }
    }

    const pickTagsOnce = (currentTags = []) =>
        new Promise(res => new TagPickerModal(app, currentTags, res).open());

    const prompt = (title, placeholder = "", defaultValue = "") =>
        new Promise(r => new QuickPrompt(app, title, placeholder, r, defaultValue).open());

    class ItemEditModal extends obsidian.Modal {
        constructor(app, item, onSave) {
            super(app);
            this.item = { ...item, tags: [...(item.tags || [])] };
            this.onSave = onSave;
        }
        renderTagChips(container) {
            container.empty();
            if (!this.item.tags || this.item.tags.length === 0) {
                container.createEl("div", { text: "Êú™ÈÄâÊã©Ê†áÁ≠æ", attr: { style: "color:var(--text-muted);" } });
                return;
            }
            const chips = container.createEl("div", { attr: { style: "display:flex; flex-wrap:wrap; gap:6px;" } });
            this.item.tags.forEach(tagId => {
                const def = TAG_DEFINITIONS[tagId];
                const chip = chips.createEl("span", {
                    text: def ? `${def.icon} ${def.label}` : tagId,
                    attr: {
                        style: `padding:4px 8px; border-radius:12px; background:${def?.color || 'var(--background-secondary)'}; color:#fff; font-size:12px; cursor:default;`
                    }
                });
            });
        }
        async openTagPicker(container) {
            const selected = await pickTagsOnce([...(this.item.tags || [])]);
            if (selected === null) return;
            this.item.tags = selected;
            this.renderTagChips(container);
        }
        onOpen() {
            const { contentEl } = this;
            contentEl.empty();
            contentEl.createEl("h3", { text: "‚úèÔ∏è ÁºñËæë‰∫ãÈ°π" });

            const form = contentEl.createEl("div", { attr: { style: "display:flex; flex-direction:column; gap:12px; margin-top:10px;" } });

            const nameInput = form.createEl("input", { type: "text", value: this.item.name, attr: { placeholder: "‰∫ãÈ°πÂêçÁß∞" } });
            const dateRow = form.createEl("div", { attr: { style: "display:flex; gap:10px;" } });
            const startInput = dateRow.createEl("input", { type: "date", value: this.item.startDate });
            const endInput = dateRow.createEl("input", { type: "date", value: this.item.endDate });

            const commentArea = form.createEl("textarea", {
                text: this.item.comment || "",
                attr: { rows: 3, placeholder: "Â§áÊ≥®" }
            });

            const tagRow = form.createEl("div", { attr: { style: "display:flex; flex-direction:column; gap:6px;" } });
            const tagActions = tagRow.createEl("div", { attr: { style: "display:flex; gap:8px; align-items:center;" } });
            tagActions.createEl("span", { text: "Ê†áÁ≠æ:" });
            const pickBtn = tagActions.createEl("button", { text: "ÈÄâÊã©Ê†áÁ≠æ", cls: "mod-cta" });
            const chipsHolder = tagRow.createEl("div");
            this.renderTagChips(chipsHolder);
            pickBtn.onclick = () => this.openTagPicker(chipsHolder);

            const btnRow = form.createEl("div", { attr: { style: "display:flex; justify-content:flex-end; gap:10px; margin-top:10px;" } });
            const cancelBtn = btnRow.createEl("button", { text: "ÂèñÊ∂à" });
            const deleteBtn = btnRow.createEl("button", { text: "Âà†Èô§", attr: { style: "color:#e74c3c; border:1px solid #e74c3c; padding:6px 12px; border-radius:6px;" } });
            const saveBtn = btnRow.createEl("button", { text: "‰øùÂ≠ò", cls: "mod-cta" });

            cancelBtn.onclick = () => this.close();
            deleteBtn.onclick = async () => {
                const ok = confirm("Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™‰∫ãÈ°πÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄ„ÄÇ");
                if (!ok) return;
                this.onSave({ ...this.item, __delete: true });
                this.close();
            };
            saveBtn.onclick = () => {
                if (!nameInput.value.trim()) { new Notice("ËØ∑ËæìÂÖ•ÂêçÁß∞"); return; }
                if (!startInput.value || !endInput.value) { new Notice("ËØ∑ËæìÂÖ•ÂºÄÂßã/ÁªìÊùüÊó•Êúü"); return; }
                if (moment(endInput.value).isBefore(moment(startInput.value))) { new Notice("ÁªìÊùüÊó•Êúü‰∏çËÉΩÊó©‰∫éÂºÄÂßã"); return; }
                this.item.name = nameInput.value.trim();
                this.item.startDate = startInput.value;
                this.item.endDate = endInput.value;
                this.item.comment = commentArea.value || "";
                this.onSave(this.item);
                this.close();
            };
        }
    }

    // ===== 4. Ê†áÁ≠æÁÆ°ÁêÜËßÜÂõæ =====

    const renderTagManagerView = (container) => {
        container.empty();

        const style = `<style>
            .tag-mgr-container { background: var(--background-secondary); border-radius: 12px; padding: 20px; font-family: sans-serif; }
            .tag-mgr-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--interactive-accent); }
            .tag-mgr-title { font-size: 1.5em; font-weight: 800; color: var(--text-normal); margin: 0; display: flex; align-items: center; gap: 8px; }
            .tag-mgr-actions { display: flex; gap: 8px; }
            .tag-mgr-btn { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; transition: all 0.2s; }
            .tag-mgr-btn-primary { background: var(--interactive-accent); color: white; }
            .tag-mgr-btn-secondary { background: var(--background-modifier-border); color: var(--text-normal); }
            .tag-item { display: flex; align-items: center; padding: 10px 12px; margin: 4px 0; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 8px; transition: all 0.2s; }
            .tag-item:hover { border-color: var(--interactive-accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
            .tag-item.drag-over { border-color: var(--interactive-accent); box-shadow: 0 0 0 2px var(--interactive-accent); }
            .tag-item.is-category { background: linear-gradient(135deg, var(--background-primary) 0%, var(--background-secondary) 100%); border-width: 2px; }
            .tag-color-dot { width: 16px; height: 16px; border-radius: 50%; margin-right: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
            .tag-icon { font-size: 1.2em; margin-right: 8px; }
            .tag-label { font-weight: 600; color: var(--text-normal); }
            .tag-meta { font-size: 0.8em; color: var(--text-muted); margin-top: 2px; }
            .tag-actions { display: flex; gap: 6px; margin-left: auto; }
            .tag-action-btn { padding: 4px 8px; border-radius: 4px; border: 1px solid var(--background-modifier-border); background: var(--background-secondary); cursor: pointer; font-size: 12px; }
            .tag-action-btn:hover { background: var(--interactive-accent); color: white; border-color: transparent; }
            .tag-children { margin-left: 30px; border-left: 2px solid var(--background-modifier-border); padding-left: 15px; margin-top: 5px; }
            .tag-form { background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 8px; padding: 15px; margin-bottom: 15px; }
            .tag-form-row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
            .tag-form-label { width: 60px; font-weight: 500; color: var(--text-muted); font-size: 0.9em; }
            .tag-form-input { flex: 1; padding: 8px 12px; border: 1px solid var(--background-modifier-border); border-radius: 6px; background: var(--background-secondary); color: var(--text-normal); }
            .tag-stats { display: flex; gap: 20px; padding: 10px 15px; background: var(--background-primary); border-radius: 8px; margin-bottom: 15px; font-size: 0.9em; color: var(--text-muted); }
            .tag-stat-num { font-weight: 700; color: var(--text-normal); }
        </style>`;

        container.innerHTML = style;
        const wrapper = container.createEl("div", { cls: "tag-mgr-container" });

        // Â§¥ÈÉ®
        const header = wrapper.createEl("div", { cls: "tag-mgr-header" });
        header.createEl("div", { cls: "tag-mgr-title" }).innerHTML = `üè∑Ô∏è Ê†áÁ≠æÁÆ°ÁêÜÂô®`;
        const headerActions = header.createEl("div", { cls: "tag-mgr-actions" });

        const addTagBtn = headerActions.createEl("button", { text: "‚ûï Êñ∞Âª∫Ê†áÁ≠æ", cls: "tag-mgr-btn tag-mgr-btn-primary" });
        const addCategoryBtn = headerActions.createEl("button", { text: "üìÅ Êñ∞Âª∫ÂàÜÁ±ª", cls: "tag-mgr-btn tag-mgr-btn-secondary" });
        const exitBtn = headerActions.createEl("button", { text: "ËøîÂõû‰∏ªÁïåÈù¢", cls: "tag-mgr-btn tag-mgr-btn-secondary" });
        exitBtn.onclick = () => { window.timelineTagManagerMode = false; if (renderViewFn) renderViewFn(); };

        // ÁªüËÆ°
        const topLevelCount = Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k]?.parentId === null).length;
        const categoryCount = Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k]?.isCategory).length;
        const leafCount = Object.keys(TAG_DEFINITIONS).filter(k => !TAG_DEFINITIONS[k]?.isCategory).length;
        const stats = wrapper.createEl("div", { cls: "tag-stats" });
        stats.innerHTML = `
            <span>üìä ÊÄªËÆ°: <span class="tag-stat-num">${Object.keys(TAG_DEFINITIONS).length}</span> ‰∏™</span>
            <span>üìÅ ÂàÜÁ±ª: <span class="tag-stat-num">${categoryCount}</span></span>
            <span>üè∑Ô∏è Ê†áÁ≠æ: <span class="tag-stat-num">${leafCount}</span></span>
            <span>üå≤ È°∂Â±Ç: <span class="tag-stat-num">${topLevelCount}</span></span>
        `;

        // Ë°®Âçï
        const formContainer = wrapper.createEl("div", { cls: "tag-form", attr: { style: "display:none;" } });
        let editingTagId = null;

        const showTagForm = (tagId = null) => {
            editingTagId = tagId;
            const tag = tagId ? TAG_DEFINITIONS[tagId] : null;
            formContainer.innerHTML = "";
            formContainer.style.display = "block";

            formContainer.createEl("div", {
                text: tagId ? "‚úèÔ∏è ÁºñËæëÊ†áÁ≠æ" : "‚ûï Êñ∞Âª∫Ê†áÁ≠æ",
                attr: { style: "font-weight:700; margin-bottom:12px; font-size:1.1em;" }
            });

            const idRow = formContainer.createEl("div", { cls: "tag-form-row" });
            idRow.createEl("span", { text: "ID:", cls: "tag-form-label" });
            const idInputAttr = tagId ? { disabled: "true" } : {};
            const idInput = idRow.createEl("input", { type: "text", cls: "tag-form-input", value: tagId || "", attr: idInputAttr });
            idInput.placeholder = "ÂîØ‰∏ÄÊ†áËØÜÁ¨¶ (Ëã±Êñá)";

            const labelRow = formContainer.createEl("div", { cls: "tag-form-row" });
            labelRow.createEl("span", { text: "ÂêçÁß∞:", cls: "tag-form-label" });
            const labelInput = labelRow.createEl("input", { type: "text", cls: "tag-form-input", value: tag?.label || "", attr: { placeholder: "ÊòæÁ§∫ÂêçÁß∞" } });

            const iconRow = formContainer.createEl("div", { cls: "tag-form-row" });
            iconRow.createEl("span", { text: "ÂõæÊ†á:", cls: "tag-form-label" });
            const iconInput = iconRow.createEl("input", { type: "text", cls: "tag-form-input", value: tag?.icon || "üè∑Ô∏è", attr: { placeholder: "Emoji" } });

            const colorRow = formContainer.createEl("div", { cls: "tag-form-row" });
            colorRow.createEl("span", { text: "È¢úËâ≤:", cls: "tag-form-label" });
            const colorInput = colorRow.createEl("input", { type: "color", value: tag?.color || "#3498db", attr: { style: "width:50px; height:35px; padding:2px;" } });

            const parentRow = formContainer.createEl("div", { cls: "tag-form-row" });
            parentRow.createEl("span", { text: "Áà∂Á∫ß:", cls: "tag-form-label" });
            const parentInput = parentRow.createEl("input", {
                type: "text",
                cls: "tag-form-input",
                attr: { placeholder: "ËæìÂÖ•Á≠õÈÄâÔºåÁïôÁ©∫‰∏∫È°∂Â±Ç" }
            });
            const dataListId = `timeline-tag-parent-list-${Date.now()}`;
            parentInput.setAttr("list", dataListId);
            const parentList = formContainer.createEl("datalist", { attr: { id: dataListId } });
            const parentCandidates = sortTagIdsByName(Object.keys(TAG_DEFINITIONS).filter(k => k !== tagId));
            parentCandidates.forEach(k => {
                const opt = parentList.createEl("option");
                opt.value = formatTagOptionValue(k);
            });
            parentInput.value = tag?.parentId ? formatTagOptionValue(tag.parentId) : "";

            const categoryRow = formContainer.createEl("div", { cls: "tag-form-row" });
            categoryRow.createEl("span", { text: "ÂàÜÁ±ª:", cls: "tag-form-label" });
            const categoryCheck = categoryRow.createEl("input", { type: "checkbox" });
            categoryCheck.checked = tag?.isCategory || false;
            categoryRow.createEl("span", { text: "ËÆæ‰∏∫ÂàÜÁ±ª", attr: { style: "margin-left:8px;" } });

            const btnRow = formContainer.createEl("div", { cls: "tag-form-row", attr: { style: "justify-content:flex-end; margin-top:15px;" } });
            const cancelBtn = btnRow.createEl("button", { text: "ÂèñÊ∂à", cls: "tag-mgr-btn tag-mgr-btn-secondary" });
            cancelBtn.onclick = () => { formContainer.style.display = "none"; };
            const saveBtn = btnRow.createEl("button", { text: tagId ? "‰øùÂ≠ò‰øÆÊîπ" : "ÂàõÂª∫Ê†áÁ≠æ", cls: "tag-mgr-btn tag-mgr-btn-primary" });

            saveBtn.onclick = async () => {
                const newId = idInput.value.trim();
                if (!newId) { new Notice("‚ö†Ô∏è ËØ∑ËæìÂÖ•Ê†áÁ≠æID"); return; }
                if (!labelInput.value.trim()) { new Notice("‚ö†Ô∏è ËØ∑ËæìÂÖ•Ê†áÁ≠æÂêçÁß∞"); return; }
                if (!tagId && TAG_DEFINITIONS[newId]) { new Notice("‚ö†Ô∏è ËØ•IDÂ∑≤Â≠òÂú®"); return; }

                const rawParent = parentInput.value.trim();
                let parentId = null;
                if (rawParent) {
                    if (TAG_DEFINITIONS[rawParent]) {
                        parentId = rawParent;
                    } else {
                        const match = rawParent.match(/\(([^)]+)\)\s*$/);
                        if (match && TAG_DEFINITIONS[match[1]]) parentId = match[1];
                    }
                    if (!parentId) {
                        const labelMatches = Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k]?.label?.trim() === rawParent);
                        if (labelMatches.length === 1) parentId = labelMatches[0];
                    }
                    if (!parentId) { new Notice("‚ö†Ô∏è Áà∂Á∫ßÊó†ÊïàÔºåËØ∑‰ªéÂàóË°®ÈÄâÊã©ÊàñÁïôÁ©∫"); return; }
                    if (parentId === newId) { new Notice("‚ö†Ô∏è Áà∂Á∫ß‰∏çËÉΩÊòØËá™Â∑±"); return; }
                    if (isCycle(parentId, newId)) { new Notice("‚ùå ‰∏çËÉΩÈÄâÊã©Ëá™Â∑±ÁöÑÂ≠êÂ±ÇÁ∫ß"); return; }
                }

                TAG_DEFINITIONS[newId] = {
                    label: labelInput.value.trim(),
                    icon: iconInput.value.trim() || "üè∑Ô∏è",
                    color: colorInput.value,
                    parentId: parentId || null,
                    isCategory: categoryCheck.checked,
                    order: tag?.order || Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k]?.parentId === (parentId || null)).length
                };

                if (tagId && tagId !== newId) {
                    Object.keys(TAG_DEFINITIONS).forEach(k => {
                        if (TAG_DEFINITIONS[k]?.parentId === tagId) TAG_DEFINITIONS[k].parentId = newId;
                    });
                    delete TAG_DEFINITIONS[tagId];
                }

                await saveTagDefinitions(TAG_DEFINITIONS);
                TAG_DEFINITIONS = await loadTagDefinitions();
                new Notice(tagId ? "‚úÖ Ê†áÁ≠æÂ∑≤Êõ¥Êñ∞" : "‚úÖ Ê†áÁ≠æÂ∑≤ÂàõÂª∫");
                formContainer.style.display = "none";
                if (renderViewFn) renderViewFn();
            };
        };

        addTagBtn.onclick = () => showTagForm(null);
        addCategoryBtn.onclick = () => {
            showTagForm(null);
            setTimeout(() => {
                const checkbox = formContainer.querySelector('input[type="checkbox"]');
                if (checkbox) checkbox.checked = true;
            }, 50);
        };

        const isCycle = (candidateParentId, nodeId) => {
            if (!candidateParentId) return false;
            if (candidateParentId === nodeId) return true;
            let cursor = TAG_DEFINITIONS[candidateParentId]?.parentId || null;
            while (cursor) {
                if (cursor === nodeId) return true;
                cursor = TAG_DEFINITIONS[cursor]?.parentId || null;
            }
            return false;
        };

        const normalizeOrders = (parentId) => {
            const siblings = getChildTags(parentId);
            siblings.forEach((id, idx) => {
                if (TAG_DEFINITIONS[id]) TAG_DEFINITIONS[id].order = idx;
            });
        };

        // ÈÄíÂΩíÊ∏≤ÊüìÊ†áÁ≠æÊ†ë
        const treeContainer = wrapper.createEl("div", { attr: { style: "margin-top:15px;" } });

        const renderTagTree = (parentId, container, level = 0) => {
            const children = sortTagIdsByName(getChildTags(parentId));

            children.forEach(tagId => {
                const def = TAG_DEFINITIONS[tagId];
                if (!def) return;

                const item = container.createEl("div", {
                    cls: `tag-item ${def.isCategory ? 'is-category' : ''}`,
                    attr: { draggable: "true" }
                });

                item.createEl("div", { cls: "tag-color-dot", attr: { style: `background:${def.color};` } });
                item.createEl("span", { cls: "tag-icon", text: def.icon });
                const info = item.createEl("div");
                info.createEl("div", { cls: "tag-label", text: def.label });
                info.createEl("div", { cls: "tag-meta", text: `ID: ${tagId} | ${def.isCategory ? 'üìÅ ÂàÜÁ±ª' : 'üè∑Ô∏è Ê†áÁ≠æ'}` });

                const actions = item.createEl("div", { cls: "tag-actions" });
                const editBtn = actions.createEl("button", { text: "‚úèÔ∏è", cls: "tag-action-btn" });
                editBtn.onclick = () => showTagForm(tagId);

                const deleteBtn = actions.createEl("button", { text: "üóëÔ∏è", cls: "tag-action-btn" });
                const childCount = getChildTags(tagId).length;
                const usageCount = (timelineData.items || []).filter(i => i.tags && i.tags.includes(tagId)).length;
                deleteBtn.onclick = async () => {
                    if (childCount > 0) { new Notice("‚ö†Ô∏è ËØ∑ÂÖàÂà†Èô§Â≠êÊ†áÁ≠æ"); return; }
                    if (usageCount > 0) { new Notice(`‚ö†Ô∏è ËØ•Ê†áÁ≠æÊ≠£Âú®Ë¢´ ${usageCount} ‰∏™‰∫ãÈ°π‰ΩøÁî®`); return; }
                    if (confirm(`Á°ÆÂÆöÂà†Èô§ "${def.label}" ÂêóÔºü`)) {
                        delete TAG_DEFINITIONS[tagId];
                        await saveTagDefinitions(TAG_DEFINITIONS);
                        TAG_DEFINITIONS = await loadTagDefinitions();
                        new Notice("üóëÔ∏è Ê†áÁ≠æÂ∑≤Âà†Èô§");
                        if (renderViewFn) renderViewFn();
                    }
                };

                // ÊãñÊãΩÊéíÂ∫èÔºö‰ªÖÂú®Âêå‰∏ÄÁà∂Á∫ßÂÜÖË∞ÉÊï¥ order
                const reorderWithinParent = async (sourceId, targetId) => {
                    const parentId = def.parentId || null;
                    const siblings = getChildTags(parentId);
                    const srcIdx = siblings.indexOf(sourceId);
                    const tgtIdx = siblings.indexOf(targetId);
                    if (srcIdx === -1 || tgtIdx === -1) return;
                    siblings.splice(srcIdx, 1);
                    siblings.splice(tgtIdx, 0, sourceId);
                    siblings.forEach((id, idx) => {
                        if (TAG_DEFINITIONS[id]) TAG_DEFINITIONS[id].order = idx;
                    });
                    await saveTagDefinitions(TAG_DEFINITIONS);
                    TAG_DEFINITIONS = await loadTagDefinitions();
                    if (renderViewFn) renderViewFn();
                };

                item.addEventListener("dragstart", (e) => {
                    e.dataTransfer.setData("text/tag-id", tagId);
                    e.dataTransfer.setData("text/parent-id", def.parentId || "");
                    item.classList.add("is-dragging");
                });

                item.addEventListener("dragend", () => item.classList.remove("is-dragging"));

                item.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    item.classList.add("drag-over");
                });

                item.addEventListener("dragleave", () => item.classList.remove("drag-over"));

                item.addEventListener("drop", async (e) => {
                    const srcId = e.dataTransfer.getData("text/tag-id");
                    const srcParent = e.dataTransfer.getData("text/parent-id") || null;
                    item.classList.remove("drag-over");
                    if (!srcId || srcId === tagId) return;
                    const targetAsParent = tagId;
                    // ÂêåÁ∫ßÊéíÂ∫è
                    if (srcParent === (def.parentId || null)) {
                        await reorderWithinParent(srcId, tagId);
                        return;
                    }
                    // Ë∑®Â±ÇÁ∫ßÔºöÊîπÁà∂Á∫ß
                    if (isCycle(targetAsParent, srcId)) {
                        new Notice("‚ùå ‰∏çËÉΩÂ∞ÜÊ†áÁ≠æÁßªÂä®Âà∞Ëá™Â∑±ÁöÑÂ≠êÂ±ÇÁ∫ß");
                        return;
                    }
                    const oldParent = srcParent || null;
                    TAG_DEFINITIONS[srcId].parentId = targetAsParent;
                    TAG_DEFINITIONS[srcId].order = getChildTags(targetAsParent).length;
                    normalizeOrders(oldParent);
                    normalizeOrders(targetAsParent);
                    await saveTagDefinitions(TAG_DEFINITIONS);
                    TAG_DEFINITIONS = await loadTagDefinitions();
                    new Notice("‚úÖ Â∑≤Ë∞ÉÊï¥Â±ÇÁ∫ß");
                    if (renderViewFn) renderViewFn();
                });

                const hasChildren = getChildTags(tagId).length > 0;
                if (hasChildren) {
                    const childrenContainer = container.createEl("div", { cls: "tag-children" });
                    renderTagTree(tagId, childrenContainer, level + 1);
                }
            });
        };

        // È°∂Â±ÇÊãñÊîæÂå∫ÔºöÊãñÂà∞ËøôÈáåËÆæ‰∏∫È°∂Â±Ç
        const rootDrop = wrapper.createEl("div", {
            text: "‚áß ÊãñÊãΩÂà∞ËøôÈáåËÆæ‰∏∫È°∂Â±Ç",
            attr: { style: "padding:8px 12px; margin-top:8px; border:1px dashed var(--interactive-accent); border-radius:6px; color:var(--text-muted); font-size:12px;" }
        });
        rootDrop.addEventListener("dragover", (e) => { e.preventDefault(); rootDrop.style.background = "var(--background-primary)"; });
        rootDrop.addEventListener("dragleave", () => { rootDrop.style.background = "transparent"; });
        rootDrop.addEventListener("drop", async (e) => {
            e.preventDefault();
            rootDrop.style.background = "transparent";
            const srcId = e.dataTransfer.getData("text/tag-id");
            if (!srcId) return;
            if (TAG_DEFINITIONS[srcId]?.parentId === null) return;
            if (isCycle(null, srcId)) return; // always false but keep symmetry
            const oldParent = TAG_DEFINITIONS[srcId].parentId || null;
            TAG_DEFINITIONS[srcId].parentId = null;
            TAG_DEFINITIONS[srcId].order = getChildTags(null).length;
            normalizeOrders(oldParent);
            normalizeOrders(null);
            await saveTagDefinitions(TAG_DEFINITIONS);
            TAG_DEFINITIONS = await loadTagDefinitions();
            new Notice("‚úÖ Â∑≤ÁßªÂà∞È°∂Â±Ç");
            if (renderViewFn) renderViewFn();
        });

        renderTagTree(null, treeContainer);

        if (Object.keys(TAG_DEFINITIONS).length === 0) {
            treeContainer.createEl("div", {
                text: "ÊöÇÊó†Ê†áÁ≠æÔºåÁÇπÂáª‰∏äÊñπÊåâÈíÆÂàõÂª∫",
                attr: { style: "text-align:center; padding:40px; color:var(--text-muted);" }
            });
        }
    };

    // ===== 5. Mermaid Gantt Êó∂Èó¥Á∫øËßÜÂõæ =====

    const filterGanttItems = (data, activeRange, useViewRange) => {
        const scheduledOnly = !!window.timelineDayblockOnlyScheduled;
        return data.filter(item => {
            if (!tagMatchesFilter(item.tags, window.timelineTagFilters)) return false;
            if (scheduledOnly && !itemHasScheduledInRange(item, activeRange.start, activeRange.end)) return false;
            if (!useViewRange) return true;
            const s = moment(item.startDate);
            const e = moment(item.endDate);
            return e.isSameOrAfter(activeRange.start, "day") && s.isSameOrBefore(activeRange.end, "day");
        });
    };

    // ÁîüÊàê Mermaid Gantt ‰ª£Á†Å
    const generateMermaidGanttCode = (data, config, activeRange, useViewRange) => {
        if (data.length === 0) {
            return `gantt
    title ÊöÇÊó†‰∫ãÈ°π
    section Á©∫
    ËØ∑Ê∑ªÂä†‰∫ãÈ°π :crit, 0d`;
        }

        const filteredData = filterGanttItems(data, activeRange, useViewRange);

        if (filteredData.length === 0) {
            const emptyTitle = useViewRange ? "ÂΩìÂâçËåÉÂõ¥ÊöÇÊó†‰∫ãÈ°π" : "ÂΩìÂâçÁ≠õÈÄâÊöÇÊó†‰∫ãÈ°π";
            return `gantt
    title ${emptyTitle}
    dateFormat  YYYY-MM-DD
    axisFormat ${config.axisFormat || "%Y-%m-%d"}
    section ÊèêÁ§∫
    Âú®ÈÄâÊã©ÁöÑÊù°‰ª∂ÂÜÖÊ≤°Êúâ‰∫ãÈ°π :crit, ${activeRange.start.format("YYYY-MM-DD")}, 1d`;
        }

        // ËÆ°ÁÆóÊó•ÊúüËåÉÂõ¥
        let minDate = activeRange.start.clone();
        let maxDate = activeRange.end.clone();

        const startDateStr = minDate.format("YYYY-MM-DD");
        const axisFormat = config.axisFormat || "%Y-%m-%d";

        // ÊåâÊ†áÁ≠æÂàÜÁªÑ
        const groupedData = {};
        filteredData.forEach(item => {
            if (item.tags && item.tags.length > 0) {
                const primaryTag = item.tags[0];
                const tagDef = TAG_DEFINITIONS[primaryTag];
                const groupName = tagDef ? `${tagDef.icon} ${tagDef.label}` : "Êú™ÂàÜÁ±ª";
                if (!groupedData[groupName]) groupedData[groupName] = [];
                groupedData[groupName].push(item);
            } else {
                if (!groupedData["Êú™ÂàÜÁ±ª"]) groupedData["Êú™ÂàÜÁ±ª"] = [];
                groupedData["Êú™ÂàÜÁ±ª"].push(item);
            }
        });

        let code = `%%{init: { "theme": "base" }}%%
gantt
    title Timeline Êó∂Èó¥Á∫øËßÜÂõæ
    dateFormat  YYYY-MM-DD
    axisFormat ${axisFormat}
    excludes weekends

`;

        // ÁîüÊàê sections
        Object.keys(groupedData).forEach(groupName => {
            code += `    section ${groupName}\n`;
            groupedData[groupName].forEach((item, idx) => {
                const taskId = `task_${item.id}`;
                const safeName = (item.name || "")
                    .replace(/:/g, "Ôºö")
                    .replace(/\|/g, "ÔΩú")
                    .replace(/\"/g, "ÔºÇ")
                    .replace(/\n/g, " ");
                const rangeStart = activeRange.start.clone();
                const rangeEnd = activeRange.end.clone();
                const startMoment = moment(item.startDate);
                const endMoment = moment(item.endDate);
                const clippedStart = useViewRange && startMoment.isBefore(rangeStart, "day") ? rangeStart.clone() : startMoment;
                const clippedEnd = useViewRange && endMoment.isAfter(rangeEnd, "day") ? rangeEnd.clone() : endMoment;
                const startDate = clippedStart.format("YYYY-MM-DD");
                // ÁªìÊùüÊó•ÊúüÔºöÈÄâÂÆöËåÉÂõ¥ÂÜÖ‰∏çÂä†‰∏ÄÂ§©ÔºåÈÅøÂÖçÈáåÁ®ãÁ¢ëÈù†ËøëËæπÁïåÊó∂Èîô‰Ωç
                const endDate = useViewRange
                    ? clippedEnd.format("YYYY-MM-DD")
                    : clippedEnd.clone().add(1, 'day').format("YYYY-MM-DD");

                // Ê£ÄÊü•ËØ•‰∫ãÈ°πÂú®ÂΩìÂâçËßÜÂõæËåÉÂõ¥ÂÜÖÊòØÂê¶ÊúâÈáåÁ®ãÁ¢ë
                const milestones = timelineData.milestones ?
                    Object.values(timelineData.milestones).filter(m => {
                        if (m.itemId !== item.id) return false;
                        if (!useViewRange) return true;
                        return moment(m.date).isBetween(activeRange.start, activeRange.end, "day", "[]");
                    }).sort((a, b) => moment(a.date).diff(moment(b.date))) : [];

                let displayName = safeName;
                if (milestones.length > 0) {
                    const completedCount = milestones.filter(m => m.completed).length;
                    const totalCount = milestones.length;
                    // Âú®‰∫ãÈ°πÂêçÁß∞ÂêéÊ∑ªÂä†ÈáåÁ®ãÁ¢ë‰ø°ÊÅØ
                    displayName = `${safeName} [üéØ${completedCount}/${totalCount}]`;
                }

                // ‰ΩøÁî®ÊòæÂºèÁªìÊùüÊó•ÊúüÔºåÈÅøÂÖç duration Â∑Æ‰∏ÄÊó•
                code += `    ${displayName} :${taskId}, ${startDate}, ${endDate}\n`;

                // Âú®‰∫ãÈ°π‰∏ãÊñπÊ∑ªÂä†ÈáåÁ®ãÁ¢ëÔºàÁõ¥Êé•Ë∑üÂú®‰∫ãÈ°πÂêéÈù¢Ôºå‰∏ç‰ΩøÁî®sectionÔºå‰øùÊåÅËßÜËßâ‰∏äÁöÑÂ±ÇÁ∫ßÂÖ≥Á≥ªÔºâ
                milestones.forEach(m => {
                    const mileDate = moment(m.date).isValid() ? moment(m.date).format("YYYY-MM-DD") : m.date;
                    const mileTaskId = `mile_${m.id}`;
                    const status = m.completed ? "‚úÖ" : "üî≤";
                    const safeMileName = (m.name || "")
                        .replace(/:/g, "Ôºö")
                        .replace(/\|/g, "ÔΩú")
                        .replace(/\"/g, "ÔºÇ")
                        .replace(/\n/g, " ");
                    // ‰ΩøÁî® milestone ‰Ωú‰∏∫ 0 ÊåÅÁª≠Êó∂Èó¥ÁöÑ‰ªªÂä°ÔºåÂπ∂Ê∑ªÂä†Áº©ËøõÂâçÁºÄË°®Á§∫Â±ÇÁ∫ß
                    code += `        ${status} ${mileDate} ${safeMileName} :${mileTaskId}, ${mileDate}, 0d\n`;
                });
            });
        });

        // ÁßªÈô§Áã¨Á´ãÁöÑ"üìç ÈáåÁ®ãÁ¢ë"sectionÔºåÊîπ‰∏∫Â∞ÜÈáåÁ®ãÁ¢ëÁõ¥Êé•ÊîæÂú®‰∫ãÈ°π‰∏ãÊñπ
        // ‰∏ãÈù¢‰∏çÂÜçÈúÄË¶ÅÂçïÁã¨ÁöÑÈáåÁ®ãÁ¢ëÊ±áÊÄªÂå∫Âùó
        const allMilestones = [];
        if (timelineData.milestones) {
            Object.values(timelineData.milestones).forEach(m => {
                if (useViewRange && !moment(m.date).isBetween(activeRange.start, activeRange.end, "day", "[]")) return;
                const item = filteredData.find(i => i.id === m.itemId);
                if (item) {
                    allMilestones.push({ ...m, itemName: item.name });
                }
            });
        }

        // Â¶ÇÊûúÊúâ‰∏çÂú®‰ªª‰Ωï‰∫ãÈ°πËåÉÂõ¥ÂÜÖÁöÑÈáåÁ®ãÁ¢ëÔºåÊ∑ªÂä†‰∏Ä‰∏™Áã¨Á´ãÁöÑÈáåÁ®ãÁ¢ësectionÊòæÁ§∫ÂÆÉ‰ª¨
        const milestoneItemIds = new Set(filteredData.map(i => i.id));
        const orphanedMilestones = allMilestones.filter(m => !milestoneItemIds.has(m.itemId));

        if (orphanedMilestones.length > 0) {
            code += `\n    section üìç ÂÖ∂‰ªñÈáåÁ®ãÁ¢ë\n`;
            orphanedMilestones.forEach(m => {
                const mileDate = moment(m.date).isValid() ? moment(m.date).format("YYYY-MM-DD") : m.date;
                const taskId = `mile_${m.id}`;
                const safeMileName = (m.name || "").replace(/:/g, "Ôºö").replace(/\|/g, "ÔΩú").replace(/\"/g, "ÔºÇ").replace(/\n/g, " ");
                const safeItemName = (m.itemName || "").replace(/:/g, "Ôºö").replace(/\|/g, "ÔΩú").replace(/\"/g, "ÔºÇ").replace(/\n/g, " ");
                // ‰ΩøÁî® milestone ‰Ωú‰∏∫ 0 ÊåÅÁª≠Êó∂Èó¥ÁöÑ‰ªªÂä°
                code += `    üéØ ${safeMileName} (${safeItemName}) :${taskId}, ${mileDate}, 0d\n`;
            });
        }

        return code;
    };

    // Ê∏≤Êüì Mermaid Gantt ÂõæË°®
    const renderMermaidGantt = async (container, data) => {
        container.empty();
        const activeRange = getActiveRange();
        const useViewRange = window.timelineGanttRangeMode === "view";

        // Á≠õÈÄâÊï∞ÊçÆÔºàÊ†áÁ≠æ + ÂèØÈÄâÊó∂Èó¥ËåÉÂõ¥Ôºâ
        const filteredData = filterGanttItems(data, activeRange, useViewRange);

        // Â∑•ÂÖ∑Ê†è
        const toolbar = container.createEl("div", {
            attr: {
                style: `
                    display:flex;
                    gap:10px;
                    padding:10px 15px;
                    background:var(--background-secondary);
                    border-bottom:1px solid var(--background-modifier-border);
                    align-items:center;
                    flex-wrap:wrap;
                `
            }
        });

        toolbar.createEl("span", { text: "üîç Áº©Êîæ:", attr: { style: "font-weight:600;" } });

        Object.keys(MERMAID_CONFIG.zoom).forEach(zoomKey => {
            const btn = toolbar.createEl("button", {
                text: MERMAID_CONFIG.zoom[zoomKey].label || zoomKey,
                attr: {
                    style: `
                        padding:6px 12px;
                        border-radius:4px;
                        border:1px solid var(--background-modifier-border);
                        cursor:pointer;
                        background:${window.timelineZoom === zoomKey ? 'var(--interactive-accent)' : 'transparent'};
                        color:${window.timelineZoom === zoomKey ? 'white' : 'var(--text-normal)'};
                    `
                }
            });
            btn.addEventListener("click", () => { window.timelineZoom = zoomKey; renderViewFn(); });
        });

        // ËåÉÂõ¥ÂàáÊç¢
        const rangeContainer = toolbar.createEl("div", { attr: { style: "display:flex; gap:6px; align-items:center; margin-left:20px; flex-wrap:wrap;" } });
        rangeContainer.createEl("span", { text: "‚è±Ô∏è ËåÉÂõ¥:", attr: { style: "font-weight:600;" } });

        const weekBtn = rangeContainer.createEl("button", {
            text: "Êú¨Âë®",
            attr: {
                style: `
                    padding:6px 10px;
                    border-radius:6px;
                    border:1px solid var(--background-modifier-border);
                    cursor:pointer;
                    background:${window.timelineRangeMode === 'week' ? 'var(--interactive-accent)' : 'transparent'};
                    color:${window.timelineRangeMode === 'week' ? '#fff' : 'var(--text-normal)'};
                `
            }
        });
        weekBtn.onclick = async () => {
            window.timelineRangeMode = "week";
            window.timelineCustomStart = moment().startOf("isoWeek").format("YYYY-MM-DD");
            window.timelineCustomEnd = moment().endOf("isoWeek").format("YYYY-MM-DD");
            await persistViewRange();
        };

        const customBtn = rangeContainer.createEl("button", {
            text: "Ëá™ÂÆö‰πâ",
            attr: {
                style: `
                    padding:6px 10px;
                    border-radius:6px;
                    border:1px solid var(--background-modifier-border);
                    cursor:pointer;
                    background:${window.timelineRangeMode === 'custom' ? 'var(--interactive-accent)' : 'transparent'};
                    color:${window.timelineRangeMode === 'custom' ? '#fff' : 'var(--text-normal)'};
                `
            }
        });
        customBtn.onclick = async () => {
            window.timelineRangeMode = "custom";
            if (!window.timelineCustomStart || !window.timelineCustomEnd) {
                window.timelineCustomStart = moment().startOf("isoWeek").format("YYYY-MM-DD");
                window.timelineCustomEnd = moment().endOf("isoWeek").format("YYYY-MM-DD");
            }
            await persistViewRange();
        };

        const startInput = rangeContainer.createEl("input", { type: "date", value: window.timelineCustomStart, attr: { style: "padding:4px 8px;" } });
        const endInput = rangeContainer.createEl("input", { type: "date", value: window.timelineCustomEnd, attr: { style: "padding:4px 8px;" } });
        const applyBtn = rangeContainer.createEl("button", { text: "‰øùÂ≠òËåÉÂõ¥", cls: "mod-cta" });

        const setInputDisabled = () => {
            const disabled = window.timelineRangeMode !== "custom";
            startInput.disabled = disabled;
            endInput.disabled = disabled;
            applyBtn.disabled = disabled;
            applyBtn.style.opacity = disabled ? 0.6 : 1;
        };
        setInputDisabled();

        applyBtn.onclick = async () => {
            if (window.timelineRangeMode !== "custom") return;
            if (!startInput.value || !endInput.value) { new Notice("ËØ∑ËæìÂÖ•ÂºÄÂßã/ÁªìÊùüÊó•Êúü"); return; }
            if (moment(endInput.value).isBefore(moment(startInput.value))) { new Notice("ÁªìÊùüÊó•Êúü‰∏çËÉΩÊó©‰∫éÂºÄÂßã"); return; }
            window.timelineCustomStart = startInput.value;
            window.timelineCustomEnd = endInput.value;
            await persistViewRange();
        };

        // ÁîòÁâπËåÉÂõ¥ÂàáÊç¢Ôºà‰∫ãÈ°πËåÉÂõ¥ / ÈÄâÂÆöËåÉÂõ¥Ôºâ
        const ganttRangeContainer = toolbar.createEl("div", { attr: { style: "display:flex; gap:6px; align-items:center; margin-left:20px; flex-wrap:wrap;" } });
        ganttRangeContainer.createEl("span", { text: "üìä ÁîòÁâπ:", attr: { style: "font-weight:600;" } });
        const autoRangeBtn = ganttRangeContainer.createEl("button", {
            text: "‰∫ãÈ°πËåÉÂõ¥",
            attr: {
                style: `
                    padding:6px 10px;
                    border-radius:6px;
                    border:1px solid var(--background-modifier-border);
                    cursor:pointer;
                    background:${window.timelineGanttRangeMode === 'auto' ? 'var(--interactive-accent)' : 'transparent'};
                    color:${window.timelineGanttRangeMode === 'auto' ? '#fff' : 'var(--text-normal)'};
                `
            }
        });
        autoRangeBtn.onclick = async () => {
            window.timelineGanttRangeMode = "auto";
            await persistViewRange();
        };

        const viewRangeBtn = ganttRangeContainer.createEl("button", {
            text: "ÈÄâÂÆöËåÉÂõ¥",
            attr: {
                style: `
                    padding:6px 10px;
                    border-radius:6px;
                    border:1px solid var(--background-modifier-border);
                    cursor:pointer;
                    background:${window.timelineGanttRangeMode === 'view' ? 'var(--interactive-accent)' : 'transparent'};
                    color:${window.timelineGanttRangeMode === 'view' ? '#fff' : 'var(--text-normal)'};
                `
            }
        });
        viewRangeBtn.onclick = async () => {
            window.timelineGanttRangeMode = "view";
            await persistViewRange();
        };

        // Ê†áÁ≠æÁ≠õÈÄâÂô®ÔºàÂµåÂ•óÂ±ÇÁ∫ßÊ†∑ÂºèÔºåÂèÇËÄÉ GTD ÁïåÈù¢ - Áà∂Ê†áÁ≠æÂ•óÂúàÂ≠êÊ†áÁ≠æÔºâ
        const filterContainer = toolbar.createEl("div", { attr: { style: "display:flex; gap:10px; align-items:flex-start; margin-left:20px; flex-wrap:wrap; flex:1 1 100%; padding-top:4px;" } });
        filterContainer.createEl("span", { text: "üè∑Ô∏è Á≠õÈÄâ:", attr: { style: "font-weight:600; margin-top:4px;" } });

        const filterTreeBox = filterContainer.createEl("div", { attr: { style: "display:flex; flex-wrap:wrap; gap:8px 10px; align-items:flex-start; flex:1 1 100%; max-width:none;" } });

        // ÂÖ®ÈÉ®ÊåâÈíÆ
        const allBtn = filterTreeBox.createEl("button", {
            text: "ÂÖ®ÈÉ®",
            attr: {
                style: `
                    padding:6px 12px;
                    border-radius:6px;
                    border:1px solid var(--background-modifier-border);
                    cursor:pointer;
                    background:${(!window.timelineTagFilters || window.timelineTagFilters.length === 0) ? 'var(--interactive-accent)' : 'transparent'};
                    color:${(!window.timelineTagFilters || window.timelineTagFilters.length === 0) ? '#fff' : 'var(--text-normal)'};
                    font-size:12px;
                    font-weight:600;
                `
            }
        });
        allBtn.onclick = () => { window.timelineTagFilters = []; renderViewFn(); };

        const toggleFilter = (id) => {
            window.timelineTagFilters = window.timelineTagFilters || [];
            if (window.timelineTagFilters.includes(id)) {
                window.timelineTagFilters = window.timelineTagFilters.filter(t => t !== id);
            } else {
                window.timelineTagFilters.push(id);
            }
            renderViewFn();
        };

        // ÂµåÂ•óÂ±ÇÁ∫ßÊ†áÁ≠æÁ≠õÈÄâÂô®ÔºàÁà∂Ê†áÁ≠æÂ•óÂúàÂ≠êÊ†áÁ≠æ - Á¥ßÂáëÊ†∑ÂºèÔºâ
        const renderNestedTagFilter = (parentId, container) => {
            const children = sortTagIdsByName(getChildTags(parentId));
            if (children.length === 0) return;

            children.forEach(key => {
                const def = TAG_DEFINITIONS[key];
                if (!def) return;
                const isActive = (window.timelineTagFilters || []).includes(key);
                const subChildren = getChildTags(key);
                const hasSubChildren = subChildren.length > 0;

                if (hasSubChildren) {
                    // ÊúâÂ≠êÊ†áÁ≠æÁöÑÔºöÈááÁî®ÂàÜÁªÑÂÆπÂô®Ê†∑ÂºèÔºàÁà∂Ê†áÁ≠æÂ•óÂúàÂ≠êÊ†áÁ≠æÔºâ
                    const groupWrapper = container.createEl("div", {
                        attr: {
                            style: `
                                display: inline-flex;
                                flex-direction: column;
                                gap: 3px;
                                padding: 4px 6px;
                                border-radius: 8px;
                                background: var(--background-secondary);
                                border: 2px solid ${def.color}40;
                                margin: 3px;
                                vertical-align: top;
                            `
                        }
                    });

                    // Áà∂Ê†áÁ≠æÊ†áÈ¢òË°å
                    const headerRow = groupWrapper.createEl("div", {
                        attr: {
                            style: "display: flex; align-items: center; gap: 4px;"
                        }
                    });
                    const parentLabel = headerRow.createEl("span", {
                        text: `${def.icon} ${def.label}`,
                        attr: {
                            style: `
                                padding: 2px 6px;
                                border-radius: 10px;
                                cursor: pointer;
                                font-size: 11px;
                                font-weight: 700;
                                background: ${isActive ? def.color : 'transparent'};
                                color: ${isActive ? '#fff' : 'var(--text-normal)'};
                                border: 1px solid ${def.color}60;
                                transition: all 0.2s;
                            `
                        }
                    });
                    parentLabel.onclick = () => toggleFilter(key);

                    // Â≠êÊ†áÁ≠æÂÆπÂô®ÔºàÊñ∞Ë°åÊòæÁ§∫ÔºåÂ∏¶Â∑¶ËæπÁ∫øË°®Á§∫Â±ÇÁ∫ßÂÖ≥Á≥ªÔºâ
                    const childContainer = groupWrapper.createEl("div", {
                        attr: {
                            style: `
                                display: flex;
                                flex-wrap: wrap;
                                gap: 3px;
                                padding-left: 8px;
                                border-left: 2px solid ${def.color}50;
                                margin-top: 2px;
                            `
                        }
                    });
                    renderNestedTagFilter(key, childContainer);
                } else {
                    // Âè∂Â≠êÊ†áÁ≠æÔºöÊ∏≤Êüì‰∏∫Á¥ßÂáëËÉ∂ÂõäÊåâÈíÆ
                    const btn = container.createEl("button", {
                        text: `${def.icon} ${def.label}`,
                        attr: {
                            style: `
                                padding: 2px 6px;
                                border-radius: 12px;
                                border: 1px solid ${def.color}80;
                                cursor: pointer;
                                background: ${isActive ? def.color : 'transparent'};
                                color: ${isActive ? '#fff' : 'var(--text-normal)'};
                                font-size: 11px;
                                transition: all 0.2s;
                                margin: 2px;
                            `
                        }
                    });
                    btn.onclick = () => toggleFilter(key);
                }
            });
        };
        renderNestedTagFilter(null, filterTreeBox);

        // Â∑≤ÈÄâÊ†áÁ≠æÊòæÁ§∫
        const chipBox = filterContainer.createEl("div", { attr: { style: "display:flex; gap:6px; align-items:center; flex-wrap:wrap; margin-top:4px;" } });
        if (!window.timelineTagFilters || window.timelineTagFilters.length === 0) {
            chipBox.createEl("span", { text: "‚úì ÊòæÁ§∫ÂÖ®ÈÉ®", attr: { style: "color:var(--text-muted); font-size:12px;" } });
        } else {
            const clearBtn = chipBox.createEl("button", {
                text: "Ê∏ÖÁ©∫",
                attr: {
                    style: `
                        padding:4px 10px;
                        border-radius:4px;
                        border:1px solid var(--background-modifier-border);
                        cursor:pointer;
                        background:transparent;
                        color:var(--text-normal);
                        font-size:11px;
                    `
                }
            });
            clearBtn.onclick = () => { window.timelineTagFilters = []; renderViewFn(); };

            const activeChips = chipBox.createEl("div", { attr: { style: "display:flex; gap:4px; flex-wrap:wrap;" } });
            window.timelineTagFilters.forEach(id => {
                const def = TAG_DEFINITIONS[id];
                const chip = activeChips.createEl("span", {
                    text: def ? `${def.icon} ${def.label}` : id,
                    attr: {
                        style: `
                            padding:4px 8px;
                            border-radius:12px;
                            background:${def?.color || 'var(--background-modifier-border)'};
                            color:#fff;
                            cursor:pointer;
                            font-size:11px;
                        `
                    }
                });
                chip.onclick = () => toggleFilter(id);
            });
        }

        if (filteredData.length === 0) {
            const emptyText = data.length === 0
                ? "üì≠ ÊöÇÊó†‰∫ãÈ°πÔºåÁÇπÂáª [+ Ê∑ªÂä†‰∫ãÈ°π] ÂºÄÂßãËÆ∞ÂΩï"
                : (useViewRange ? "üì≠ ÂΩìÂâçËåÉÂõ¥ÊàñÁ≠õÈÄâ‰∏ãÊó†‰∫ãÈ°π" : "üì≠ ÂΩìÂâçÁ≠õÈÄâ‰∏ãÊó†‰∫ãÈ°π");
            container.createEl("div", {
                text: emptyText,
                attr: { style: "text-align:center; padding:40px; color:#999;" }
            });
            return;
        }

        // Mermaid ÂõæË°®ÂÆπÂô®
        const diagramContainer = container.createEl("div", { cls: "mermaid-gantt-container" });
        diagramContainer.style.position = "relative";
        diagramContainer.style.padding = "15px";
        diagramContainer.style.overflowX = "auto";
        diagramContainer.style.overflowY = "visible";
        diagramContainer.style.border = "1px solid var(--background-modifier-border)";
        diagramContainer.style.borderRadius = "8px";
        diagramContainer.style.margin = "10px";

        // ÁîüÊàê Mermaid ‰ª£Á†Å
        const config = MERMAID_CONFIG.zoom[window.timelineZoom] || MERMAID_CONFIG.zoom.week;
        let mermaidCode = generateMermaidGanttCode(data, config, activeRange, useViewRange);

        // ‰ΩøÁî® window.mermaid Ê∏≤Êüì
        if (window.mermaid) {
            try {
                window.mermaid.initialize({
                    startOnLoad: false,
                    theme: "default",
                    securityLevel: "loose",
                    gantt: {
                        axisFormat: config.axisFormat,
                        barHeight: 25,
                        barGap: 5,
                        sectionSize: config.sectionSize || 5
                    }
                });

                diagramContainer.innerHTML = `<div class="mermaid">${mermaidCode}</div>`;
                await window.mermaid.init(undefined, diagramContainer.querySelector(".mermaid"));

                // ÊÅ¢Â§çÁº©ÊîæÁä∂ÊÄÅ & ÁªëÂÆöÁÇπÂáªÁºñËæë
                setTimeout(() => {
                    const svgElement = diagramContainer.querySelector("svg");
                    if (svgElement) {
                        svgElement.style.transformOrigin = "top left";
                        if (window.timelineMermaidState && window.timelineMermaidState.zoom !== 1.0) {
                            svgElement.style.transform = `scale(${window.timelineMermaidState.zoom})`;
                        }
                        const findMermaidTaskToken = (targetEl) => {
                            let node = targetEl;
                            while (node && node !== svgElement) {
                                const id = node.id || "";
                                if (id.includes("task_") || id.includes("mile_")) return id;
                                if (node.getAttribute) {
                                    const dataId = node.getAttribute("data-task-id") || node.getAttribute("data-id") || node.getAttribute("data-task");
                                    if (dataId && (dataId.includes("task_") || dataId.includes("mile_"))) return dataId;
                                }
                                node = node.parentElement;
                            }
                            return null;
                        };

                        const normalizeTaskToken = (token, prefix) => {
                            if (!token) return null;
                            const match = token.match(new RegExp(`${prefix}[A-Za-z0-9]+`));
                            return match ? match[0].replace(prefix, "") : null;
                        };

                        svgElement.addEventListener("click", (evt) => {
                            const token = findMermaidTaskToken(evt.target);
                            if (!token) return;

                            const mileId = normalizeTaskToken(token, "mile_");
                            if (mileId) {
                                const milestone = getMilestoneById(mileId);
                                if (milestone) {
                                    const item = (timelineData.items || []).find(i => i.id === milestone.itemId);
                                    if (item) {
                                        openMilestoneModal(app, milestone, item, milestone.date, saveMilestone, deleteMilestone);
                                    } else {
                                        new Notice("‚ö†Ô∏è Êú™ÊâæÂà∞ÈáåÁ®ãÁ¢ëÂØπÂ∫îÁöÑ‰∫ãÈ°π");
                                    }
                                } else {
                                    new Notice("‚ö†Ô∏è Êú™ÊâæÂà∞ÈáåÁ®ãÁ¢ëÊï∞ÊçÆ");
                                }
                                return;
                            }

                            const taskId = normalizeTaskToken(token, "task_");
                            if (taskId) openEditModalById(taskId);
                        });

                        const clickableEls = svgElement.querySelectorAll('[id*="task_"], [id*="mile_"], .task');
                        clickableEls.forEach(el => { el.style.cursor = "pointer"; });
                    }
                    if (diagramContainer && window.timelineMermaidState) {
                        diagramContainer.scrollLeft = window.timelineMermaidState.scrollLeft || 0;
                        diagramContainer.scrollTop = window.timelineMermaidState.scrollTop || 0;
                    }
                }, 100);

            } catch (error) {
                diagramContainer.innerHTML = `<div style="color:red;padding:10px;">Ê∏≤ÊüìÂ§±Ë¥•: ${error.message}</div>`;
                // ËæìÂá∫‰ª£Á†ÅÁî®‰∫éË∞ÉËØï
                diagramContainer.innerHTML += `<pre style="background:#f5f5f5;padding:10px;margin-top:10px;overflow:auto;">${mermaidCode}</pre>`;
            }
        } else {
            diagramContainer.innerHTML = `<div style="color:orange;padding:10px;">‚ö†Ô∏è Mermaid Â∫ìÊú™Âä†ËΩΩÔºåÂ∞ÜÊòæÁ§∫‰ª£Á†Å</div>`;
            diagramContainer.innerHTML += `<pre style="background:#f5f5f5;padding:10px;margin-top:10px;overflow:auto;white-space:pre-wrap;">${mermaidCode}</pre>`;
        }

        // ‰øùÂ≠òÊªöÂä®Áä∂ÊÄÅ
        if (diagramContainer) {
            diagramContainer.addEventListener('scroll', () => {
                if (window.timelineMermaidState) {
                    window.timelineMermaidState.scrollLeft = diagramContainer.scrollLeft;
                    window.timelineMermaidState.scrollTop = diagramContainer.scrollTop;
                }
            });
        }

        // ‰ø°ÊÅØÊèêÁ§∫ÔºàÂê´ ISO Âë®Êï∞Ôºâ
        let rangeLabel = "‰∫ãÈ°πËåÉÂõ¥";
        let weekLabel = "";
        if (useViewRange) {
            const startWeek = activeRange.start.isoWeek();
            const endWeek = activeRange.end.isoWeek();
            const startYear = activeRange.start.isoWeekYear();
            const endYear = activeRange.end.isoWeekYear();
            weekLabel = startWeek === endWeek && startYear === endYear
                ? `W${String(startWeek).padStart(2,"0")} (${startYear})`
                : `W${String(startWeek).padStart(2,"0")} (${startYear}) ‚Üí W${String(endWeek).padStart(2,"0")} (${endYear})`;
            rangeLabel = `${activeRange.start.format("YYYY-MM-DD")} ~ ${activeRange.end.format("YYYY-MM-DD")} | Âë®Ê¨° ${weekLabel}`;
        }

        container.createEl("div", {
            text: `üìä ËåÉÂõ¥ ${rangeLabel} | ÊòæÁ§∫ ${filteredData.length} ‰∏™‰∫ãÈ°π | ÁÇπÂáªÊù°ÂΩ¢ÂèØÁºñËæë`,
            attr: { style: "padding:10px 15px; color:var(--text-muted); font-size:0.9em;" }
        });
    };

    // ===== 6. ÊúàÂéÜËßÜÂõæ =====

    const renderCalendarView = (container, data) => {
        container.empty();

        const currentMonth = window.timelineCurrentMonth || moment();
        const monthStart = currentMonth.clone().startOf('month');
        const monthEnd = currentMonth.clone().endOf('month');

        // Â∫îÁî®Ê†áÁ≠æÁ≠õÈÄâ
        let filteredData = data.filter(item =>
            tagMatchesFilter(item.tags, window.timelineTagFilters)
        );
        if (window.timelineDayblockOnlyScheduled) {
            filteredData = filteredData.filter(item =>
                itemHasScheduledInRange(item, monthStart, monthEnd)
            );
        }

        const itemMap = new Map(filteredData.map(item => [item.id, item]));
        const milestones = Object.values(timelineData.milestones || {})
            .filter(m => {
                if (!m?.date) return false;
                if (!moment(m.date).isBetween(monthStart, monthEnd, "day", "[]")) return false;
                return itemMap.has(m.itemId);
            });
        const milestonesByDate = {};
        milestones.forEach(m => {
            if (!milestonesByDate[m.date]) milestonesByDate[m.date] = [];
            milestonesByDate[m.date].push(m);
        });
        Object.keys(milestonesByDate).forEach(d => {
            milestonesByDate[d].sort((a, b) => (a.name || "").localeCompare(b.name || ""));
        });

        const headerDiv = container.createEl("div", {
            attr: { style: "display:flex; justify-content:center; align-items:center; padding:20px; gap:20px;" }
        });

        headerDiv.createEl("button", { text: "‚óÄ ‰∏äÊúà", cls: "mod-cta" }).onclick = () => {
            window.timelineCurrentMonth = currentMonth.clone().subtract(1, 'month');
            renderViewFn();
        };

        headerDiv.createEl("h2", { text: currentMonth.format("YYYYÂπ¥ MMÊúà") });

        headerDiv.createEl("button", { text: "‰∏ãÊúà ‚ñ∂", cls: "mod-cta" }).onclick = () => {
            window.timelineCurrentMonth = currentMonth.clone().add(1, 'month');
            renderViewFn();
        };

        const calendarDiv = container.createEl("div", {
            attr: { style: "display:grid; grid-template-columns:repeat(7, 1fr); gap:5px; padding:20px;" }
        });

        ["Êó•", "‰∏Ä", "‰∫å", "‰∏â", "Âõõ", "‰∫î", "ÂÖ≠"].forEach(day => {
            calendarDiv.createEl("div", {
                text: day,
                attr: { style: "text-align:center; font-weight:bold; padding:10px; background:#f0f0f0;" }
            });
        });

        const firstDay = monthStart.clone();
        const lastDay = monthEnd.clone();
        const startWeekday = firstDay.day();

        for (let i = 0; i < startWeekday; i++) {
            calendarDiv.createEl("div", { attr: { style: "background:#fafafa; min-height:100px;" } });
        }

        let currentDate = firstDay.clone();
        while (currentDate.isSameOrBefore(lastDay, 'day')) {
            const dateStr = currentDate.format('YYYY-MM-DD');
            const isToday = dateStr === moment().format('YYYY-MM-DD');

            const dayDiv = calendarDiv.createEl("div", {
                attr: {
                    style: `border:1px solid #ddd; min-height:100px; padding:5px; background:${isToday ? '#e8f4fc' : '#fff'};`
                }
            });

            dayDiv.createEl("div", {
                text: currentDate.format('D'),
                attr: { style: `font-weight:bold; margin-bottom:5px; color:${isToday ? '#3498db' : '#333'};` }
            });

            const dayMilestones = milestonesByDate[dateStr] || [];
            dayMilestones.forEach(m => {
                const item = itemMap.get(m.itemId);
                if (!item) return;
                const isDone = !!m.completed;
                const label = m.name || "ÈáåÁ®ãÁ¢ë";
                const itemDiv = dayDiv.createEl("div", {
                    text: `üéØ ${label}`,
                    attr: {
                        style: `
                            background:${item.color};
                            color:#fff;
                            padding:2px 5px;
                            margin:2px 0;
                            border-radius:3px;
                            font-size:11px;
                            overflow:hidden;
                            text-overflow:ellipsis;
                            white-space:nowrap;
                            opacity:${isDone ? 0.6 : 1};
                            text-decoration:${isDone ? 'line-through' : 'none'};
                            cursor:pointer;
                        `,
                        title: `${item.name}\n${label}\n${m.date}${isDone ? " (Â∑≤ÂÆåÊàê)" : ""}`
                    }
                });
                itemDiv.onclick = () => {
                    openMilestoneModal(app, m, item, m.date, saveMilestone, deleteMilestone);
                };
            });

            currentDate.add(1, 'day');
        }
    };

    // ===== 7.1 Êó•ÂùóÁü©ÈòµËßÜÂõæ =====

    const setBlockForItemOnDate = async (itemId, dateStr, blockId) => {
        await updateData((data) => {
            const idx = (data.items || []).findIndex(i => i.id === itemId);
            if (idx === -1) return;
            const item = data.items[idx];
            ensureDaySlots(item);
            if (!blockId) delete item.daySlots[dateStr];
            else item.daySlots[dateStr] = blockId;
        });
    };

    const renderDayBlockMatrix = (container, data) => {
        container.empty();
        const activeRange = getActiveRange();
        const dates = [];
        const cursor = activeRange.start.clone();
        while (cursor.isSameOrBefore(activeRange.end, "day")) {
            dates.push(cursor.format("YYYY-MM-DD"));
            cursor.add(1, "day");
        }

        // Â∫îÁî®Ê†áÁ≠æÁ≠õÈÄâ
        let filteredData = data.filter(item =>
            tagMatchesFilter(item.tags, window.timelineTagFilters)
        );
        const scheduledOnly = !!window.timelineDayblockOnlyScheduled;
        if (scheduledOnly) {
            filteredData = filteredData.filter(item =>
                itemHasScheduledInRange(item, activeRange.start, activeRange.end)
            );
        }

        // ËÆ°ÁÆó‚ÄúÊØèÊó•È°∫Â∫è‚ÄùÁî®‰∫éÊú™ÂàÜÈÖçÁªßÊâø
        const dailyOrderMap = buildDailyOrderMap(dates, filteredData);

        const table = container.createEl("table", { attr: { style: "width:100%; border-collapse:collapse; font-size:13px; table-layout:fixed;" } });
        const thead = table.createEl("thead");
        const headRow = thead.createEl("tr");
        headRow.createEl("th", { text: "Êó∂Èó¥Âùó", attr: { style: "position:sticky; left:0; background:var(--background-secondary); z-index:2; padding:8px; border:1px solid var(--background-modifier-border); width:100px;" } });
        dates.forEach(d => {
            const dateObj = moment(d);
            headRow.createEl("th", {
                text: `${dateObj.format("MM/DD")}\n(${getDayName(d)})`,
                attr: { style: "padding:8px; border:1px solid var(--background-modifier-border); white-space:pre; text-align:center; font-size:12px; min-width:70px;" }
            });
        });

        const tbody = table.createEl("tbody");

        const renderCellItems = (cell, dateStr, blockId) => {
            const items = filteredData.filter(item => {
                const s = moment(item.startDate);
                const e = moment(item.endDate);
                if (!e.isSameOrAfter(dateStr, "day") || !s.isSameOrBefore(dateStr, "day")) return false;
                const slotId = (item.daySlots || {})[dateStr] || null;
                if (blockId === "__unassigned") return slotId === null;
                return slotId === blockId;
            });
            // ‰æùÊçÆÊØèÊó•ÁªßÊâøÈ°∫Â∫èÊéíÂ∫èÔºõËã•Êó†ËÆ∞ÂΩïÂàôÂõûÈÄÄÂà∞ÂêçÁß∞
            const dayOrder = dailyOrderMap[dateStr] || [];
            items.sort((a, b) => {
                const ai = dayOrder.indexOf(a.id);
                const bi = dayOrder.indexOf(b.id);
                if (ai !== -1 && bi !== -1) return ai - bi;
                if (ai !== -1) return -1;
                if (bi !== -1) return 1;
                return (a.name || "").localeCompare(b.name || "");
            });

            if (items.length === 0) {
                cell.createEl("div", { text: "‚Äî", attr: { style: "color:var(--text-muted);" } });
                return;
            }

            items.forEach(it => {
                // Ëé∑ÂèñËØ•‰∫ãÈ°πÂú®ËØ•Êó•ÊúüÁöÑÈáåÁ®ãÁ¢ë
                const dailyMilestones = getMilestonesForItemDate(it.id, dateStr);
                const hasDailyMilestones = dailyMilestones.length > 0;

                // Ëé∑ÂèñËØ•‰∫ãÈ°πÁöÑÊâÄÊúâÈáåÁ®ãÁ¢ëÊÄªÊï∞ÔºàÊó†ËÆ∫Êó•ÊúüÂíåÊòØÂê¶Âú®ÂΩìÂâçËßÜÂõæÔºâ
                const allMilestones = getMilestonesForItem(it.id);
                const totalMilestones = allMilestones.length;
                const completedTotalMilestones = allMilestones.filter(m => m.completed).length;
                const pendingTotalMilestones = totalMilestones - completedTotalMilestones;

                // Ê£ÄÊü•ÈáåÁ®ãÁ¢ëÊÄªÊï∞
                let milestoneBadge = '';
                if (totalMilestones > 0) {
                    milestoneBadge = `
                        <span style="
                            display:inline-flex;
                            align-items:center;
                            gap:2px;
                            margin-left:4px;
                            padding:1px 4px;
                            background:${allMilestones.every(m => m.completed) ? '#27ae60' : '#e67e22'};
                            border-radius:8px;
                            font-size:9px;
                            color:#fff;
                            font-weight:bold;
                        ">${pendingTotalMilestones}/${totalMilestones} ‚óâ</span>
                    `;
                }

                const pill = cell.createEl("div", {
                    attr: {
                        style: `
                            background:${it.color};
                            color:#fff;
                            padding:4px 6px;
                            border-radius:6px;
                            margin:2px 0;
                            cursor:pointer;
                            font-weight:600;
                            white-space:nowrap;
                            overflow:hidden;
                            text-overflow:ellipsis;
                            display:flex;
                            align-items:center;
                        `,
                        title: `${it.name}\n${it.startDate}~${it.endDate}${hasDailyMilestones ? `\n${pendingTotalMilestones}/${totalMilestones} ‰∏™ÈáåÁ®ãÁ¢ë` : ''}`
                    }
                });

                // ‰∫ãÈ°πÂêçÁß∞
                const nameSpan = pill.createEl("span", { text: it.name });
                nameSpan.style.flex = "1";
                nameSpan.style.overflow = "hidden";
                nameSpan.style.textOverflow = "ellipsis";

                // ÈáåÁ®ãÁ¢ëÂæΩÁ´†ÔºàÊÄªÊï∞Ôºâ
                if (totalMilestones > 0) {
                    pill.innerHTML += milestoneBadge;
                }

                // ÊàòÊ£ãÈ£éÊ†ºÈáåÁ®ãÁ¢ëÊòæÁ§∫Ë°åÔºàÁã¨Á´ã‰∏ÄË°åÔºåÈáëËâ≤Â§ñÊ°ÜÔºâ
                if (hasDailyMilestones) {
                    dailyMilestones.forEach(m => {
                        // ËÆ°ÁÆóÈáåÁ®ãÁ¢ëË°åÁöÑÊ†∑Âºè
                        const rowStyle = `
                            margin-top: 3px;
                            padding: 4px 6px;
                            border: 2px solid #FFD700;
                            border-radius: 6px;
                            background: ${it.color}40;
                            cursor: pointer;
                            font-size: 11px;
                            display: flex;
                            align-items: center;
                            gap: 4px;
                            opacity: ${m.completed ? 0.6 : 1};
                            line-height: 1.4;
                            min-height: 20px;
                        `;

                        const mileRow = cell.createEl("div", {
                            attr: {
                                style: rowStyle,
                                title: `ÁÇπÂáªÁºñËæëÈáåÁ®ãÁ¢ë: ${m.name}`
                            }
                        });
                        mileRow.createEl("span", {
                            text: m.completed ? "‚úÖ" : "üî≤",
                            attr: { style: "font-size:10px; flex-shrink:0;" }
                        });

                        // Â∑≤ÂÆåÊàêÈáåÁ®ãÁ¢ëÊ∑ªÂä†ÂàíÁ∫øÊïàÊûúÔºåÁßªÈô§ÊñáÂ≠óÁúÅÁï•ÈôêÂà∂ÔºåÊòæÁ§∫ÂÆåÊï¥ÊñáÂ≠ó
                        const textStyle = `
                            color: ${it.color};
                            font-weight: 600;
                            text-decoration: ${m.completed ? 'line-through' : 'none'};
                            white-space: normal;
                            word-break: break-all;
                            line-height: 1.3;
                        `;

                        const mileText = mileRow.createEl("span", {
                            text: m.name,
                            attr: { style: textStyle }
                        });
                        mileRow.onclick = () => {
                            openMilestoneModal(app, m, it, dateStr, saveMilestone, deleteMilestone);
                        };
                    });
                }

                pill.onclick = async () => {
                    // ÂºπÂá∫Êìç‰ΩúÈÄâÊã©ËèúÂçïÔºàÁÇπÈÄâÔºâ
                    const action = await pickActionOnce(it.name);

                    if (action === null) return;

                    if (action === 'milestone') {
                        // ÊâìÂºÄÈáåÁ®ãÁ¢ëÂºπÁ™ó
                        openMilestoneModal(app, null, it, dateStr, saveMilestone, deleteMilestone);
                    } else if (action === 'detail') {
                        // Êü•ÁúãËØ¶ÊÉÖ - ÊâìÂºÄÁºñËæëÂºπÁ™ó
                        openEditModalById(it.id);
                    } else if (action === 'timeblock') {
                        // ËÆæÁΩÆÊó∂Èó¥ÂùóÔºàÁÇπÈÄâÔºâ
                        const currentBlockId = (it.daySlots || {})[dateStr] || null;
                        const blockId = await pickTimeBlockOnce(currentBlockId);
                        if (blockId !== undefined) { // null Ë°®Á§∫Ê∏ÖÈô§
                            await setBlockForItemOnDate(it.id, dateStr, blockId);
                        }
                    }
                };
            });
        };

        // Ê∏≤ÊüìÊó∂Èó¥ÂùóË°å
        TIME_BLOCKS.forEach(block => {
            const row = tbody.createEl("tr");
            row.createEl("td", {
                text: `${block.label}\n${block.range}`,
                attr: {
                    style: "position:sticky; left:0; background:var(--background-secondary); z-index:1; padding:8px; border:1px solid var(--background-modifier-border); white-space:pre;"
                }
            });
            dates.forEach(d => {
                const cell = row.createEl("td", { attr: { style: "vertical-align:top; padding:6px; border:1px solid var(--background-modifier-border);" } });
                renderCellItems(cell, d, block.id);
            });
        });

        // Êú™ÂàÜÈÖçË°å
        if (!scheduledOnly) {
            const unRow = tbody.createEl("tr");
            unRow.createEl("td", {
                text: "Êú™ÂàÜÈÖç\n(ÁÇπÂáªÊù°ÁõÆËÆæÂÆöÂùó)",
                attr: { style: "position:sticky; left:0; background:var(--background-secondary); z-index:1; padding:8px; border:1px solid var(--background-modifier-border); white-space:pre; color:var(--text-muted);" }
            });
            dates.forEach(d => {
                const cell = unRow.createEl("td", { attr: { style: "vertical-align:top; padding:6px; border:1px solid var(--background-modifier-border);" } });
                renderCellItems(cell, d, "__unassigned");
            });
        }
    };

    // ===== 6.5 Ê≥¢ÂΩ¢ÂõæËßÜÂõæ =====
    const renderWaveView = (container, data) => {
        container.empty();
        const activeRange = getActiveRange();

        // ËøáÊª§ + Êó•ÊúüÂàóË°®
        const filteredItems = data.filter(item => {
            if (!tagMatchesFilter(item.tags, window.timelineTagFilters)) return false;
            if (window.timelineDayblockOnlyScheduled && !itemHasScheduledInRange(item, activeRange.start, activeRange.end)) return false;
            const s = moment(item.startDate);
            const e = moment(item.endDate);
            return e.isSameOrAfter(activeRange.start, "day") && s.isSameOrBefore(activeRange.end, "day");
        });

        if (filteredItems.length === 0) {
            container.createEl("div", {
                text: data.length === 0 ? "üì≠ ÊöÇÊó†‰∫ãÈ°πÔºåÁÇπÂáª [+ Ê∑ªÂä†‰∫ãÈ°π] ÂºÄÂßãËÆ∞ÂΩï" : `üì≠ ÂΩìÂâçËåÉÂõ¥ÊàñÁ≠õÈÄâ‰∏ãÊó†‰∫ãÈ°π`,
                attr: { style: "text-align:center; padding:40px; color:#999;" }
            });
            return;
        }

        const dates = [];
        const cursor = activeRange.start.clone();
        while (cursor.isSameOrBefore(activeRange.end, "day")) {
            dates.push(cursor.format("YYYY-MM-DD"));
            cursor.add(1, "day");
        }

        // ËÆ°ÁÆóÊØèÊó•ÈªòËÆ§È°∫Â∫èÔºöÊú™ÂàÜÈÖçÁªßÊâøÊò®Êó•ÔºåÂ∑≤ÊéíÂùó‰ºòÂÖà
        const dailyOrderMap = buildDailyOrderMap(dates, filteredItems);

        const perDay = {};
        dates.forEach(d => {
            perDay[d] = filteredItems
                .filter(item => moment(d).isBetween(item.startDate, item.endDate, "day", "[]"))
                .sort((a, b) => {
                    const dayOrder = dailyOrderMap[d] || [];
                    const aiOrder = dayOrder.indexOf(a.id);
                    const biOrder = dayOrder.indexOf(b.id);
                    if (aiOrder !== -1 && biOrder !== -1) return aiOrder - biOrder;
                    if (aiOrder !== -1) return -1;
                    if (biOrder !== -1) return 1;
                    const ai = blockIndex(a, d);
                    const bi = blockIndex(b, d);
                    if (ai !== bi) return ai - bi;
                    return (a.name || "").localeCompare(b.name || "");
                });
        });

        const maxRows = Math.max(...dates.map(d => perDay[d].length));
        const rowHeight = 38;
        const colWidth = 90;
        const leftMargin = 110;
        const topMargin = 10;
        const widthPx = leftMargin + dates.length * colWidth + 40;
        const heightPx = topMargin + maxRows * rowHeight + 40;

        const waveContainer = container.createEl("div", {
            attr: { style: "overflow:auto; padding:10px; position:relative;" }
        });

        // Headers
        const headerHeight = 26;
        const headerRow = waveContainer.createEl("div", { attr: { style: `display:flex; margin-left:${leftMargin}px; gap:0; height:${headerHeight}px;` } });
        dates.forEach(d => {
            const isToday = d === moment().format("YYYY-MM-DD");
            headerRow.createEl("div", {
                text: `${moment(d).format("MM/DD")} ${getDayName(d)}`,
                attr: {
                    style: `
                        width:${colWidth}px;
                        text-align:center;
                        font-size:11px;
                        color:${isToday ? 'var(--interactive-accent)' : 'var(--text-muted)'};
                        font-weight:${isToday ? 700 : 500};
                        border-left:1px solid var(--background-modifier-border);
                        padding:4px 0;
                    `
                }
            });
        });

        // ÂÜÖÂÆπÂåÖË£πÂ±ÇÔºåÁªü‰∏ÄÂÅèÁßªÔºåÂÜÖÈÉ®ÂØπÈΩê
        const waveWrap = waveContainer.createEl("div", {
            attr: { style: `position:relative; margin-top:${headerHeight + 4}px; width:${widthPx}px; height:${heightPx}px;` }
        });

        // Canvas layer for linesÔºà‰∏äÂ±Ç„ÄÅÂÖçÈÅÆÊå°Ôºâ
        const canvas = waveWrap.createEl("canvas");
        canvas.width = widthPx * 2;  // high DPI
        canvas.height = heightPx * 2;
        canvas.style.width = `${widthPx}px`;
        canvas.style.height = `${heightPx}px`;
        canvas.style.position = "absolute";
        canvas.style.left = "0";
        canvas.style.top = "0";
        canvas.style.pointerEvents = "none";
        canvas.style.zIndex = 2;
        const ctx = canvas.getContext("2d");
        ctx.scale(2, 2);

        // Bars layerÔºà‰∏ãÂ±ÇÔºâ
        const barsLayer = waveWrap.createEl("div", {
            attr: {
                style: `position:relative; width:${widthPx}px; height:${heightPx}px; z-index:1;`
            }
        });

        // y reference grid
        for (let r = 0; r < maxRows; r++) {
            const line = barsLayer.createEl("div", {
                attr: {
                    style: `
                        position:absolute;
                        left:${leftMargin}px;
                        right:0;
                        top:${topMargin + r * rowHeight}px;
                        height:0;
                        border-top:1px dashed var(--background-modifier-border);
                        pointer-events:none;
                    `
                }
            });
        }

        // store centers per item for polyline
        const centersByItem = {};

        dates.forEach((d, colIdx) => {
            const dayItems = perDay[d];
            dayItems.forEach((item, rowIdx) => {
                const top = topMargin + rowIdx * rowHeight;
                const left = leftMargin + colIdx * colWidth;
                const height = rowHeight - 6;
                const width = colWidth - 12;

                const card = barsLayer.createEl("div", {
                    attr: {
                        style: `
                            position:absolute;
                            left:${left}px;
                            top:${top}px;
                            width:${width}px;
                            height:${height}px;
                            background:${item.color};
                            border-radius:6px;
                            padding:4px 6px;
                            color:#fff;
                            font-size:11px;
                            font-weight:600;
                            overflow:hidden;
                            text-overflow:ellipsis;
                            white-space:nowrap;
                            cursor:pointer;
                            box-shadow:0 1px 4px rgba(0,0,0,0.15);
                        `,
                        title: `${item.name}\n${d} ‚Ä¢ ${getBlockById((item.daySlots||{})[d])?.label || 'Êú™ÂàÜÈÖç'}`
                    },
                    text: item.name
                });
                card.onclick = () => openEditModalById(item.id);

                const center = {
                    x: left + width / 2,
                    y: top + height / 2
                };
                if (!centersByItem[item.id]) centersByItem[item.id] = [];
                centersByItem[item.id].push({ date: d, ...center });
            });
        });

        // draw polylines per item (sorted by date)
        Object.keys(centersByItem).forEach(id => {
            const pts = centersByItem[id].sort((a, b) => a.date.localeCompare(b.date));
            if (pts.length < 2) return;
            ctx.strokeStyle = filteredItems.find(i => i.id === id)?.color || "#999";
            ctx.lineWidth = 2;
            ctx.beginPath();
            pts.forEach((p, idx) => {
                if (idx === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
        });

        // legend
        const legend = container.createEl("div", {
            attr: {
                style: "margin-top:12px; padding:10px; background:var(--background-secondary); border-radius:8px; font-size:12px; color:var(--text-muted);"
            }
        });
        legend.innerHTML = `
            <strong>üìà Ê≥¢ÂΩ¢Âõæ</strong>ÔºöÊåâÊó•ÂùóÈ°∫Â∫èËá™‰∏äËÄå‰∏ãÂ†ÜÂè†ÔºåÊØèÂ§©ÈΩêÂπ≥Ëµ∑ÂßãÔºõÂêå‰∫ãÈ°πË∑®Êó•ËøûÁ∫øÂΩ¢ÊàêÊ≥¢ÂΩ¢„ÄÇÁÇπÂáªÂç°ÁâáÂèØÁºñËæë„ÄÇ`;
    };

    // ===== 7. ÂäüËÉΩÂáΩÊï∞ =====

    const addItem = async () => {
        const name = await prompt("‰∫ãÈ°πÂêçÁß∞", "‰æãÂ¶ÇÔºöÂÆåÊàêÈ°πÁõÆÊä•Âëä");
        if (!name) return;

        const startDate = await prompt("ÂºÄÂßãÊó•Êúü", "YYYY-MM-DD", moment().format("YYYY-MM-DD"));
        if (!startDate) return;

        const endDate = await prompt("ÁªìÊùüÊó•Êúü", "YYYY-MM-DD", moment().add(7, 'days').format("YYYY-MM-DD"));
        if (!endDate) return;

        const comment = await prompt("Â§áÊ≥®ÔºàÂèØÈÄâÔºâ", "ËÆ∞ÂΩï‰∏Ä‰∫õËØ¥Êòé...", "");

        // Â§öÈÄâÊ†áÁ≠æ
        const selectedTags = await pickTagsOnce([]);
        if (selectedTags === null) return;

        const existingColors = (timelineData.items || []).map(item => item.color);
        const color = getColorForItem(name, existingColors);

        await updateData((data) => {
            data.items = data.items || [];
            data.items.push({
                id: generateId(),
                name: name,
                startDate: startDate,
                endDate: endDate,
                comment: comment || "",
                color: color,
                tags: selectedTags,
                daySlots: {},
                created: moment().format("YYYY-MM-DD HH:mm:ss")
            });
        });

        new Notice("‚úÖ ‰∫ãÈ°πÂ∑≤Ê∑ªÂä†");
    };

    const addItemWithDate = async (defaultDate) => {
        const name = await prompt("‰∫ãÈ°πÂêçÁß∞", "‰æãÂ¶ÇÔºöÂÆåÊàêÈ°πÁõÆÊä•Âëä");
        if (!name) return;

        const startDate = await prompt("ÂºÄÂßãÊó•Êúü", "YYYY-MM-DD", defaultDate);
        if (!startDate) return;

        const endDate = await prompt("ÁªìÊùüÊó•Êúü", "YYYY-MM-DD", moment(defaultDate).add(1, 'days').format("YYYY-MM-DD"));
        if (!endDate) return;

        const comment = await prompt("Â§áÊ≥®ÔºàÂèØÈÄâÔºâ", "ËÆ∞ÂΩï‰∏Ä‰∫õËØ¥Êòé...", "");

        const selectedTags = await pickTagsOnce([]);
        if (selectedTags === null) return;

        const existingColors = (timelineData.items || []).map(item => item.color);
        const color = getColorForItem(name, existingColors);

        await updateData((data) => {
            data.items = data.items || [];
            data.items.push({
                id: generateId(),
                name: name,
                startDate: startDate,
                endDate: endDate,
                comment: comment || "",
                color: color,
                tags: selectedTags,
                daySlots: {},
                created: moment().format("YYYY-MM-DD HH:mm:ss")
            });
        });

        new Notice("‚úÖ ‰∫ãÈ°πÂ∑≤Ê∑ªÂä†");
    };

    const editItem = async (index) => {
        const item = (timelineData.items || [])[index];
        if (!item) return;

        const name = await prompt("‰∫ãÈ°πÂêçÁß∞", "‰øÆÊîπÂêçÁß∞", item.name);
        if (!name) return;

        const startDate = await prompt("ÂºÄÂßãÊó•Êúü", "YYYY-MM-DD", item.startDate);
        if (!startDate) return;

        const endDate = await prompt("ÁªìÊùüÊó•Êúü", "YYYY-MM-DD", item.endDate);
        if (!endDate) return;

        const comment = await prompt("Â§áÊ≥®", "‰øÆÊîπÂ§áÊ≥®", item.comment || "");

        const selectedTags = await pickTagsOnce([...(item.tags || [])]);
        if (selectedTags === null) return;

        await updateData((data) => {
            if (!data.items || !data.items[index]) return;
            data.items[index].name = name;
            data.items[index].startDate = startDate;
            data.items[index].endDate = endDate;
            data.items[index].comment = comment;
            data.items[index].tags = selectedTags;
            ensureDaySlots(data.items[index]);
        });

        new Notice("‚úÖ ‰∫ãÈ°πÂ∑≤Êõ¥Êñ∞");
    };

    const switchViewMode = (mode) => {
        window.timelineViewMode = mode;
        renderViewFn();
    };

    const openEditModalById = (itemId) => {
        const idx = (timelineData.items || []).findIndex(i => i.id === itemId);
        if (idx === -1) { new Notice("Êú™ÊâæÂà∞ËØ•‰∫ãÈ°π"); return; }
        const item = timelineData.items[idx];
        new ItemEditModal(app, item, async (updated) => {
            await updateData((data) => {
                const realIdx = (data.items || []).findIndex(i => i.id === itemId);
                if (realIdx === -1) return;
                if (updated.__delete) {
                    data.items.splice(realIdx, 1);
                    return;
                }
                data.items[realIdx] = { ...data.items[realIdx], ...updated };
                ensureDaySlots(data.items[realIdx]);
            });
            new Notice(updated.__delete ? "üóëÔ∏è ‰∫ãÈ°πÂ∑≤Âà†Èô§" : "‚úÖ ‰∫ãÈ°πÂ∑≤Êõ¥Êñ∞");
        }).open();
    };

    // ===== 8. ‰∏ªÊ∏≤ÊüìÂáΩÊï∞ =====

    let renderViewFn = null;

    const renderMainView = () => {
        const mainContainer = dv.container;
        mainContainer.empty();

        const titleDiv = mainContainer.createEl("div", {
            attr: {
                style: "display:flex; justify-content:space-between; align-items:center; padding:20px; border-bottom:2px solid var(--interactive-accent);"
            }
        });

        titleDiv.createEl("h1", { text: "üóìÔ∏è Timeline Êó∂Èó¥Á∫øËßÜÂõæ (MermaidÁâà)" });

        const controlsDiv = titleDiv.createEl("div", { attr: { style: "display:flex; gap:10px;" } });

        // ËßÜÂõæÂàáÊç¢
        const ganttBtn = controlsDiv.createEl("button", {
            text: "üìä GanttÂõæ",
            cls: window.timelineViewMode === "gantt" ? "mod-cta" : ""
        });
        ganttBtn.addEventListener("click", () => switchViewMode("gantt"));

        const calendarBtn = controlsDiv.createEl("button", {
            text: "üìÖ ÊúàÂéÜ",
            cls: window.timelineViewMode === "calendar" ? "mod-cta" : ""
        });
        calendarBtn.addEventListener("click", () => switchViewMode("calendar"));

        const dayBlockBtn = controlsDiv.createEl("button", {
            text: "üß≠ Êó•ÂùóÁü©Èòµ",
            cls: window.timelineViewMode === "dayblock" ? "mod-cta" : ""
        });
        dayBlockBtn.addEventListener("click", () => switchViewMode("dayblock"));

        const waveBtn = controlsDiv.createEl("button", {
            text: "üåä Ê≥¢ÂΩ¢Âõæ",
            cls: window.timelineViewMode === "wave" ? "mod-cta" : ""
        });
        waveBtn.addEventListener("click", () => switchViewMode("wave"));

        const scheduledBtn = controlsDiv.createEl("button", {
            text: "‰ªÖÂ∑≤ÊéíÂùó",
            cls: window.timelineDayblockOnlyScheduled ? "mod-cta" : "",
            attr: { title: "‰ªÖÊòæÁ§∫Âú®ÂΩìÂâçËåÉÂõ¥ÂÜÖÂ∑≤ÂÆâÊéíÊó∂Èó¥ÂùóÁöÑ‰∫ãÈ°π" }
        });
        scheduledBtn.addEventListener("click", () => {
            window.timelineDayblockOnlyScheduled = !window.timelineDayblockOnlyScheduled;
            renderViewFn();
        });

        // Ê†áÁ≠æÁÆ°ÁêÜ
        const tagMgrBtn = controlsDiv.createEl("button", {
            text: "üè∑Ô∏è Ê†áÁ≠æÁÆ°ÁêÜ",
            cls: window.timelineTagManagerMode ? "mod-cta" : ""
        });
        tagMgrBtn.addEventListener("click", () => {
            window.timelineTagManagerMode = !window.timelineTagManagerMode;
            renderViewFn();
        });

        // Ê∑ªÂä†‰∫ãÈ°π
        const addBtn = controlsDiv.createEl("button", { text: "+ Ê∑ªÂä†‰∫ãÈ°π", cls: "mod-cta" });
        addBtn.addEventListener("click", addItem);

        // ÂÜÖÂÆπÂå∫
        const contentDiv = mainContainer.createEl("div", { attr: { style: "padding:20px;" } });

        if (window.timelineTagManagerMode) {
            renderTagManagerView(contentDiv);
        } else if (window.timelineViewMode === "gantt") {
            renderMermaidGantt(contentDiv, timelineData.items || []);
        } else if (window.timelineViewMode === "calendar") {
            renderCalendarView(contentDiv, timelineData.items || []);
        } else if (window.timelineViewMode === "dayblock") {
            renderDayBlockMatrix(contentDiv, timelineData.items || []);
        } else if (window.timelineViewMode === "wave") {
            renderWaveView(contentDiv, timelineData.items || []);
        }
    };

    renderViewFn = renderMainView;
    renderMainView();

})();
```
