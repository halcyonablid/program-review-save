```dataviewjs
// ============================================================
// ğŸš€ GTD ç®¡ç†ç³»ç»Ÿ (v19.0 Timelineå®Œæˆè®°å½•ç‰ˆ)
// æ–°å¢ï¼šå®Œæˆäº‹é¡¹å¼¹çª—è®°å½• + Timelineæ—¶é—´è½´è§†å›¾
// ç‰¹æ€§ï¼šå®Œæˆä»»åŠ¡æ—¶è®°å½•è¯„è¯­ï¼Œè‡ªåŠ¨è¿½è¸ªé¡¹ç›®å±‚çº§ä¸æ ‡ç­¾
// ====================================

(async () => {

    // --- 0. æ ‡ç­¾æ•°æ®æ–‡ä»¶ç®¡ç† ---
    const JSON_FILENAME = "GTD_Database.json";
    const TAGS_FILENAME = "GTD_Tags.json";
    const TIMELINE_FILENAME = "GTD_Timeline.json";  // æ–°å¢ï¼šæ—¶é—´è½´æ—¥å¿—æ–‡ä»¶
    const currentFolder = dv.current().file.folder;
    const DB_PATH = currentFolder + "/" + JSON_FILENAME;
    const TAGS_PATH = currentFolder + "/" + TAGS_FILENAME;
    const TIMELINE_PATH = currentFolder + "/" + TIMELINE_FILENAME;

    // é»˜è®¤æ ‡ç­¾å®šä¹‰ï¼ˆé¦–æ¬¡ä½¿ç”¨æˆ–æ–‡ä»¶ä¸å­˜åœ¨æ—¶ï¼‰
    const DEFAULT_TAG_DEFINITIONS = {
        "work-type":     { label: "å·¥ä½œç±»å‹", icon: "ğŸ“‹", color: "#7f8c8d", parentId: null, isCategory: true, order: 0 },
        "system":        { label: "æ¶æ„è®¾è®¡", icon: "ğŸ—ï¸", color: "#9b59b6", parentId: "work-type", isCategory: false, order: 0 },
        "learning":      { label: "å­¦ä¹ é’»ç ”", icon: "ğŸ“š", color: "#3498db", parentId: "work-type", isCategory: false, order: 1 },
        "review":        { label: "å¤ç›˜æ²‰æ·€", icon: "ğŸ’¡", color: "#f1c40f", parentId: "work-type", isCategory: false, order: 2 },
        "urgent":        { label: "ç´§æ€¥æ•‘ç«", icon: "ğŸ”¥", color: "#e74c3c", parentId: "work-type", isCategory: false, order: 3 },
        "waiting":       { label: "å¤–éƒ¨ç­‰å¾…", icon: "â³", color: "#95a5a6", parentId: "work-type", isCategory: false, order: 4 },
        "domain":        { label: "èƒ½åŠ›åŸŸ", icon: "ğŸ¯", color: "#2c3e50", parentId: null, isCategory: true, order: 1 },
        "tech":          { label: "æŠ€æœ¯èƒ½åŠ›", icon: "âš™ï¸", color: "#1abc9c", parentId: "domain", isCategory: false, order: 0 },
        "mgmt":          { label: "ç®¡ç†èƒ½åŠ›", icon: "ğŸ‘”", color: "#e67e22", parentId: "domain", isCategory: false, order: 1 },
        "personal":      { label: "ä¸ªäººå‘å±•", icon: "ğŸŒ±", color: "#27ae60", parentId: "domain", isCategory: false, order: 2 },
        "priority":      { label: "ç´§æ€¥ç¨‹åº¦", icon: "âš¡", color: "#8e44ad", parentId: null, isCategory: true, order: 2 },
        "p1-critical":   { label: "P1-ç´§æ€¥", icon: "ğŸ”´", color: "#c0392b", parentId: "priority", isCategory: false, order: 0 },
        "p2-high":       { label: "P2-é‡è¦", icon: "ğŸŸ ", color: "#d35400", parentId: "priority", isCategory: false, order: 1 },
        "p3-normal":     { label: "P3-æ­£å¸¸", icon: "ğŸŸ¡", color: "#f39c12", parentId: "priority", isCategory: false, order: 2 },
        "p4-low":        { label: "P4-ä½", icon: "ğŸŸ¢", color: "#27ae60", parentId: "priority", isCategory: false, order: 3 }
    };

    // ä»æ–‡ä»¶åŠ è½½æ ‡ç­¾å®šä¹‰
    const loadTagDefinitions = async () => {
        try {
            if (await app.vault.adapter.exists(TAGS_PATH)) {
                const content = await app.vault.adapter.read(TAGS_PATH);
                const data = JSON.parse(content);
                return data.tags || DEFAULT_TAG_DEFINITIONS;
            }
        } catch (e) {
            console.error("åŠ è½½æ ‡ç­¾å®šä¹‰å¤±è´¥:", e);
        }
        return DEFAULT_TAG_DEFINITIONS;
    };

    // ä¿å­˜æ ‡ç­¾å®šä¹‰åˆ°æ–‡ä»¶
    const saveTagDefinitions = async (tags) => {
        const data = {
            tags: tags,
            version: "1.0",
            lastModified: moment().format("YYYY-MM-DD HH:mm:ss")
        };
        const jsonString = JSON.stringify(data, null, 2);
        const file = app.vault.getAbstractFileByPath(TAGS_PATH);
        if (file) {
            await app.vault.modify(file, jsonString);
        } else {
            await app.vault.create(TAGS_PATH, jsonString);
        }
    };

    // åŠ è½½æ ‡ç­¾å®šä¹‰
    let TAG_DEFINITIONS = await loadTagDefinitions();

    // ============================================================
    // ğŸ”· æ–°å¢ï¼šTimeline æ—¶é—´è½´åŠŸèƒ½æ¨¡å—
    // ============================================================

    // --- Timeline å…¨å±€çŠ¶æ€ ---
    if (window.gtdTimelineMode === undefined) window.gtdTimelineMode = false;

    // --- Timeline åŠ è½½/ä¿å­˜å‡½æ•° ---
    const generateTimelineId = () => Date.now().toString(36) + Math.random().toString(36).substr(2, 5);

    const loadTimelineData = async () => {
        try {
            if (await app.vault.adapter.exists(TIMELINE_PATH)) {
                const content = await app.vault.adapter.read(TIMELINE_PATH);
                return JSON.parse(content);
            }
        } catch (e) { console.error("åŠ è½½Timelineæ•°æ®å¤±è´¥:", e); }
        return [];  // è¿”å›ç©ºæ•°ç»„ï¼ˆæ— æŸåˆå§‹åŒ–ï¼‰
    };

    const saveTimelineData = async (data) => {
        const jsonString = JSON.stringify(data, null, 2);
        const file = app.vault.getAbstractFileByPath(TIMELINE_PATH);
        if (file) {
            await app.vault.modify(file, jsonString);
        } else {
            await app.vault.create(TIMELINE_PATH, jsonString);
        }
    };

    // --- è·å–ä»»åŠ¡çš„å®Œæ•´å±‚çº§è·¯å¾„ï¼ˆå†’æ³¡ä¸Šå±‚çº§ï¼‰---
    const getTaskHierarchyPath = (task, allTasks) => {
        const pathStack = [task.project || "æœªå½’ç±»"];
        let currentTask = task;

        // å‘ä¸Šè¿½æº¯çˆ¶ä»»åŠ¡
        while (currentTask && currentTask.parentId) {
            const parent = allTasks.find(t => t.id === currentTask.parentId);
            if (parent) {
                pathStack.unshift(parent.content || parent.project);
                currentTask = parent;
            } else {
                break;
            }
        }
        return pathStack.join(" â€º ");
    };

    // --- è·å–æ ‡ç­¾çš„æ˜¾ç¤ºä¿¡æ¯ ---
    const getTagDisplayInfo = (tagIds) => {
        if (!tagIds || tagIds.length === 0) return [];
        return tagIds.map(tagId => {
            const def = TAG_DEFINITIONS[tagId];
            if (!def) return null;
            return {
                id: tagId,
                label: def.label,
                icon: def.icon,
                color: def.color
            };
        }).filter(Boolean);
    };

    // --- è®°å½•å®Œæˆäº‹é¡¹åˆ° Timeline ---
    const recordToTimeline = async (task, index) => {
        // 1. å¼¹å‡ºè¯„è¯­è¾“å…¥çª—å£ï¼ˆç•™ç©ºåˆ™ä¸è®°å½•åˆ°Timelineï¼‰
        const rawComment = await prompt(`âœ… å®Œæˆè®°å½•: ${task.content || task.project}`, "è®°å½•è¯„è¯­/æ„Ÿæƒ³/å¤‡æ³¨ (ç•™ç©ºåˆ™ä¸è®°å½•åˆ°Timeline)");
        if (rawComment === undefined) return false;  // ç”¨æˆ·å–æ¶ˆ

        // 2. å¤„ç†è¯„è¯­ï¼šç©ºã€ç©ºå­—ç¬¦ä¸²ã€"ç©º"åˆ™è§†ä¸ºè·³è¿‡è®°å½•
        const finalComment = (rawComment === null || rawComment === undefined || rawComment.trim() === "" || rawComment.trim() === "ç©º") ? null : rawComment.trim();

        // ğŸ”· å…³é”®é€»è¾‘ï¼šå¦‚æœ finalComment ä¸º nullï¼Œç›´æ¥è¿”å›ï¼Œä¸åˆ›å»º Timeline è®°å½•
        // ä½†ä»ç„¶è¿”å› true ä»¥ç¡®ä¿ä»»åŠ¡çŠ¶æ€èƒ½è¢«æ­£å¸¸æ›´æ–°
        if (finalComment === null) {
            new Notice(`â„¹ï¸ ä»»åŠ¡å®Œæˆï¼Œè·³è¿‡ Timeline è®°å½•`);
            return true;
        }

        // 3. ç¡®è®¤æ—¥æœŸï¼ˆé»˜è®¤ä»Šå¤©ï¼‰- ä»…å½“éœ€è¦è®°å½•æ—¶æ‰è¯¢é—®
        const defaultDate = moment().format("YYYY-MM-DD");
        const inputDate = await prompt("ç¡®è®¤æ—¥æœŸ", "YYYY-MM-DD", defaultDate);
        if (inputDate === undefined) return false;

        // 4. æ„å»ºå®Œæ•´è·¯å¾„å’Œæ ‡ç­¾ä¿¡æ¯
        const allTasks = await loadData();
        const projectPath = getTaskHierarchyPath(task, allTasks);
        const tagInfo = getTagDisplayInfo(task.tags);

        // 5. åˆ›å»ºæ—¥å¿—è®°å½•
        const newLog = {
            id: generateTimelineId(),
            taskId: task.id,
            taskTitle: task.content || task.project,
            projectName: task.project || "æœªå½’ç±»",
            projectPath: projectPath,  // å®Œæ•´å†’æ³¡å±‚çº§è·¯å¾„
            tags: task.tags || [],
            tagInfo: tagInfo,  // æ ‡ç­¾è¯¦ç»†ä¿¡æ¯ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
            date: inputDate,
            time: moment().format("HH:mm"),
            comment: finalComment,
            timestamp: Date.now()
        };

        // 6. ä¿å­˜åˆ°ç‹¬ç«‹æ—¥å¿—æ–‡ä»¶
        const timelineData = await loadTimelineData();
        timelineData.push(newLog);
        // æŒ‰æ—¥æœŸå€’åºï¼Œæ—¶é—´æˆ³æ­£åº
        timelineData.sort((a, b) => {
            if (a.date !== b.date) return b.date.localeCompare(a.date);
            return b.timestamp - a.timestamp;
        });
        await saveTimelineData(timelineData);

        new Notice(`ğŸ“ å·²è®°å½•åˆ° Timeline [${inputDate}]`);
        return true;
    };

    // ============================================================
    // ğŸ”· åŸæœ‰æ ‡ç­¾å±‚çº§å·¥å…·å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰
    // ============================================================

    // --- 0.1 æ ‡ç­¾å±‚çº§å·¥å…·å‡½æ•° ---
    // è·å–æ ‡ç­¾çš„æ‰€æœ‰å­å­™æ ‡ç­¾IDï¼ˆç”¨äºç­›é€‰æ—¶çˆ¶çº§åŒ…å«å­çº§ï¼‰
    const getDescendantTagIds = (tagId) => {
        const descendants = [];
        const findChildren = (parentId) => {
            Object.keys(TAG_DEFINITIONS).forEach(key => {
                if (TAG_DEFINITIONS[key].parentId === parentId) {
                    descendants.push(key);
                    findChildren(key); // é€’å½’æŸ¥æ‰¾å­å­™
                }
            });
        };
        findChildren(tagId);
        return descendants;
    };

    // è·å–æ ‡ç­¾çš„æ‰€æœ‰ç¥–å…ˆæ ‡ç­¾IDï¼ˆç”¨äºæ˜¾ç¤ºé¢åŒ…å±‘è·¯å¾„ï¼‰
    const getAncestorTagIds = (tagId) => {
        const ancestors = [];
        let current = TAG_DEFINITIONS[tagId];
        while (current && current.parentId) {
            ancestors.unshift(current.parentId);
            current = TAG_DEFINITIONS[current.parentId];
        }
        return ancestors;
    };

    // è·å–é¡¶å±‚æ ‡ç­¾ï¼ˆparentIdä¸ºnullçš„ï¼‰
    const getTopLevelTags = () => {
        return Object.keys(TAG_DEFINITIONS).filter(key => TAG_DEFINITIONS[key].parentId === null);
    };

    // è·å–æŸä¸ªæ ‡ç­¾çš„ç›´æ¥å­æ ‡ç­¾
    const getChildTags = (parentId) => {
        return Object.keys(TAG_DEFINITIONS).filter(key => TAG_DEFINITIONS[key].parentId === parentId);
    };

    // æ£€æŸ¥æŸä¸ªtagIdæ˜¯å¦åŒ¹é…ç­›é€‰æ¡ä»¶ï¼ˆåŒ…å«å­å­™åŒ¹é…ï¼‰
    const tagMatchesFilter = (itemTags, filterTagId) => {
        if (!filterTagId || !itemTags || itemTags.length === 0) return false;
        // ç›´æ¥åŒ¹é…
        if (itemTags.includes(filterTagId)) return true;
        // å­å­™åŒ¹é…ï¼šå¦‚æœç­›é€‰çš„æ˜¯çˆ¶æ ‡ç­¾ï¼Œåˆ™å­å­™æ ‡ç­¾ä¹Ÿç®—åŒ¹é…
        const descendants = getDescendantTagIds(filterTagId);
        return itemTags.some(t => descendants.includes(t));
    };

    // åˆå§‹åŒ–å…¨å±€çŠ¶æ€
    if (window.gtdShowOnlyFirstClass === undefined) window.gtdShowOnlyFirstClass = false;
    if (window.gtdShowOnlyFocus === undefined) window.gtdShowOnlyFocus = false;
    if (window.gtdTagFilter === undefined) window.gtdTagFilter = null;
    if (window.gtdKaioKenMode === undefined) window.gtdKaioKenMode = false;
    if (window.gtdTagManagerMode === undefined) window.gtdTagManagerMode = false;
    if (window.gtdRecentIds === undefined) window.gtdRecentIds = [];
    if (window.gtdQuickNavCollapsed === undefined) window.gtdQuickNavCollapsed = {};

    window.gtdCurrentDragId = null;
    window.gtdCurrentDragTagId = null;
    window.gtdCurrentDragProjectId = null;

    // --- 1. æ ¸å¿ƒäº¤äº’ç»„ä»¶ ---
    class QuickSuggester extends obsidian.FuzzySuggestModal {
        constructor(app, items, onChoose) { super(app); this.items = items; this.onChoose = onChoose; }
        getItems() { return this.items; }
        getItemText(item) { return item; }
        onChooseItem(item, evt) { this.onChoose(item); }
    }
    
    // --- å±‚çº§æ ‡ç­¾é€‰æ‹©å™¨ï¼ˆæ”¯æŒæ ‘çŠ¶å±•ç¤ºï¼‰---
    class TagSuggester extends obsidian.FuzzySuggestModal {
        constructor(app, currentTags, onChoose) {
            super(app);
            this.currentTags = currentTags || [];
            this.onChoose = onChoose;
            // æ„å»ºå±‚çº§åˆ—è¡¨ï¼šå…ˆé¡¶å±‚ï¼Œç„¶åé€’å½’åŠ å…¥å­çº§
            this.items = [];
            const buildTreeItems = (parentId, level) => {
                const children = getChildTags(parentId);
                children.forEach(key => {
                    const def = TAG_DEFINITIONS[key];
                    const isSelected = this.currentTags.includes(key);
                    const indent = "ã€€".repeat(level); // å…¨è§’ç©ºæ ¼ç¼©è¿›
                    const prefix = level > 0 ? "â””â”€ " : "";
                    this.items.push({
                        key: key,
                        label: def.label,
                        icon: def.icon,
                        color: def.color,
                        isCategory: def.isCategory || false,
                        level: level,
                        displayText: `${indent}${prefix}${def.icon} ${def.label}`,
                        desc: def.isCategory ? "ğŸ“ åˆ†ç±»" : (isSelected ? "âœ… å·²åº”ç”¨" : "â¬œ ç‚¹å‡»æ·»åŠ "),
                        action: isSelected ? "remove" : "add"
                    });
                    buildTreeItems(key, level + 1); // é€’å½’å­çº§
                });
            };
            buildTreeItems(null, 0); // ä»é¡¶å±‚å¼€å§‹
        }
        getItems() { return this.items; }
        getItemText(item) { return `${item.displayText}  ${item.desc}`; }
        onChooseItem(item, evt) {
            // åˆ†ç±»æ ‡ç­¾ä¸å¯ç›´æ¥é€‰æ‹©ï¼Œåªèƒ½é€‰å­æ ‡ç­¾
            if (item.isCategory) {
                new Notice(`ğŸ“ "${item.label}" æ˜¯åˆ†ç±»ï¼Œè¯·é€‰æ‹©å…¶ä¸‹çš„å­æ ‡ç­¾`);
                return;
            }
            this.onChoose(item);
        }
    }

    class QuickPrompt extends obsidian.Modal {
        constructor(app, title, placeholder, onSubmit, defaultValue = "") {
            super(app); this.titleStr = title; this.placeholder = placeholder; this.defaultValue = defaultValue; this.onSubmit = onSubmit;
        }
        onOpen() {
            const { contentEl } = this; contentEl.createEl("h3", { text: this.titleStr });
            const input = contentEl.createEl("input", { type: "text", value: this.defaultValue });
            input.placeholder = this.placeholder; input.style.width = "100%"; input.focus();
            const btn = contentEl.createEl("button", { text: "ç¡®å®š", cls: "mod-cta", style: "margin-top:15px; float:right;" });
            const submit = () => { if(input.value) { this.close(); this.onSubmit(input.value); }};
            btn.onclick = submit; input.addEventListener("keypress", (e) => { if (e.key === "Enter") submit(); });
        }
        onClose() { this.contentEl.empty(); }
    }
    class ConfirmModal extends obsidian.Modal {
        constructor(app, title, message, onConfirm) {
            super(app); this.titleStr = title; this.message = message; this.onConfirm = onConfirm;
        }
        onOpen() {
            const { contentEl } = this;
            contentEl.createEl("h3", { text: this.titleStr });
            const msgEl = contentEl.createEl("div");
            msgEl.innerHTML = this.message;
            msgEl.style.marginBottom = "20px";
            
            const btnDiv = contentEl.createEl("div", { attr: { style: "display:flex; justify-content:flex-end; gap:10px;" } });
            const cancelBtn = btnDiv.createEl("button", { text: "å–æ¶ˆ" });
            cancelBtn.onclick = () => this.close();
            const confirmBtn = btnDiv.createEl("button", { text: "ç¡®è®¤ç§»åŠ¨", cls: "mod-cta" });
            confirmBtn.onclick = () => { this.close(); this.onConfirm(); };
        }
        onClose() { this.contentEl.empty(); }
    }

    const prompt = (title, placeholder = "", defaultValue = "") => new Promise(r => new QuickPrompt(app, title, placeholder, r, defaultValue).open());
    const suggester = (items) => new Promise(r => new QuickSuggester(app, items, r).open());
    const tagSelector = (currentTags) => new Promise(r => new TagSuggester(app, currentTags, r).open());
    const confirm = (title, message) => new Promise(r => new ConfirmModal(app, title, message, r).open());

    // --- 2. æ–‡ä»¶ç®¡ç† ---
    const getOrCreateProjectFile = async (projectName) => {
        const projectPath = `${currentFolder}/${projectName}.md`;
        let projectFile = app.vault.getAbstractFileByPath(projectPath);
        if (!projectFile) {
            const initialContent = `åˆ›å»ºæ—¶é—´: ${moment().format("YYYY-MM-DD HH:mm:ss")}\n\n# ${projectName}\n\n## é¡¹ç›®æ¦‚è¿°\n\n## ç›¸å…³èµ„æ–™\n\n`;
            await app.vault.create(projectPath, initialContent);
            projectFile = app.vault.getAbstractFileByPath(projectPath);
            new Notice(`ğŸ“„ å·²è‡ªåŠ¨åˆ›å»ºé¡¹ç›®æ–‡ä»¶: ${projectName}`);
        }
        return projectFile;
    };

    const openOrCreateNote = async (displayName) => {
        const sourcePath = dv.current().file.path;
        const existing = app.metadataCache.getFirstLinkpathDest(displayName, sourcePath);
        if (!existing) {
            const sourceFile = app.vault.getAbstractFileByPath(sourcePath);
            const parentPath = sourceFile?.parent?.path || "";
            const newPath = parentPath && parentPath !== "/" ? `${parentPath}/${displayName}.md` : `${displayName}.md`;
            const initialContent = `åˆ›å»ºæ—¶é—´: ${moment().format("YYYY-MM-DD HH:mm:ss")}\n\n`;
            await app.vault.create(newPath, initialContent);
        }
        await app.workspace.openLinkText(displayName, sourcePath, true);
    };

    // --- 3. æ•°æ®å¤„ç†ä¸è‡ªæ„ˆæœºåˆ¶ ---
    const repairOrphans = (list) => {
        let fixedCount = 0;
        const idMap = new Map(list.map(i => [i.id, i]));
        list.forEach(item => {
            if (item.status === 'active' && item.parentId) {
                const parent = idMap.get(item.parentId);
                if (parent && parent.status === 'completed') {
                    parent.status = 'active';
                    delete parent.completed_date;
                    delete parent.archived_by_project;
                    fixedCount++;
                }
            }
        });
        return fixedCount;
    };

    const loadData = async () => {
        if (!await app.vault.adapter.exists(DB_PATH)) return [];
        const content = await app.vault.adapter.read(DB_PATH);
        try { 
            let list = JSON.parse(content);
            let modified = false;
            list.forEach(i => { 
                if(i.isFirstClass === undefined) i.isFirstClass = false;
                if(i.isFocusSession === undefined) i.isFocusSession = false;
                if(i.isDimmed === undefined) i.isDimmed = false; 
                if(i.isCollapsed === undefined) i.isCollapsed = false;
                if(i.tags === undefined) i.tags = []; 
                if(!i.id) i.id = Date.now() + Math.random().toString().slice(2,8);
                if(i.deadline === undefined) i.deadline = null;
                if(!i.created) i.created = moment().format("YYYY-MM-DD");
                if(i.parentId === undefined) i.parentId = null; 
            });
            const repairedCount = repairOrphans(list);
            if (repairedCount > 0) { new Notice(`ğŸš‘ è‡ªåŠ¨ä¿®å¤ ${repairedCount} ä¸ªçˆ¶çº§çŠ¶æ€`); modified = true; }
            if (modified) {
                const jsonString = JSON.stringify(list, null, 2);
                const file = app.vault.getAbstractFileByPath(DB_PATH);
                await app.vault.modify(file, jsonString);
            }
            return list;
        } catch (e) { return []; }
    };
    let gtdList = await loadData();
    let renderViewFn = null;

    const updateGTD = async (operationFn) => {
        let currentList = await loadData(); 
        operationFn(currentList);
        const jsonString = JSON.stringify(currentList, null, 2);
        const file = app.vault.getAbstractFileByPath(DB_PATH);
        if (file) await app.vault.modify(file, jsonString); else await app.vault.create(DB_PATH, jsonString);
        gtdList = currentList; 
        if (renderViewFn) renderViewFn(); 
    };

    // --- åŠŸèƒ½å‡½æ•°åŒº ---
    const toggleFirstClass = async (index) => { await updateGTD((list) => { if (list[index]) list[index].isFirstClass = !list[index].isFirstClass; }); };
    const toggleFocusSession = async (index) => { await updateGTD((list) => { if (list[index]) list[index].isFocusSession = !list[index].isFocusSession; }); };
    const toggleDimmed = async (index) => { await updateGTD((list) => { if (list[index]) list[index].isDimmed = !list[index].isDimmed; }); };
    const toggleCollapse = async (index) => { await updateGTD((list) => { if (list[index]) list[index].isCollapsed = !list[index].isCollapsed; }); };
    
    const modifyTag = async (index) => {
        const item = gtdList[index];
        const choice = await tagSelector(item.tags); 
        if (!choice) return;
        
        await updateGTD((list) => {
            if (!list[index]) return;
            if (!list[index].tags) list[index].tags = [];
            const tagId = choice.key;
            const action = choice.action;
            
            if (action === "add") {
                if (!list[index].tags.includes(tagId)) list[index].tags.push(tagId);
            } else {
                list[index].tags = list[index].tags.filter(t => t !== tagId);
            }
        });
        new Notice(choice.action === "add" ? `âœ… å·²æ·»åŠ : ${choice.label}` : `ğŸ—‘ï¸ å·²ç§»é™¤: ${choice.label}`);
    };

    const moveInboxItem = async (index) => {
        const options = ["ğŸ“‚ è½¬ä¸ºæ–°é¡¹ç›®", "âš¡ è½¬å…¥å·²æœ‰é¡¹ç›®"];
        const choice = await suggester(options);
        if (!choice) return;
        if (choice.startsWith("ğŸ“‚")) {
            await updateGTD((list) => { const item = list[index]; item.type = 'project'; item.project = item.content; item.content = null; });
            await getOrCreateProjectFile(gtdList[index].content); 
            new Notice("âœ… å·²å‡çº§ä¸ºé¡¹ç›®");
        } else {
            const activeProjects = gtdList.filter(i => i.type === 'project' && i.status === 'active').map(p => p.project).sort((a, b) => a.localeCompare(b, "zh"));
            if (activeProjects.length === 0) { new Notice("âš ï¸ æ²¡æœ‰æ´»è·ƒé¡¹ç›®"); return; }
            const targetProj = await suggester(activeProjects);
            if (!targetProj) return;
            await updateGTD((list) => { const item = list[index]; item.type = 'next_action'; item.project = targetProj; });
            new Notice(`âœ… å·²ç§»åŠ¨åˆ°é¡¹ç›®: ${targetProj}`);
        }
    };

    const renameLinkedFile = async (oldName, newName) => {
        const currentFile = dv.current().file;
        const targetFile = app.metadataCache.getFirstLinkpathDest(oldName, currentFile.path);
        if (targetFile) {
            try {
                const parentPath = targetFile.parent.path;
                const newPath = parentPath === "/" ? `${newName}.md` : `${parentPath}/${newName}.md`;
                await app.fileManager.renameFile(targetFile, newPath);
            } catch (e) {}
        }
    };
    
    const renameItem = async (index, type, oldName) => {
        const newName = await prompt(`é‡å‘½å${type === 'project' ? 'é¡¹ç›®' : 'æ¡ç›®'}`, "è¯·è¾“å…¥æ–°åç§°", oldName);
        if (!newName || newName === oldName) return;
        await renameLinkedFile(oldName, newName);
        await updateGTD((list) => {
            if (list[index]) {
                if (type === 'project') list[index].project = newName; else list[index].content = newName;
            }
            if (type === 'project') { list.forEach(item => { if (item.type === 'next_action' && item.project === oldName) item.project = newName; }); }
        });
        new Notice("âœ… é‡å‘½åæˆåŠŸ");
    };

    const setItemSchedule = async (index, oldDate) => {
        const newDate = await prompt("è®¾ç½®æ—¥ç¨‹ (Schedule)", "æ ¼å¼: YYYY-MM-DD", oldDate || moment().format("YYYY-MM-DD"));
        await updateGTD((list) => { if (list[index]) list[index].scheduled = newDate ? newDate : null; });
    };
    
    const setItemDeadline = async (index, oldDate) => {
        const newDate = await prompt("è®¾ç½®æˆªæ­¢ (Deadline)", "æ ¼å¼: YYYY-MM-DD", oldDate || moment().format("YYYY-MM-DD"));
        await updateGTD((list) => { if (list[index]) list[index].deadline = newDate ? newDate : null; });
    };

    const addNewItem = async (type, parentId = null, defaultProject = null) => {
        let placeholder = type === 'project' ? "ä¾‹å¦‚ï¼šå¹´åº¦æ€»ç»“æŠ¥å‘Š" : (type === 'inbox' ? "ä¾‹å¦‚ï¼šä¹°ç‰›å¥¶" : "ä¾‹å¦‚ï¼šæ•´ç†Excelæ•°æ®");
        let title = parentId ? "æ·»åŠ å­ä»»åŠ¡" : `æ·»åŠ ã€${type === 'project' ? 'é¡¹ç›®' : (type === 'inbox' ? 'å·¥ä½œç¯®ä»»åŠ¡' : 'ä¸‹ä¸€æ­¥è¡ŒåŠ¨')}ã€‘`;
        const inputName = await prompt(title, placeholder);
        if (!inputName) return;
        const newId = Date.now().toString();
        let newItem = { 
            id: newId, type: type, status: "active", created: moment().format("YYYY-MM-DD"), 
            project: null, content: null, scheduled: null, deadline: null, 
            isFirstClass: false, isFocusSession: false, isDimmed: false, isCollapsed: false, tags: [], parentId: parentId 
        };
        if (type === 'project') {
            newItem.project = inputName;
            await getOrCreateProjectFile(inputName);
        }
        else if (type === 'inbox') newItem.content = inputName;
        else if (type === 'next_action') {
            let selectedProject = defaultProject;
            if (!selectedProject) {
                const activeProjects = gtdList.filter(i => i.type === 'project' && i.status === 'active').map(p => p.project).sort((a, b) => a.localeCompare(b, "zh"));
                if (activeProjects.length === 0) { new Notice("âš ï¸ è¯·å…ˆåˆ›å»ºä¸€ä¸ªé¡¹ç›®ï¼"); return; }
                selectedProject = await suggester(activeProjects);
            }
            if (!selectedProject) return;
            newItem.project = selectedProject;
            newItem.content = inputName;
        }
        window.gtdRecentIds.push(newId);
        await updateGTD((list) => { list.push(newItem); });
    };

    const checkSubtasks = (parentId) => {
        return gtdList.some(item => item.parentId === parentId && item.status === 'active');
    };

    const completeItem = async (index) => {
        const item = gtdList[index];
        if (checkSubtasks(item.id)) { new Notice("âš ï¸ æ— æ³•å®Œæˆï¼šè¯·å…ˆå®Œæˆè¯¥ä»»åŠ¡ä¸‹çš„æ‰€æœ‰å­ä»»åŠ¡ï¼"); return; }

        // ğŸ”· æ–°å¢ï¼šå…ˆè®°å½•åˆ° Timelineï¼ˆç”¨æˆ·å¯å–æ¶ˆï¼Œä½†çŠ¶æ€ä»ä¼šå˜æ›´ï¼‰
        await recordToTimeline(item, index);

        await updateGTD((list) => { if (list[index]) { list[index].status = "completed"; list[index].completed_date = moment().format("YYYY-MM-DD"); } });
    };
    
    const completeProject = async (index, projectName) => {
        // ğŸ”· æ–°å¢ï¼šæ‰¹é‡è®°å½•ä»»åŠ¡åˆ° Timeline
        const tasksToComplete = gtdList.filter(i => i.type === 'next_action' && i.project === projectName && i.status === 'active');
        for (const task of tasksToComplete) {
            await recordToTimeline(task, -1);
        }

        await updateGTD((list) => {
            if (list[index]) { list[index].status = "completed"; list[index].completed_date = moment().format("YYYY-MM-DD"); }
            for (let i = 0; i < list.length; i++) {
                if (list[i].type === 'next_action' && list[i].project === projectName && list[i].status === 'active') {
                    list[i].status = "completed"; list[i].completed_date = moment().format("YYYY-MM-DD"); list[i].archived_by_project = true;
                }
            }
        });
        new Notice(`ğŸ“‚ é¡¹ç›® [${projectName}] å·²å½’æ¡£`);
    };

    const reactivateItem = async (index) => { await updateGTD((list) => { if (list[index]) { list[index].status = "active"; delete list[index].completed_date; delete list[index].archived_by_project; } }); };
    
    const reactivateProject = async (index, projectName) => {
        await updateGTD((list) => {
            if (list[index]) { list[index].status = "active"; delete list[index].completed_date; }
            let count = 0;
            for (let i = 0; i < list.length; i++) {
                if (list[i].type === 'next_action' && list[i].project === projectName && list[i].archived_by_project === true) {
                    list[i].status = "active"; delete list[i].completed_date; delete list[i].archived_by_project; count++;
                }
            }
        });
        new Notice(`ğŸ“‚ é¡¹ç›®å·²å›é€€ï¼Œæ¢å¤ ${count} ä¸ªä»»åŠ¡`);
    };

    const deleteItem = async (index) => { 
        const item = gtdList[index];
        if (checkSubtasks(item.id)) { new Notice("âš ï¸ æ— æ³•åˆ é™¤ï¼šåŒ…å«å­ä»»åŠ¡ï¼"); return; }
        await confirm("å½»åº•åˆ é™¤", "ç¡®å®šè¦å½»åº•åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ").then(async () => {
            await updateGTD((list) => { list.splice(index, 1); }); 
            new Notice("ğŸ—‘ï¸ ä»»åŠ¡å·²å½»åº•åˆ é™¤");
        }).catch(() => {});
    };

    const handleDrop = async (draggedId, targetId, position, targetType = 'task') => {
        if (!draggedId || draggedId === targetId) return;
        const draggedItem = gtdList.find(i => i.id === draggedId);
        if (!draggedItem) return;
        let confirmMsg = ""; let targetName = "";
        if (targetType === 'project') {
            targetName = targetId;
            confirmMsg = `ç¡®å®šè¦å°† <b>[${draggedItem.content}]</b> ç§»åŠ¨åˆ°é¡¹ç›® <b>[${targetName}]</b> çš„é¡¶å±‚å—ï¼Ÿ`;
        } else {
            const targetItem = gtdList.find(i => i.id === targetId);
            if (!targetItem) return;
            targetName = targetItem.content;
            if (position === 'child') confirmMsg = `ç¡®å®šå°† <b>[${draggedItem.content}]</b> è®¾ä¸º <b>[${targetName}]</b> çš„å­ä»»åŠ¡å—ï¼Ÿ`;
            else confirmMsg = `ç¡®å®šè°ƒæ•´ <b>[${draggedItem.content}]</b> çš„çˆ¶çº§å½’å±åˆ° <b>[${targetName}]</b> æ‰€åœ¨å±‚çº§å—ï¼Ÿ`;
        }
        await confirm("ç¡®è®¤ç§»åŠ¨", confirmMsg).then(async () => {
            await updateGTD((list) => {
                const draggedIndex = list.findIndex(i => i.id === draggedId);
                const item = list[draggedIndex];
                if (targetType === 'project') { item.parentId = null; item.project = targetName; } else {
                    const targetIndex = list.findIndex(i => i.id === targetId); const target = list[targetIndex];
                    if (position === 'child') { item.parentId = target.id; if (item.project !== target.project) item.project = target.project; } else { item.parentId = target.parentId; if (item.project !== target.project) item.project = target.project; }
                }
                list.splice(draggedIndex, 1); list.push(item); 
            });
            new Notice("âœ… ç§»åŠ¨æˆåŠŸ");
        }).catch(() => {});
    };

    const moveProjectUnderParent = async (draggedProjectId, targetParentProjectId = null) => {
        if (!draggedProjectId) return;
        if (draggedProjectId === targetParentProjectId) return;

        const draggedProject = gtdList.find(i => i.id === draggedProjectId && i.type === "project" && i.status === "active");
        if (!draggedProject) return;

        const targetParent = targetParentProjectId
            ? gtdList.find(i => i.id === targetParentProjectId && i.type === "project" && i.status === "active")
            : null;
        if (targetParentProjectId && !targetParent) return;

        const currentParentId = draggedProject.parentId || null;
        const nextParentId = targetParentProjectId || null;
        if (currentParentId === nextParentId) return;

        // é˜²æ­¢å¾ªç¯ï¼šä¸èƒ½æŠŠé¡¹ç›®æ‹–åˆ°è‡ªå·±çš„åä»£ä¸‹
        let cursor = nextParentId;
        while (cursor) {
            if (cursor === draggedProjectId) {
                new Notice("âš ï¸ æ— æ•ˆæ“ä½œï¼šä¸èƒ½æŠŠé¡¹ç›®æ‹–åˆ°è‡ªå·±çš„å­çº§ä¸‹é¢");
                return;
            }
            const cursorItem = gtdList.find(i => i.id === cursor && i.type === "project");
            cursor = cursorItem ? (cursorItem.parentId || null) : null;
        }

        const fromName = draggedProject.project || "æœªå‘½åé¡¹ç›®";
        const targetName = targetParent ? (targetParent.project || "æœªå‘½åé¡¹ç›®") : "é¡¶å±‚";
        const msg = targetParent
            ? `ç¡®å®šå°†é¡¹ç›® <b>[${fromName}]</b> è®¾ä¸º <b>[${targetName}]</b> çš„å­é¡¹ç›®å—ï¼Ÿ`
            : `ç¡®å®šå°†é¡¹ç›® <b>[${fromName}]</b> ç§»åŠ¨åˆ°é¡¶å±‚å—ï¼Ÿ`;

        await confirm("ç¡®è®¤è°ƒæ•´é¡¹ç›®å±‚çº§", msg).then(async () => {
            await updateGTD((list) => {
                const idx = list.findIndex(i => i.id === draggedProjectId && i.type === "project");
                if (idx < 0) return;
                list[idx].parentId = nextParentId;
            });
            new Notice("âœ… é¡¹ç›®å±‚çº§å·²æ›´æ–°");
        }).catch(() => {});
    };

    // ==========================================================
    // ğŸ¨ è§†å›¾é€»è¾‘
    // ==========================================================
    const renderKaioKenView = (container) => {
        // ... (KaioKenè§†å›¾é€»è¾‘çœç•¥ï¼Œä¿æŒä¸å˜) ...
        const style = `<style>.kaio-container{background:var(--background-secondary);border-radius:12px;padding:20px;font-family:sans-serif;min-height:400px}.kaio-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid var(--interactive-accent)}.kaio-title{font-size:1.5em;font-weight:800;color:var(--text-normal);margin:0;display:flex;align-items:center;gap:8px}.kaio-icon{font-size:1.2em;color:#e74c3c;animation:kaio-glow 2s infinite alternate}@keyframes kaio-glow{from{text-shadow:0 0 5px rgba(231,76,60,.5)}to{text-shadow:0 0 15px #e74c3c}}.kaio-section-title{font-size:1.1em;font-weight:700;margin:25px 0 10px;color:var(--text-muted);border-bottom:1px solid var(--background-modifier-border);padding-bottom:4px;display:flex;justify-content:space-between}.kaio-proj-group{margin-bottom:15px;border-left:2px solid var(--interactive-accent);padding-left:12px}.kaio-proj-name{font-weight:700;font-size:.9em;color:var(--text-normal);margin-bottom:8px;opacity:.9}.kaio-item-card{background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:8px;padding:10px 14px;display:grid;grid-template-columns:200px 1fr 100px;gap:15px;align-items:center;margin-bottom:8px;transition:transform .2s}.kaio-item-card:hover{transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,0,0,.1)}.k-info{display:flex;flex-direction:column;gap:2px;overflow:hidden}.k-name{font-weight:700;font-size:1em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--text-normal);cursor:pointer}.k-name:hover{color:var(--interactive-accent);text-decoration:underline}.k-sub{font-size:.75em;color:var(--text-muted);display:flex;gap:6px;align-items:center}.k-tag{background:var(--background-modifier-hover);padding:1px 4px;border-radius:3px}.k-timeline-container{position:relative;height:28px;width:100%;display:flex;flex-direction:column;justify-content:center}.k-track{width:100%;height:8px;background:var(--background-modifier-form-field);border-radius:4px;position:relative;overflow:visible}.k-zone-kaio{position:absolute;left:0;top:0;bottom:0;width:33.33%;background:linear-gradient(90deg,rgba(231,76,60,.4),rgba(243,156,18,.3));border-radius:4px 0 0 4px;border-right:1px dashed rgba(231,76,60,.6)}.k-marker-now{position:absolute;top:-3px;bottom:-3px;width:3px;background:#3498db;box-shadow:0 0 6px #3498db;z-index:10;border-radius:2px;transition:left .5s ease}.k-dates{display:flex;justify-content:space-between;font-size:.7em;color:var(--text-muted);margin-top:3px}.k-actions{display:flex;flex-direction:column;align-items:flex-end;gap:4px}.k-status{font-size:.8em;font-weight:700}.k-status.rush{color:#e74c3c;display:flex;align-items:center;gap:4px}.k-status.calm{color:#2ecc71}.k-mini-btn{font-size:12px;cursor:pointer;padding:2px 6px;border-radius:4px;background:var(--background-secondary);border:1px solid var(--background-modifier-border)}.k-mini-btn:hover{background:var(--interactive-accent);color:#fff;border-color:transparent}</style>`;
        container.innerHTML = style;
        const wrapper = container.createEl("div", { cls: "kaio-container" });
        const header = wrapper.createEl("div", { cls: "kaio-header" });
        header.createEl("div", { cls: "kaio-title" }).innerHTML = `<span class="kaio-icon">ğŸ”¥</span> ç•Œç‹æ‹³çªå‡»çœ‹æ¿`;
        const exitBtn = header.createEl("button", { text: "é€€å‡ºæ¨¡å¼" });
        exitBtn.onclick = () => { window.gtdKaioKenMode = false; if(renderViewFn) renderViewFn(); };

        const today = moment();
        let rawItems = gtdList.map((item, index) => ({ item, index })).filter(({ item }) => 
            item.status === 'active' && item.deadline
        );

        if (rawItems.length === 0) {
            wrapper.createEl("div", { text: "ğŸ§˜ æš‚æ— å¸¦æˆªæ­¢æ—¥æœŸçš„çªå‡»ä»»åŠ¡", attr: { style: "text-align:center; padding:40px; color:var(--text-muted);" } });
            return;
        }

        rawItems.forEach(wrap => {
            const startStr = wrap.item.created;
            const endStr = wrap.item.deadline;
            let percent = 0;
            if (endStr) {
                const startDate = moment(startStr);
                const endDate = moment(endStr);
                const totalDays = endDate.diff(startDate, 'days');
                const passedDays = today.diff(startDate, 'days');
                totalDays <= 0 ? percent = 100 : percent = (passedDays / totalDays) * 100;
                percent = Math.max(0, Math.min(100, percent));
            }
            wrap.percent = percent;
            wrap.isSprint = percent <= 33.33;
            wrap.displayName = wrap.item.type === 'project' ? wrap.item.project : wrap.item.content;
            wrap.projectName = wrap.item.type === 'project' ? wrap.item.project : (wrap.item.project || "æœªåˆ†ç±»");
        });

        const sprintItems = rawItems.filter(x => x.isSprint).sort((a, b) => a.item.deadline.localeCompare(b.item.deadline));
        const calmItems = rawItems.filter(x => !x.isSprint);

        const renderCard = (targetEl, wrap) => {
            const card = targetEl.createEl("div", { cls: "kaio-item-card" });
            const { item, index, displayName, percent } = wrap;
            const info = card.createEl("div", { cls: "k-info" });
            const link = info.createEl("div", { text: displayName, cls: "k-name" });
            link.onclick = async () => { await openOrCreateNote(displayName); };
            const sub = info.createEl("div", { cls: "k-sub" });
            if (item.type === 'next_action') sub.innerHTML = `<span class="k-tag">ğŸ“‚ ${item.project}</span>`;
            else if (item.type === 'inbox') sub.innerHTML = `<span class="k-tag">ğŸ“¥ Inbox</span>`; 
            else sub.innerHTML = `<span class="k-tag">ğŸš© Project</span>`;
            const timelineBox = card.createEl("div", { cls: "k-timeline-container" });
            const track = timelineBox.createEl("div", { cls: "k-track" });
            track.createEl("div", { cls: "k-zone-kaio" }); 
            const marker = track.createEl("div", { cls: "k-marker-now" });
            marker.style.left = `${percent}%`;
            const dateRow = timelineBox.createEl("div", { cls: "k-dates" });
            dateRow.createEl("span", { text: item.created }); dateRow.createEl("span", { text: `ğŸ ${item.deadline}` });
            const actions = card.createEl("div", { cls: "k-actions" });
            const statusDiv = actions.createEl("div", { cls: "k-status" });
            if (today.isAfter(moment(item.deadline))) statusDiv.innerHTML = `<span style="color:#e74c3c">ğŸ’€ å·²è¿‡æœŸ</span>`;
            else if (wrap.isSprint) { statusDiv.className += " rush"; statusDiv.innerHTML = `ğŸ”¥ çªå‡»ä¸­`; }
            else { statusDiv.className += " calm"; statusDiv.innerHTML = `â˜• å¹³ç¨³æœŸ`; }
            const btnGroup = actions.createEl("div", { attr: { style: "display:flex; gap:4px;" } });
            const dlBtn = btnGroup.createEl("button", { text: "ğŸ", cls: "k-mini-btn", title: "ä¿®æ”¹" });
            dlBtn.onclick = () => setItemDeadline(index, item.deadline);
            const doneBtn = btnGroup.createEl("button", { text: "âœ…", cls: "k-mini-btn", title: "å®Œæˆ" });
            doneBtn.onclick = async () => { if (item.type === 'project') await completeProject(index, item.project); else await completeItem(index); };
        };

        const listContainer = wrapper.createEl("div");
        if (sprintItems.length > 0) {
            listContainer.createEl("div", { cls: "kaio-section-title" }).innerHTML = `<span style="color:#e74c3c">ğŸ”¥ çªå‡»å†²åˆº</span> <span>${sprintItems.length}</span>`;
            sprintItems.forEach(wrap => renderCard(listContainer, wrap));
        }
        if (calmItems.length > 0) {
            listContainer.createEl("div", { cls: "kaio-section-title" }).innerHTML = `<span style="color:#2ecc71">â˜• å¹³ç¨³æ¨è¿›</span> <span>${calmItems.length}</span>`;
            const groups = {};
            calmItems.forEach(wrap => { if (!groups[wrap.projectName]) groups[wrap.projectName] = []; groups[wrap.projectName].push(wrap); });
            Object.keys(groups).sort().forEach(projName => {
                const groupDiv = listContainer.createEl("div", { cls: "kaio-proj-group" });
                groupDiv.createEl("div", { text: `ğŸ“‚ ${projName}`, cls: "kaio-proj-name" });
                groups[projName].forEach(wrap => renderCard(groupDiv, wrap));
            });
        }
    };

    // ==========================================================
    // â±ï¸ Timeline æ—¶é—´è½´è§†å›¾
    // ==========================================================
    const renderTimelineView = async (container) => {
        // åŠ è½½ Timeline æ•°æ®
        const timelineData = await loadTimelineData();

        const style = `<style>
            .timeline-container { background: var(--background-secondary); border-radius: 12px; padding: 20px; font-family: sans-serif; min-height: 500px; }
            .timeline-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--interactive-accent); }
            .timeline-title { font-size: 1.5em; font-weight: 800; color: var(--text-normal); margin: 0; display: flex; align-items: center; gap: 8px; }
            .timeline-exit-btn { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; background: var(--background-modifier-border); color: var(--text-normal); transition: all 0.2s; }
            .timeline-exit-btn:hover { background: var(--interactive-accent); color: white; }
            .timeline-empty { text-align: center; padding: 60px 20px; color: var(--text-muted); font-size: 1.1em; }
            .timeline-empty-icon { font-size: 3em; margin-bottom: 15px; opacity: 0.5; }
            .timeline-list { display: flex; flex-direction: column; gap: 0; }
            .timeline-item { display: flex; gap: 15px; padding: 15px 0; border-bottom: 1px solid var(--background-modifier-border); position: relative; }
            .timeline-item:last-child { border-bottom: none; }
            .timeline-item::before { content: ''; position: absolute; left: -6px; top: 22px; width: 12px; height: 12px; border-radius: 50%; background: var(--interactive-accent); border: 2px solid var(--background-secondary); }
            .timeline-date-box { min-width: 80px; text-align: right; }
            .timeline-date { font-size: 1.1em; font-weight: 700; color: var(--text-normal); }
            .timeline-time { font-size: 0.8em; color: var(--text-muted); margin-top: 2px; }
            .timeline-content { flex: 1; }
            .timeline-path { font-size: 0.85em; color: var(--text-muted); margin-bottom: 6px; padding-left: 10px; border-left: 2px solid var(--interactive-accent); }
            .timeline-task { font-size: 1.1em; font-weight: 600; color: var(--text-normal); margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
            .timeline-tags { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; }
            .timeline-tag { padding: 2px 8px; border-radius: 12px; font-size: 0.8em; color: white; display: flex; align-items: center; gap: 4px; }
            .timeline-comment { font-size: 0.95em; color: var(--text-normal); padding: 10px 12px; background: var(--background-primary); border-radius: 8px; border-left: 3px solid var(--interactive-accent); }
            .timeline-stats { display: flex; gap: 20px; margin-bottom: 20px; padding: 15px; background: var(--background-primary); border-radius: 8px; }
            .timeline-stat { display: flex; align-items: center; gap: 8px; }
            .timeline-stat-num { font-size: 1.4em; font-weight: 700; color: var(--interactive-accent); }
            .timeline-stat-label { font-size: 0.9em; color: var(--text-muted); }
        </style>`;

        container.innerHTML = style;

        const wrapper = container.createEl("div", { cls: "timeline-container" });

        // å¤´éƒ¨
        const header = wrapper.createEl("div", { cls: "timeline-header" });
        header.createEl("div", { cls: "timeline-title" }).innerHTML = `â±ï¸ å®Œæˆäº‹é¡¹ Timeline`;
        const exitBtn = header.createEl("button", { text: "è¿”å›ä¸»ç•Œé¢", cls: "timeline-exit-btn" });
        exitBtn.onclick = () => { window.gtdTimelineMode = false; if (renderViewFn) renderViewFn(); };

        // ç»Ÿè®¡ä¿¡æ¯
        const totalCount = timelineData.length;
        const todayCount = timelineData.filter(l => l.date === moment().format("YYYY-MM-DD")).length;
        const weekCount = timelineData.filter(l => {
            const d = moment(l.date);
            return d.isAfter(moment().subtract(7, 'days'));
        }).length;

        const statsDiv = wrapper.createEl("div", { cls: "timeline-stats" });
        statsDiv.innerHTML = `
            <div class="timeline-stat"><span class="timeline-stat-num">${totalCount}</span><span class="timeline-stat-label">æ€»è®°å½•</span></div>
            <div class="timeline-stat"><span class="timeline-stat-num">${todayCount}</span><span class="timeline-stat-label">ä»Šæ—¥</span></div>
            <div class="timeline-stat"><span class="timeline-stat-num">${weekCount}</span><span class="timeline-stat-label">æœ¬å‘¨</span></div>
        `;

        // åˆ—è¡¨
        if (timelineData.length === 0) {
            const emptyDiv = wrapper.createEl("div", { cls: "timeline-empty" });
            emptyDiv.innerHTML = `<div class="timeline-empty-icon">ğŸ“­</div><div>æš‚æ— å®Œæˆè®°å½•</div><div style="font-size:0.9em;margin-top:8px;">å®Œæˆä»»åŠ¡æ—¶ä¼šè‡ªåŠ¨è®°å½•åˆ°è¿™é‡Œ</div>`;
            return;
        }

        const listContainer = wrapper.createEl("div", { cls: "timeline-list" });

        timelineData.forEach(log => {
            const item = listContainer.createEl("div", { cls: "timeline-item" });

            // æ—¥æœŸæ¡†
            const dateBox = item.createEl("div", { cls: "timeline-date-box" });
            dateBox.createEl("div", { text: log.date, cls: "timeline-date" });
            dateBox.createEl("div", { text: log.time, cls: "timeline-time" });

            // å†…å®¹
            const content = item.createEl("div", { cls: "timeline-content" });

            // å†’æ³¡å±‚çº§è·¯å¾„
            content.createEl("div", { text: log.projectPath, cls: "timeline-path" });

            // ä»»åŠ¡å
            const taskDiv = content.createEl("div", { cls: "timeline-task" });
            taskDiv.createEl("span", { text: log.taskTitle });

            // æ ‡ç­¾
            if (log.tagInfo && log.tagInfo.length > 0) {
                const tagsDiv = content.createEl("div", { cls: "timeline-tags" });
                log.tagInfo.forEach(tag => {
                    const tagEl = tagsDiv.createEl("span", { cls: "timeline-tag" });
                    tagEl.style.backgroundColor = tag.color;
                    tagEl.innerHTML = `${tag.icon} ${tag.label}`;
                });
            }

            // è¯„è¯­ï¼ˆä»…å½“æœ‰å†…å®¹æ—¶æ‰æ˜¾ç¤ºï¼‰
            if (log.comment) {
                content.createEl("div", { text: log.comment, cls: "timeline-comment" });
            }
        });
    };

    // ==========================================================
    // ğŸ·ï¸ æ ‡ç­¾ç®¡ç†è§†å›¾
    // ==========================================================
    const renderTagManagerView = (container) => {
        const style = `<style>
            .tag-mgr-container { background: var(--background-secondary); border-radius: 12px; padding: 20px; font-family: sans-serif; min-height: 500px; }
            .tag-mgr-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--interactive-accent); }
            .tag-mgr-title { font-size: 1.5em; font-weight: 800; color: var(--text-normal); margin: 0; display: flex; align-items: center; gap: 8px; }
            .tag-mgr-actions { display: flex; gap: 8px; }
            .tag-mgr-btn { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; transition: all 0.2s; }
            .tag-mgr-btn-primary { background: var(--interactive-accent); color: white; }
            .tag-mgr-btn-primary:hover { opacity: 0.9; transform: translateY(-1px); }
            .tag-mgr-btn-secondary { background: var(--background-modifier-border); color: var(--text-normal); }
            .tag-mgr-btn-secondary:hover { background: var(--background-modifier-hover); }
            .tag-tree { margin-top: 15px; }
            .tag-item { display: flex; align-items: center; padding: 10px 12px; margin: 4px 0; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 8px; cursor: grab; transition: all 0.2s; user-select: none; }
            .tag-item:hover { border-color: var(--interactive-accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
            .tag-item.is-category { background: linear-gradient(135deg, var(--background-primary) 0%, var(--background-secondary) 100%); border-width: 2px; }
            .tag-item.drag-over { border: 2px dashed var(--interactive-accent); background: rgba(var(--interactive-accent-rgb), 0.1); }
            .tag-item.dragging { opacity: 0.5; transform: scale(0.98); }
            .tag-icon { font-size: 1.3em; margin-right: 10px; width: 30px; text-align: center; }
            .tag-info { flex: 1; }
            .tag-label { font-weight: 600; color: var(--text-normal); }
            .tag-meta { font-size: 0.8em; color: var(--text-muted); margin-top: 2px; }
            .tag-color-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
            .tag-actions { display: flex; gap: 6px; opacity: 0; transition: opacity 0.2s; }
            .tag-item:hover .tag-actions { opacity: 1; }
            .tag-action-btn { padding: 4px 8px; border-radius: 4px; border: 1px solid var(--background-modifier-border); background: var(--background-secondary); cursor: pointer; font-size: 12px; }
            .tag-action-btn:hover { background: var(--interactive-accent); color: white; border-color: transparent; }
            .tag-action-btn.delete:hover { background: #e74c3c; }
            .tag-children { margin-left: 30px; border-left: 2px solid var(--background-modifier-border); padding-left: 10px; }
            .tag-drop-zone { height: 30px; border: 2px dashed transparent; border-radius: 6px; margin: 4px 0; transition: all 0.2s; display: flex; align-items: center; justify-content: center; color: var(--text-muted); font-size: 0.85em; }
            .tag-drop-zone.active { border-color: var(--interactive-accent); background: rgba(var(--interactive-accent-rgb), 0.05); }
            .tag-drop-zone.active::before { content: "æ‹–æ”¾åˆ°æ­¤å¤„è®¾ä¸ºé¡¶å±‚æ ‡ç­¾"; }
            .tag-form { background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-radius: 8px; padding: 15px; margin-bottom: 15px; }
            .tag-form-row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
            .tag-form-label { width: 60px; font-weight: 500; color: var(--text-muted); font-size: 0.9em; }
            .tag-form-input { flex: 1; padding: 8px 12px; border: 1px solid var(--background-modifier-border); border-radius: 6px; background: var(--background-secondary); color: var(--text-normal); font-size: 14px; }
            .tag-form-input:focus { outline: none; border-color: var(--interactive-accent); }
            .tag-parent-selector { position: relative; flex: 1; }
            .tag-parent-input-wrapper { display: flex; align-items: center; border: 1px solid var(--background-modifier-border); border-radius: 6px; background: var(--background-secondary); overflow: hidden; }
            .tag-parent-input-wrapper:focus-within { border-color: var(--interactive-accent); }
            .tag-parent-input { flex: 1; padding: 8px 12px; border: none; background: transparent; color: var(--text-normal); font-size: 14px; outline: none; }
            .tag-parent-clear { padding: 0 8px; cursor: pointer; color: var(--text-muted); }
            .tag-parent-clear:hover { color: var(--text-normal); }
            .tag-parent-dropdown { position: absolute; top: 100%; left: 0; right: 0; max-height: 260px; overflow-y: auto; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-top: none; border-radius: 0 0 6px 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; display: none; }
            .tag-parent-dropdown.visible { display: block; }
            .tag-parent-option { padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 13px; transition: background 0.1s; }
            .tag-parent-option:hover, .tag-parent-option.highlighted { background: var(--background-modifier-hover); }
            .tag-parent-option.selected { background: rgba(var(--interactive-accent-rgb), 0.1); color: var(--interactive-accent); }
            .tag-parent-empty { padding: 8px 12px; color: var(--text-faint); font-size: 12px; }
            .tag-parent-stats { padding: 6px 12px; font-size: 11px; color: var(--text-faint); border-top: 1px solid var(--background-modifier-border); background: var(--background-secondary); }
            .tag-form-checkbox { width: 18px; height: 18px; cursor: pointer; }
            .tag-stats { display: flex; gap: 20px; padding: 10px 15px; background: var(--background-primary); border-radius: 8px; margin-bottom: 15px; font-size: 0.9em; color: var(--text-muted); }
            .tag-stat-item { display: flex; align-items: center; gap: 6px; }
            .tag-stat-num { font-weight: 700; color: var(--text-normal); }
        </style>`;
        container.innerHTML = style;

        const wrapper = container.createEl("div", { cls: "tag-mgr-container" });

        // å¤´éƒ¨
        const header = wrapper.createEl("div", { cls: "tag-mgr-header" });
        header.createEl("div", { cls: "tag-mgr-title" }).innerHTML = `ğŸ·ï¸ æ ‡ç­¾ç®¡ç†å™¨`;
        const headerActions = header.createEl("div", { cls: "tag-mgr-actions" });
        const addTagBtn = headerActions.createEl("button", { text: "â• æ–°å»ºæ ‡ç­¾", cls: "tag-mgr-btn tag-mgr-btn-primary" });
        const addCategoryBtn = headerActions.createEl("button", { text: "ğŸ“ æ–°å»ºåˆ†ç±»", cls: "tag-mgr-btn tag-mgr-btn-secondary" });
        const exitBtn = headerActions.createEl("button", { text: "è¿”å›ä¸»ç•Œé¢", cls: "tag-mgr-btn tag-mgr-btn-secondary" });
        exitBtn.onclick = () => { window.gtdTagManagerMode = false; if (renderViewFn) renderViewFn(); };

        // ç»Ÿè®¡ä¿¡æ¯
        const topLevelCount = Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k].parentId === null).length;
        const categoryCount = Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k].isCategory).length;
        const leafCount = Object.keys(TAG_DEFINITIONS).filter(k => !TAG_DEFINITIONS[k].isCategory).length;
        const stats = wrapper.createEl("div", { cls: "tag-stats" });
        stats.innerHTML = `
            <div class="tag-stat-item">ğŸ“Š æ€»è®¡: <span class="tag-stat-num">${Object.keys(TAG_DEFINITIONS).length}</span> ä¸ªæ ‡ç­¾</div>
            <div class="tag-stat-item">ğŸ“ åˆ†ç±»: <span class="tag-stat-num">${categoryCount}</span></div>
            <div class="tag-stat-item">ğŸ·ï¸ å¶å­æ ‡ç­¾: <span class="tag-stat-num">${leafCount}</span></div>
            <div class="tag-stat-item">ğŸŒ² é¡¶å±‚: <span class="tag-stat-num">${topLevelCount}</span></div>
        `;

        // æ–°å»º/ç¼–è¾‘è¡¨å•ï¼ˆé»˜è®¤éšè—ï¼‰
        const formContainer = wrapper.createEl("div", { cls: "tag-form", attr: { style: "display:none;" } });
        let editingTagId = null;

        const showTagForm = (tagId = null) => {
            editingTagId = tagId;
            const tag = tagId ? TAG_DEFINITIONS[tagId] : null;
            formContainer.innerHTML = "";
            formContainer.style.display = "block";

            formContainer.createEl("div", { text: tagId ? "âœï¸ ç¼–è¾‘æ ‡ç­¾" : "â• æ–°å»ºæ ‡ç­¾", attr: { style: "font-weight:700; margin-bottom:12px; font-size:1.1em;" } });

            // IDï¼ˆæ–°å»ºæ—¶å¯ç¼–è¾‘ï¼Œç¼–è¾‘æ—¶ç¦ç”¨ï¼‰
            const idRow = formContainer.createEl("div", { cls: "tag-form-row" });
            idRow.createEl("span", { text: "ID:", cls: "tag-form-label" });
            const idInputAttr = tagId
                ? { placeholder: "å”¯ä¸€æ ‡è¯†ç¬¦ (è‹±æ–‡)", disabled: "true" }
                : { placeholder: "å”¯ä¸€æ ‡è¯†ç¬¦ (è‹±æ–‡)" };
            const idInput = idRow.createEl("input", { type: "text", cls: "tag-form-input", value: tagId || "", attr: idInputAttr });

            // åç§°
            const labelRow = formContainer.createEl("div", { cls: "tag-form-row" });
            labelRow.createEl("span", { text: "åç§°:", cls: "tag-form-label" });
            const labelInput = labelRow.createEl("input", { type: "text", cls: "tag-form-input", value: tag?.label || "", attr: { placeholder: "æ˜¾ç¤ºåç§°" } });

            // å›¾æ ‡
            const iconRow = formContainer.createEl("div", { cls: "tag-form-row" });
            iconRow.createEl("span", { text: "å›¾æ ‡:", cls: "tag-form-label" });
            const iconInput = iconRow.createEl("input", { type: "text", cls: "tag-form-input", value: tag?.icon || "ğŸ·ï¸", attr: { placeholder: "Emojiå›¾æ ‡" } });

            // é¢œè‰²
            const colorRow = formContainer.createEl("div", { cls: "tag-form-row" });
            colorRow.createEl("span", { text: "é¢œè‰²:", cls: "tag-form-label" });
            const colorInput = colorRow.createEl("input", { type: "color", cls: "tag-form-input", value: tag?.color || "#3498db", attr: { style: "width:60px; padding:2px;" } });

            // çˆ¶çº§
            const parentRow = formContainer.createEl("div", { cls: "tag-form-row" });
            parentRow.createEl("span", { text: "çˆ¶çº§:", cls: "tag-form-label" });
            const parentSelector = parentRow.createEl("div", { cls: "tag-parent-selector" });
            const parentInputWrapper = parentSelector.createEl("div", { cls: "tag-parent-input-wrapper" });
            const parentInput = parentInputWrapper.createEl("input", { type: "text", cls: "tag-parent-input", attr: { placeholder: "è¾“å…¥æ ‡ç­¾åç§°ç­›é€‰..." } });
            const parentClear = parentInputWrapper.createEl("span", { cls: "tag-parent-clear", text: "Ã—" });
            const parentDropdown = parentSelector.createEl("div", { cls: "tag-parent-dropdown" });

            const excluded = new Set();
            if (tagId) {
                excluded.add(tagId);
                getDescendantTagIds(tagId).forEach(id => excluded.add(id));
            }
            const availableParents = Object.keys(TAG_DEFINITIONS)
                .filter(k => !excluded.has(k))
                .map(k => ({ id: k, ...TAG_DEFINITIONS[k] }))
                .sort((a, b) => (a.label || '').localeCompare(b.label || '', 'zh-CN', { numeric: true, sensitivity: 'base' }));

            let selectedParentId = tag?.parentId || null;
            let highlightedIndex = -1;

            const updateInputDisplay = () => {
                if (selectedParentId) {
                    const def = TAG_DEFINITIONS[selectedParentId];
                    parentInput.value = def ? `${def.icon} ${def.label}` : "";
                } else {
                    parentInput.value = "";
                }
            };
            updateInputDisplay();

            const renderParentOptions = (query = "") => {
                parentDropdown.innerHTML = "";
                const q = query.trim().toLowerCase();
                const filtered = q
                    ? availableParents.filter(p =>
                        (p.label || "").toLowerCase().includes(q) ||
                        (p.id || "").toLowerCase().includes(q)
                      )
                    : availableParents;

                const topOpt = parentDropdown.createEl("div", {
                    cls: `tag-parent-option ${!selectedParentId ? "selected" : ""}`,
                    attr: { "data-value": "" }
                });
                topOpt.innerHTML = `<span>ğŸ </span><span>-- é¡¶å±‚æ ‡ç­¾ --</span>`;
                topOpt.onclick = () => {
                    selectedParentId = null;
                    updateInputDisplay();
                    parentDropdown.classList.remove("visible");
                    parentInput.blur();
                };

                if (filtered.length === 0) {
                    parentDropdown.createEl("div", { cls: "tag-parent-empty", text: "æ— åŒ¹é…çˆ¶çº§" });
                } else {
                    filtered.forEach((p, idx) => {
                        const opt = parentDropdown.createEl("div", {
                            cls: `tag-parent-option ${selectedParentId === p.id ? "selected" : ""} ${idx === highlightedIndex ? "highlighted" : ""}`,
                            attr: { "data-value": p.id }
                        });
                        opt.innerHTML = `<span>${p.icon}</span><span>${p.label}</span>`;
                        opt.onclick = () => {
                            selectedParentId = p.id;
                            updateInputDisplay();
                            parentDropdown.classList.remove("visible");
                            parentInput.blur();
                        };
                    });
                }

                const statsText = q
                    ? `æ˜¾ç¤º ${filtered.length}/${availableParents.length} ä¸ªå¯é€‰çˆ¶çº§`
                    : `å…± ${availableParents.length} ä¸ªå¯é€‰çˆ¶çº§`;
                parentDropdown.createEl("div", { cls: "tag-parent-stats", text: statsText });
                highlightedIndex = -1;
            };

            const showParentDropdown = () => {
                renderParentOptions(parentInput.value);
                parentDropdown.classList.add("visible");
            };
            const hideParentDropdown = () => {
                setTimeout(() => parentDropdown.classList.remove("visible"), 150);
            };

            parentInput.addEventListener("focus", showParentDropdown);
            parentInput.addEventListener("blur", hideParentDropdown);
            parentInput.addEventListener("input", () => {
                highlightedIndex = -1;
                showParentDropdown();
            });
            parentInput.addEventListener("keydown", (e) => {
                const options = parentDropdown.querySelectorAll(".tag-parent-option");
                if (options.length === 0) return;
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    highlightedIndex = Math.min(highlightedIndex + 1, options.length - 1);
                    options.forEach((opt, i) => opt.classList.toggle("highlighted", i === highlightedIndex));
                    if (options[highlightedIndex]) options[highlightedIndex].scrollIntoView({ block: "nearest" });
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    highlightedIndex = Math.max(highlightedIndex - 1, 0);
                    options.forEach((opt, i) => opt.classList.toggle("highlighted", i === highlightedIndex));
                    if (options[highlightedIndex]) options[highlightedIndex].scrollIntoView({ block: "nearest" });
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    if (highlightedIndex >= 0 && options[highlightedIndex]) {
                        options[highlightedIndex].click();
                    } else if (options[0]) {
                        options[0].click();
                    }
                } else if (e.key === "Escape") {
                    parentDropdown.classList.remove("visible");
                    parentInput.blur();
                }
            });

            parentClear.onclick = (e) => {
                e.stopPropagation();
                selectedParentId = null;
                updateInputDisplay();
                parentInput.focus();
            };

            // æ˜¯å¦ä¸ºåˆ†ç±»
            const categoryRow = formContainer.createEl("div", { cls: "tag-form-row" });
            categoryRow.createEl("span", { text: "åˆ†ç±»:", cls: "tag-form-label" });
            const categoryCheck = categoryRow.createEl("input", { type: "checkbox", cls: "tag-form-checkbox" });
            categoryCheck.checked = tag?.isCategory || false;
            categoryRow.createEl("span", { text: "è®¾ä¸ºåˆ†ç±»ï¼ˆåªèƒ½åŒ…å«å­æ ‡ç­¾ï¼Œä¸èƒ½ç›´æ¥æ ‡è®°æ¡ç›®ï¼‰", attr: { style: "color:var(--text-muted); font-size:0.85em; margin-left:8px;" } });

            // æŒ‰é’®
            const btnRow = formContainer.createEl("div", { cls: "tag-form-row", attr: { style: "justify-content:flex-end; margin-top:15px;" } });
            const cancelBtn = btnRow.createEl("button", { text: "å–æ¶ˆ", cls: "tag-mgr-btn tag-mgr-btn-secondary" });
            cancelBtn.onclick = () => { formContainer.style.display = "none"; };
            const saveBtn = btnRow.createEl("button", { text: tagId ? "ä¿å­˜ä¿®æ”¹" : "åˆ›å»ºæ ‡ç­¾", cls: "tag-mgr-btn tag-mgr-btn-primary" });
            saveBtn.onclick = async () => {
                const newId = idInput.value.trim();
                if (!newId) { new Notice("âš ï¸ è¯·è¾“å…¥æ ‡ç­¾ID"); return; }
                if (!labelInput.value.trim()) { new Notice("âš ï¸ è¯·è¾“å…¥æ ‡ç­¾åç§°"); return; }
                if (!tagId && TAG_DEFINITIONS[newId]) { new Notice("âš ï¸ è¯¥IDå·²å­˜åœ¨"); return; }

                TAG_DEFINITIONS[newId] = {
                    label: labelInput.value.trim(),
                    icon: iconInput.value.trim() || "ğŸ·ï¸",
                    color: colorInput.value,
                    parentId: selectedParentId || null,
                    isCategory: categoryCheck.checked,
                    order: tag?.order || Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k].parentId === (selectedParentId || null)).length
                };

                if (tagId && tagId !== newId) {
                    // IDå˜æ›´ï¼Œéœ€è¦æ›´æ–°æ‰€æœ‰å­æ ‡ç­¾çš„parentId
                    Object.keys(TAG_DEFINITIONS).forEach(k => {
                        if (TAG_DEFINITIONS[k].parentId === tagId) TAG_DEFINITIONS[k].parentId = newId;
                    });
                    delete TAG_DEFINITIONS[tagId];
                }

                await saveTagDefinitions(TAG_DEFINITIONS);
                new Notice(tagId ? "âœ… æ ‡ç­¾å·²æ›´æ–°" : "âœ… æ ‡ç­¾å·²åˆ›å»º");
                formContainer.style.display = "none";
                if (renderViewFn) renderViewFn();
            };
        };

        addTagBtn.onclick = () => showTagForm(null);
        addCategoryBtn.onclick = () => {
            showTagForm(null);
            setTimeout(() => {
                const checkbox = formContainer.querySelector('input[type="checkbox"]');
                if (checkbox) checkbox.checked = true;
            }, 50);
        };

        // æ ‡ç­¾æ ‘
        const treeContainer = wrapper.createEl("div", { cls: "tag-tree" });

        // é¡¶å±‚æ‹–æ”¾åŒº
        const topDropZone = treeContainer.createEl("div", { cls: "tag-drop-zone" });
        topDropZone.addEventListener("dragover", (e) => { e.preventDefault(); topDropZone.classList.add("active"); });
        topDropZone.addEventListener("dragleave", () => { topDropZone.classList.remove("active"); });
        topDropZone.addEventListener("drop", async (e) => {
            e.preventDefault();
            topDropZone.classList.remove("active");
            const draggedId = window.gtdCurrentDragTagId;
            if (draggedId && TAG_DEFINITIONS[draggedId]) {
                TAG_DEFINITIONS[draggedId].parentId = null;
                await saveTagDefinitions(TAG_DEFINITIONS);
                new Notice("âœ… å·²ç§»åŠ¨åˆ°é¡¶å±‚");
                if (renderViewFn) renderViewFn();
            }
        });

        // é€’å½’æ¸²æŸ“æ ‡ç­¾æ ‘
        const renderTagTree = (parentId, container, level = 0) => {
            const children = Object.keys(TAG_DEFINITIONS)
                .filter(k => TAG_DEFINITIONS[k].parentId === parentId)
                .sort((a, b) => (TAG_DEFINITIONS[a].order || 0) - (TAG_DEFINITIONS[b].order || 0));

            children.forEach(tagId => {
                const def = TAG_DEFINITIONS[tagId];
                const item = container.createEl("div", {
                    cls: `tag-item ${def.isCategory ? 'is-category' : ''}`,
                    attr: { draggable: "true", "data-tag-id": tagId }
                });

                // æ‹–æ‹½äº‹ä»¶
                item.addEventListener("dragstart", (e) => {
                    window.gtdCurrentDragTagId = tagId;
                    item.classList.add("dragging");
                    e.dataTransfer.effectAllowed = "move";
                });
                item.addEventListener("dragend", () => {
                    window.gtdCurrentDragTagId = null;
                    item.classList.remove("dragging");
                });
                item.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    if (window.gtdCurrentDragTagId && window.gtdCurrentDragTagId !== tagId) {
                        item.classList.add("drag-over");
                    }
                });
                item.addEventListener("dragleave", () => { item.classList.remove("drag-over"); });
                item.addEventListener("drop", async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    item.classList.remove("drag-over");
                    const draggedId = window.gtdCurrentDragTagId;
                    if (draggedId && draggedId !== tagId && TAG_DEFINITIONS[draggedId]) {
                        // æ£€æŸ¥æ˜¯å¦ä¼šé€ æˆå¾ªç¯å¼•ç”¨
                        let current = tagId;
                        while (current) {
                            if (current === draggedId) {
                                new Notice("âš ï¸ ä¸èƒ½å°†çˆ¶æ ‡ç­¾æ‹–å…¥å…¶å­æ ‡ç­¾");
                                return;
                            }
                            current = TAG_DEFINITIONS[current]?.parentId;
                        }
                        TAG_DEFINITIONS[draggedId].parentId = tagId;
                        await saveTagDefinitions(TAG_DEFINITIONS);
                        new Notice(`âœ… å·²ç§»åŠ¨åˆ° "${def.label}" ä¸‹`);
                        if (renderViewFn) renderViewFn();
                    }
                });

                // é¢œè‰²ç‚¹
                const colorDot = item.createEl("div", { cls: "tag-color-dot" });
                colorDot.style.backgroundColor = def.color;

                // å›¾æ ‡
                item.createEl("span", { text: def.icon, cls: "tag-icon" });

                // ä¿¡æ¯
                const info = item.createEl("div", { cls: "tag-info" });
                info.createEl("div", { text: def.label, cls: "tag-label" });
                const childCount = Object.keys(TAG_DEFINITIONS).filter(k => TAG_DEFINITIONS[k].parentId === tagId).length;
                const usageCount = gtdList.filter(i => i.tags && i.tags.includes(tagId)).length;
                info.createEl("div", {
                    cls: "tag-meta",
                    text: `ID: ${tagId} | ${def.isCategory ? 'ğŸ“ åˆ†ç±»' : 'ğŸ·ï¸ æ ‡ç­¾'} | å­çº§: ${childCount} | ä½¿ç”¨: ${usageCount}æ¬¡`
                });

                // æ“ä½œæŒ‰é’®
                const actions = item.createEl("div", { cls: "tag-actions" });
                const editBtn = actions.createEl("button", { text: "âœï¸", cls: "tag-action-btn", title: "ç¼–è¾‘" });
                editBtn.onclick = (e) => { e.stopPropagation(); showTagForm(tagId); };
                const deleteBtn = actions.createEl("button", { text: "ğŸ—‘ï¸", cls: "tag-action-btn delete", title: "åˆ é™¤" });
                deleteBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (childCount > 0) {
                        new Notice("âš ï¸ è¯·å…ˆåˆ é™¤æˆ–ç§»åŠ¨è¯¥æ ‡ç­¾ä¸‹çš„å­æ ‡ç­¾");
                        return;
                    }
                    if (usageCount > 0) {
                        new Notice(`âš ï¸ è¯¥æ ‡ç­¾æ­£åœ¨è¢« ${usageCount} ä¸ªæ¡ç›®ä½¿ç”¨ï¼Œè¯·å…ˆç§»é™¤`);
                        return;
                    }
                    delete TAG_DEFINITIONS[tagId];
                    await saveTagDefinitions(TAG_DEFINITIONS);
                    new Notice("ğŸ—‘ï¸ æ ‡ç­¾å·²åˆ é™¤");
                    if (renderViewFn) renderViewFn();
                };

                // å­æ ‡ç­¾å®¹å™¨
                const hasChildren = Object.keys(TAG_DEFINITIONS).some(k => TAG_DEFINITIONS[k].parentId === tagId);
                if (hasChildren) {
                    const childrenContainer = container.createEl("div", { cls: "tag-children" });
                    renderTagTree(tagId, childrenContainer, level + 1);
                }
            });
        };

        renderTagTree(null, treeContainer, 0);

        // æç¤ºä¿¡æ¯
        if (Object.keys(TAG_DEFINITIONS).length === 0) {
            treeContainer.createEl("div", {
                text: "æš‚æ— æ ‡ç­¾ï¼Œç‚¹å‡»ä¸Šæ–¹æŒ‰é’®åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªæ ‡ç­¾ï¼",
                attr: { style: "text-align:center; padding:40px; color:var(--text-muted);" }
            });
        }

        wrapper.createEl("div", {
            attr: { style: "margin-top:20px; padding:12px; background:var(--background-primary); border-radius:8px; font-size:0.85em; color:var(--text-muted);" }
        }).innerHTML = `
            <strong>ğŸ’¡ ä½¿ç”¨æç¤ºï¼š</strong><br>
            â€¢ æ‹–æ‹½æ ‡ç­¾å¯ä»¥è°ƒæ•´å±‚çº§å…³ç³»ï¼ˆæ‹–åˆ°å¦ä¸€ä¸ªæ ‡ç­¾ä¸Šè®¾ä¸ºå­æ ‡ç­¾ï¼Œæ‹–åˆ°é¡¶éƒ¨åŒºåŸŸè®¾ä¸ºé¡¶å±‚ï¼‰<br>
            â€¢ åˆ†ç±»æ ‡ç­¾åªèƒ½åŒ…å«å­æ ‡ç­¾ï¼Œä¸èƒ½ç›´æ¥ç”¨äºæ ‡è®°ä»»åŠ¡æ¡ç›®<br>
            â€¢ åˆ é™¤æ ‡ç­¾å‰éœ€è¦å…ˆç§»é™¤å…¶å­æ ‡ç­¾å’Œä½¿ç”¨è¯¥æ ‡ç­¾çš„æ¡ç›®
        `;
    };

    const renderNormalView = () => {
        dv.container.innerHTML = "";
        if (!gtdList) { dv.paragraph(`â³ è¯»å–æ•°æ®ä¸­...`); return; }

        const getDisplayName = (item) => item.type === 'project' ? (item.project || "æœªå‘½å") : (item.content || "æœªå‘½å");
        const nameSort = (a, b) => getDisplayName(a.item).localeCompare(getDisplayName(b.item), "zh"); 
        const scheduleSort = (a, b) => {
            const d1 = a.item.scheduled || "9999-99-99";
            const d2 = b.item.scheduled || "9999-99-99";
            if (d1 !== d2) return d1.localeCompare(d2);
            const p1 = a.item.project || "";
            const p2 = b.item.project || "";
            if (p1 !== p2) return p1.localeCompare(p2, "zh");
            return getDisplayName(a.item).localeCompare(getDisplayName(b.item), "zh");
        };
        
        const containerStyle = "margin-bottom: 20px; padding: 15px; border: 1px solid var(--background-modifier-border); border-radius: 8px; background-color: var(--background-primary-alt);";
        const headerStyle = "margin: 0 0 10px 0; font-size: 1.1em; font-weight: bold; color: var(--text-normal); border-bottom: 2px solid var(--interactive-accent); padding-bottom: 5px; display:flex; justify-content:space-between; align-items:center;";
        const btnStyle = "background-color: var(--interactive-accent); color: var(--text-on-accent); padding: 6px 16px; font-weight: bold; cursor: pointer; border-radius: 6px; border: none; font-size: 13px; margin-right: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);";

        dv.container.createEl("style", { text: `
            .gtd-item-line { user-select: none; }
            .drag-over-top { border-top: 3px solid #2ecc71 !important; }
            .drag-over-bottom { border-bottom: 3px solid #2ecc71 !important; }
            .drag-over-child { background-color: rgba(46, 204, 113, 0.2) !important; border-left: 3px solid #2ecc71 !important; }
            .drag-over-project { background-color: rgba(46, 204, 113, 0.3) !important; border: 2px dashed #2ecc71 !important; border-radius: 6px; }
            .is-dragging { opacity: 0.4; background: var(--background-modifier-hover); transform: scale(0.99); }
            .completed-line { opacity: 0.9; }
            .ghost-line { opacity: 0.5; font-style: italic; pointer-events: none; }
            .proj-nav-drop-root { border: 1px dashed var(--background-modifier-border); border-radius: 6px; padding: 6px 10px; margin-bottom: 8px; color: var(--text-muted); font-size: 0.85em; text-align: center; transition: all 0.2s; }
            .proj-nav-drop-root.drag-over { border-color: #2ecc71; background: rgba(46, 204, 113, 0.15); color: var(--text-normal); }
            .proj-nav-row { display: flex; align-items: center; gap: 2px; border-radius: 6px; padding: 1px 2px; transition: background 0.2s; }
            .proj-nav-row.drag-over { background: rgba(46, 204, 113, 0.18); outline: 1px dashed #2ecc71; }
            .proj-nav-row.is-dragging { opacity: 0.45; }
            .proj-nav-toggle { width: 16px; text-align: center; color: var(--text-muted); cursor: pointer; user-select: none; font-size: 11px; }
            .proj-nav-toggle.spacer { opacity: 0.35; cursor: default; }
            .proj-nav-tag { cursor: pointer; font-size: 0.9em; display:block; background: transparent; padding: 4px 8px; margin-bottom: 2px; border-radius: 4px; color: var(--text-muted); transition: all 0.2s; border: 1px solid transparent; user-select: none; flex: 1; }
            .proj-nav-tag:hover { color: var(--interactive-accent); border-color: var(--background-modifier-border); background: var(--background-primary); }
            .gtd-section-nav { position: fixed; right: 18px; bottom: 18px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; padding: 10px; border-radius: 18px; border: 1px solid var(--background-modifier-border); background: var(--background-secondary); box-shadow: 0 8px 24px rgba(0,0,0,0.2); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); min-width: 128px; }
            .gtd-section-nav-title { font-size: 11px; font-weight: 600; color: var(--text-muted); text-align: center; letter-spacing: 0.2px; }
            .gtd-section-nav-row { display: flex; flex-direction: column; gap: 6px; }
            .gtd-section-nav-btn { padding: 4px 10px; border-radius: 14px; border: 1px solid var(--background-modifier-border); cursor: pointer; font-size: 12px; background: var(--background-primary); color: var(--text-normal); transition: all 0.2s; white-space: nowrap; text-align: left; }
            .gtd-section-nav-btn:hover { border-color: var(--interactive-accent); color: var(--interactive-accent); transform: translateY(-1px); }
            .gtd-section-nav-btn.top { background: var(--interactive-accent); color: var(--text-on-accent); border-color: transparent; }
            .gtd-section-nav-btn.top:hover { color: var(--text-on-accent); filter: brightness(1.06); }
            @media (max-width: 768px) {
                .gtd-section-nav { right: 10px; bottom: 10px; padding: 8px; border-radius: 14px; }
                .gtd-section-nav-btn { font-size: 11px; padding: 4px 8px; }
            }
            @keyframes highlight-pulse { 0% { background-color: rgba(255, 235, 59, 0.4); } 50% { background-color: rgba(255, 235, 59, 0.2); } 100% { background-color: transparent; } }
            .highlight-target { animation: highlight-pulse 1.5s ease-out; border-radius: 8px; }
            .tag-pill { display: inline-flex; align-items: center; gap: 4px; padding: 0px 6px; border-radius: 10px; font-size: 0.75em; margin-left: 6px; font-weight: 500; color: white; opacity: 0.9; vertical-align: middle; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
            .tag-filter-btn { padding: 4px 10px; border-radius: 12px; border: 1px solid var(--background-modifier-border); cursor: pointer; font-size: 12px; background: transparent; transition: all 0.2s; display: flex; align-items: center; gap: 4px; }
            .tag-filter-btn.active { color: white; border-color: transparent; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
            .tag-filter-btn:hover { background: var(--background-modifier-hover); }
            .tag-category-group { display: flex; flex-direction: column; gap: 4px; padding: 6px 8px; border-radius: 8px; background: var(--background-secondary); border: 1px solid var(--background-modifier-border); margin-left: 6px; }
            .tag-category-header { display: flex; align-items: center; gap: 4px; }
            .tag-category-label { font-size: 13px; cursor: pointer; padding: 2px 6px; border-radius: 10px; transition: all 0.2s; font-weight: 600; }
            .tag-category-label:hover { background: var(--background-modifier-hover); }
            .tag-category-label.active { color: white; }
            .tag-children-group { display: flex; gap: 4px; flex-wrap: wrap; padding-left: 12px; border-left: 2px solid var(--background-modifier-border); margin-left: 8px; margin-top: 4px; }
        `});

        const topAnchor = dv.el("div", "", { attr: { id: "gtd-top-anchor", style: "height:0;" } });

        const controlContainer = dv.el("div", "", { attr: { style: "display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px;" } });
        const leftBtns = controlContainer.createEl("div");
        const createMainBtn = (text, onClick, style = btnStyle) => { const btn = leftBtns.createEl("button", { text: text, attr: { style: style } }); btn.onclick = onClick; return btn; };
        createMainBtn("ğŸ“¥ æ·»åŠ åˆ°å·¥ä½œç¯®", () => addNewItem('inbox')); createMainBtn("ğŸ“‚ åˆ›å»ºæ–°é¡¹ç›®", () => addNewItem('project')); createMainBtn("âš¡ æ·»åŠ ä¸‹ä¸€æ­¥è¡ŒåŠ¨", () => addNewItem('next_action'));
        
        const kaioBtnStyle = "background-color: #c0392b; color: white; padding: 6px 16px; font-weight: bold; cursor: pointer; border-radius: 6px; border: none; font-size: 13px; margin-right: 10px; box-shadow: 0 0 10px rgba(192, 57, 43, 0.4); animation: pulse 2s infinite;";
        controlContainer.createEl("style", { text: "@keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(192, 57, 43, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(192, 57, 43, 0); } 100% { box-shadow: 0 0 0 0 rgba(192, 57, 43, 0); } }" });
        createMainBtn("ğŸ”¥ ç•Œç‹æ‹³æ¨¡å¼", () => { window.gtdKaioKenMode = true; if(renderViewFn) renderViewFn(); }, kaioBtnStyle);

        const tagMgrBtnStyle = "background-color: #9b59b6; color: white; padding: 6px 16px; font-weight: bold; cursor: pointer; border-radius: 6px; border: none; font-size: 13px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);";
        createMainBtn("ğŸ·ï¸ æ ‡ç­¾ç®¡ç†", () => { window.gtdTagManagerMode = true; if(renderViewFn) renderViewFn(); }, tagMgrBtnStyle);

        const timelineBtnStyle = "background-color: #2980b9; color: white; padding: 6px 16px; font-weight: bold; cursor: pointer; border-radius: 6px; border: none; font-size: 13px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);";
        createMainBtn("â±ï¸ Timeline", () => { window.gtdTimelineMode = true; if(renderViewFn) renderViewFn(); }, timelineBtnStyle);

        const rightBtns = controlContainer.createEl("div", { attr: { style: "display:flex; flex-direction:column; align-items:flex-end; gap:8px;" } });
        
        const mainFilterRow = rightBtns.createEl("div", { attr: { style: "display:flex; gap:8px;" } });
        const toggleFirstBtn = mainFilterRow.createEl("button", { text: window.gtdShowOnlyFirstClass ? "â­ åªçœ‹ç²¾é€‰" : "ğŸ‘ï¸ æ˜¾ç¤ºå…¨éƒ¨", attr: { style: `padding: 6px 12px; border-radius: 6px; border: 1px solid var(--text-muted); cursor: pointer; background: ${window.gtdShowOnlyFirstClass ? 'var(--background-modifier-active-hover)' : 'transparent'}; color: var(--text-normal);` } });
        toggleFirstBtn.onclick = () => { window.gtdShowOnlyFirstClass = !window.gtdShowOnlyFirstClass; window.gtdRecentIds = []; if(renderViewFn) renderViewFn(); };
        const toggleFocusBtn = mainFilterRow.createEl("button", { text: window.gtdShowOnlyFocus ? "ğŸ¯ æœ¬æ¬¡æ‰§è¡Œ" : "ğŸ¯ åŠ å…¥æ‰§è¡Œ", attr: { style: `padding: 6px 12px; border-radius: 6px; border: 1px solid var(--text-muted); cursor: pointer; background: ${window.gtdShowOnlyFocus ? '#e91e63' : 'transparent'}; color: ${window.gtdShowOnlyFocus ? 'white' : 'var(--text-normal)'};` } });
        toggleFocusBtn.onclick = (e) => { window.gtdShowOnlyFocus = !window.gtdShowOnlyFocus; window.gtdRecentIds = []; if(renderViewFn) renderViewFn(); };

        const tagFilterRow = rightBtns.createEl("div", { attr: { style: "display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; align-items:center;" } });

        const allTagBtn = tagFilterRow.createEl("div", { cls: `tag-filter-btn ${window.gtdTagFilter === null ? 'active' : ''}`, text: "All" });
        if (window.gtdTagFilter === null) allTagBtn.style.background = "var(--interactive-normal)";
        allTagBtn.onclick = () => { window.gtdTagFilter = null; if(renderViewFn) renderViewFn(); };

        // [ä¼˜åŒ–] åµŒå¥—å±‚çº§æ ‡ç­¾ç­›é€‰å™¨ï¼šæœ‰å­æ ‡ç­¾çš„éƒ½å±•å¼€åˆ°ä¸‹ä¸€è¡Œæ˜¾ç¤º
        const renderNestedTagFilter = (parentId, container) => {
            const children = getChildTags(parentId).sort((a, b) => (TAG_DEFINITIONS[a].order || 0) - (TAG_DEFINITIONS[b].order || 0));
            if (children.length === 0) return;

            children.forEach(key => {
                const def = TAG_DEFINITIONS[key];
                const isActive = window.gtdTagFilter === key;
                const subChildren = getChildTags(key);
                const hasSubChildren = subChildren.length > 0;

                if (hasSubChildren) {
                    // [ç»Ÿä¸€å¤„ç†] æœ‰å­æ ‡ç­¾çš„ï¼šæ— è®ºæ˜¯åˆ†ç±»è¿˜æ˜¯æ™®é€šæ ‡ç­¾ï¼Œéƒ½é‡‡ç”¨å‚ç›´å¸ƒå±€
                    const groupWrapper = container.createEl("div", { cls: "tag-category-group" });
                    groupWrapper.style.borderColor = def.color;

                    // çˆ¶æ ‡ç­¾/åˆ†ç±»æ ‡é¢˜è¡Œ
                    const headerRow = groupWrapper.createEl("div", { cls: "tag-category-header" });
                    const parentLabel = headerRow.createEl("span", {
                        text: `${def.icon} ${def.label}`,
                        cls: `tag-category-label ${isActive ? 'active' : ''}`,
                        attr: { title: def.isCategory
                            ? `ğŸ“ åˆ†ç±»ï¼šç‚¹å‡»ç­›é€‰ã€Œ${def.label}ã€ä¸‹æ‰€æœ‰å­æ ‡ç­¾`
                            : `ğŸ·ï¸ æ ‡ç­¾ï¼šç‚¹å‡»ç­›é€‰ã€Œ${def.label}ã€åŠå…¶å­æ ‡ç­¾` }
                    });
                    if (isActive) parentLabel.style.backgroundColor = def.color;
                    parentLabel.onclick = () => {
                        window.gtdTagFilter = (window.gtdTagFilter === key) ? null : key;
                        if(renderViewFn) renderViewFn();
                    };

                    // å­æ ‡ç­¾å®¹å™¨ï¼ˆæ–°è¡Œæ˜¾ç¤ºï¼Œå¸¦å·¦è¾¹çº¿è¡¨ç¤ºå±‚çº§å…³ç³»ï¼‰
                    const childContainer = groupWrapper.createEl("div", { cls: "tag-children-group" });
                    childContainer.style.borderColor = def.color + "80";

                    // é€’å½’æ¸²æŸ“å­æ ‡ç­¾
                    renderNestedTagFilter(key, childContainer);
                } else {
                    // å¶å­æ ‡ç­¾ï¼ˆæ— å­çº§ï¼‰ï¼šæ¸²æŸ“ä¸ºæ™®é€šæŒ‰é’®
                    const btn = container.createEl("div", { cls: `tag-filter-btn ${isActive ? 'active' : ''}` });
                    btn.innerHTML = `<span>${def.icon}</span> ${def.label}`;
                    if (isActive) btn.style.backgroundColor = def.color;
                    btn.onclick = () => {
                        window.gtdTagFilter = (window.gtdTagFilter === key) ? null : key;
                        if(renderViewFn) renderViewFn();
                    };
                }
            });
        };
        renderNestedTagFilter(null, tagFilterRow);

        const sectionNav = dv.el("div", "", { cls: "gtd-section-nav" });
        sectionNav.createEl("div", { text: "GTD çµåŠ¨å¯¼èˆª", cls: "gtd-section-nav-title" });
        const sectionNavRow = sectionNav.createEl("div", { cls: "gtd-section-nav-row" });
        const jumpToSection = (sectionId) => {
            const target = dv.container.querySelector(`#${sectionId}`);
            if (!target) { new Notice("å®šä½å¤±è´¥ï¼šç›®æ ‡æ¨¡å—ä¸å­˜åœ¨"); return; }
            target.scrollIntoView({ behavior: "smooth", block: "start" });
            target.classList.add("highlight-target");
            setTimeout(() => target.classList.remove("highlight-target"), 1200);
        };
        const createSectionNavBtn = (parent, text, sectionId, extraCls = "") => {
            const btn = parent.createEl("button", { text, cls: `gtd-section-nav-btn ${extraCls}`.trim() });
            btn.onclick = () => jumpToSection(sectionId);
        };
        createSectionNavBtn(sectionNavRow, "ğŸ“¥ å·¥ä½œç¯®", "gtd-section-inbox");
        createSectionNavBtn(sectionNavRow, "âš¡ å¿«é€Ÿå¯¼èˆª", "gtd-section-quick-nav");
        createSectionNavBtn(sectionNavRow, "ğŸ“… æ—¥ç¨‹", "gtd-section-schedule");
        createSectionNavBtn(sectionNavRow, "ğŸ“‚ é¡¹ç›®æ¸…å•", "gtd-section-projects");
        createSectionNavBtn(sectionNavRow, "â¬† å›åˆ°é¡¶éƒ¨", "gtd-top-anchor", "top");


        const filterFn = (item) => {
            let visible = true;
            if (window.gtdShowOnlyFirstClass && item.isFirstClass !== true && !window.gtdRecentIds.includes(item.id)) visible = false;
            return visible;
        };

        const renderItemLine = (container, item, originalIndex, isCompleted = false, showProjectContext = false, level = 0, draggable = false, isGhost = false) => {
            const marginLeft = level * 30 + "px";
            const isChild = level > 0;
            const borderStyle = isChild ? (isGhost ? `2px dashed rgba(var(--text-muted-rgb), 0.3)` : `2px solid rgba(var(--interactive-accent-rgb), 0.5)`) : 'none';
            const bgStyle = isGhost ? `background-color: transparent;` : (isChild ? `background-color: rgba(var(--mono-rgb-100), 0.03);` : ''); 
            const fontStyle = isChild ? `font-size: 0.95em;` : `font-weight: 500;`; 
            const completedClass = isCompleted ? "completed-line" : (isGhost ? "ghost-line" : "");

            const line = container.createEl("div", { 
                cls: `gtd-item-line ${completedClass}`, 
                attr: { 
                    style: `display: flex; align-items: center; margin-bottom: 4px; padding: 6px 0; margin-left: ${marginLeft}; border-left: ${borderStyle}; padding-left: ${isChild?'10px':'0'}; border-radius: 4px; transition: background 0.2s; ${bgStyle} ${fontStyle}` 
                } 
            });

            if (draggable && !isCompleted && !isGhost && (item.type === 'next_action' || item.type === 'inbox')) {
                line.draggable = true;
                line.addEventListener("dragstart", (e) => { e.stopPropagation(); window.gtdCurrentDragId = item.id; e.dataTransfer.effectAllowed = "move"; e.dataTransfer.setData("text/plain", item.id); setTimeout(() => line.classList.add("is-dragging"), 0); });
                line.addEventListener("dragend", (e) => { e.stopPropagation(); window.gtdCurrentDragId = null; line.classList.remove("is-dragging"); });
                line.addEventListener("dragover", (e) => {
                    e.preventDefault(); e.stopPropagation();
                    if (window.gtdCurrentDragId === item.id) return;
                    const rect = line.getBoundingClientRect();
                    line.classList.remove("drag-over-top", "drag-over-bottom", "drag-over-child");
                    if ((e.clientX - rect.left) > 40) line.classList.add("drag-over-child");
                    else if ((e.clientY - rect.top) < rect.height / 2) line.classList.add("drag-over-top");
                    else line.classList.add("drag-over-bottom");
                });
                line.addEventListener("dragleave", (e) => { e.stopPropagation(); line.classList.remove("drag-over-top", "drag-over-bottom", "drag-over-child"); });
                line.addEventListener("drop", async (e) => {
                    e.preventDefault(); e.stopPropagation();
                    line.classList.remove("drag-over-top", "drag-over-bottom", "drag-over-child");
                    const draggedId = window.gtdCurrentDragId;
                    const rect = line.getBoundingClientRect();
                    let position = 'after';
                    if ((e.clientX - rect.left) > 40) position = 'child';
                    else if ((e.clientY - rect.top) < rect.height / 2) position = 'before';
                    await handleDrop(draggedId, item.id, position, 'task');
                });
            }

            const actionContainer = line.createEl("span", { attr: { style: "display: inline-flex; align-items: center; gap: 8px; margin-right: 10px; min-width: 100px;" } });
            
            const hasActiveChildren = checkSubtasks(item.id);
            if (!isGhost && hasActiveChildren) {
                const arrowBtn = actionContainer.createEl("span", { 
                    text: item.isCollapsed ? "â–¶" : "â–¼", 
                    attr: { style: "cursor: pointer; font-size: 12px; width: 14px; color: var(--text-muted);" } 
                });
                arrowBtn.onclick = (e) => { e.stopPropagation(); toggleCollapse(originalIndex); };
            }

            if (isChild) {
                actionContainer.createEl("span", { text: "â””â”€", attr: { style: `color: ${isGhost ? 'var(--text-faint)' : 'var(--text-faint)'}; font-family: monospace; font-size: 1.1em; line-height: 1; margin-right: -4px;` } });
            }

            const displayText = getDisplayName(item);
            const targetFile = app.metadataCache.getFirstLinkpathDest(displayText, dv.current().file.path);
            const fileExists = targetFile !== null;

            if (isGhost) {
                actionContainer.createEl("span", { text: "âš°ï¸", attr: { title: "æœªå®Œæˆçš„çˆ¶çº§å®¹å™¨" } });
            } else if (isCompleted) {
                const reactivateBtn = actionContainer.createEl("span", { text: "â†©ï¸", attr: { style: "cursor: pointer; font-size: 14px; color: var(--text-warning);" }, title: "å›é€€" });
                if(originalIndex !== -1) reactivateBtn.onclick = (e) => { e.stopPropagation(); item.type === 'project' ? reactivateProject(originalIndex, item.project) : reactivateItem(originalIndex); };
                actionContainer.createEl("span", { text: "âœ…", attr: { style: "margin-left:4px; color: var(--interactive-success);" } });
                const renameBtn = actionContainer.createEl("span", { text: "âœï¸", attr: { style: "cursor: pointer; font-size: 14px; margin-left:6px; color:var(--text-muted);" }, title: "é‡å‘½å (åŒæ­¥æ›´æ–°å­çº§)" });
                if(originalIndex !== -1) renameBtn.onclick = (e) => { e.stopPropagation(); renameItem(originalIndex, item.type, displayText); };
                const deleteBtn = actionContainer.createEl("span", { text: "âœ–", attr: { style: "cursor: pointer; font-size: 14px; color: var(--text-muted); margin-left: 6px;" }, title: "å½»åº•åˆ é™¤" });
                if(originalIndex !== -1) deleteBtn.onclick = (e) => { e.stopPropagation(); deleteItem(originalIndex); };
            } else {
                const dimCheckbox = actionContainer.createEl("input", { type: "checkbox", attr: { style: "margin-right: 6px; cursor: pointer;" } });
                dimCheckbox.checked = item.isDimmed || false;
                dimCheckbox.onclick = (e) => { e.stopPropagation(); toggleDimmed(originalIndex); };

                if (hasActiveChildren) {
                    actionContainer.createEl("span", { text: "ğŸ”’", attr: { title: "è¯·å…ˆå®Œæˆå­ä»»åŠ¡", style: "cursor: not-allowed; font-size: 14px; color: var(--text-muted); opacity: 0.5;" } });
                } else {
                    const completeBtn = actionContainer.createEl("span", { text: "â­•", attr: { style: "cursor: pointer; font-size: 14px; color: var(--interactive-accent);" }, title: "æ ‡è®°å®Œæˆ" });
                    completeBtn.onclick = (e) => { e.stopPropagation(); completeItem(originalIndex); };
                }

                const renameBtn = actionContainer.createEl("span", { text: "âœï¸", attr: { style: "cursor: pointer; font-size: 14px;" }, title: "é‡å‘½å" });
                renameBtn.onclick = (e) => { e.stopPropagation(); renameItem(originalIndex, item.type, displayText); };

                // [å‡çº§] æ ‡ç­¾æŒ‰é’®ï¼šå¦‚æœæ¡ç›®æœ‰æ ‡ç­¾åˆ™æ˜¾ç¤ºç¬¬ä¸€ä¸ªæ ‡ç­¾çš„å›¾æ ‡ï¼Œå¦åˆ™æ˜¾ç¤ºé»˜è®¤ğŸ·ï¸
                const firstTagDef = (item.tags && item.tags.length > 0) ? TAG_DEFINITIONS[item.tags[0]] : null;
                const tagBtnIcon = firstTagDef ? firstTagDef.icon : "ğŸ·ï¸";
                const tagBtnColor = firstTagDef ? firstTagDef.color : "var(--text-muted)";
                const tagBtnTitle = firstTagDef ? `å·²è®¾ç½®: ${firstTagDef.label} (ç‚¹å‡»ä¿®æ”¹)` : "è®¾ç½®ç±»å‹æ ‡ç­¾";
                const tagBtn = actionContainer.createEl("span", {
                    text: tagBtnIcon,
                    attr: { style: `cursor: pointer; font-size: 14px; margin-left:2px; ${firstTagDef ? 'filter: drop-shadow(0 0 2px ' + tagBtnColor + ');' : ''}`, title: tagBtnTitle }
                });
                tagBtn.onclick = (e) => { e.stopPropagation(); modifyTag(originalIndex); };

                if (item.type === 'next_action') {
                    const addSubBtn = actionContainer.createEl("span", { text: "â†³", attr: { style: "cursor: pointer; font-size: 14px; color: var(--text-accent); font-weight: bold;" }, title: "æ·»åŠ å­ä»»åŠ¡" });
                    addSubBtn.onclick = (e) => { e.stopPropagation(); addNewItem('next_action', item.id, item.project); };
                }
                if (item.type === 'inbox') {
                    const moveBtn = actionContainer.createEl("span", { text: "â¡ï¸", attr: { style: "cursor: pointer; font-size: 14px;" }, title: "æ•´ç†" });
                    moveBtn.onclick = (e) => { e.stopPropagation(); moveInboxItem(originalIndex); };
                }
                const starBtn = actionContainer.createEl("span", { text: item.isFirstClass ? "â­" : "â˜†", attr: { style: `cursor: pointer; font-size: 14px; color: ${item.isFirstClass ? '#f1c40f' : 'var(--text-muted)'};` } });
                starBtn.onclick = (e) => { e.stopPropagation(); toggleFirstClass(originalIndex); };
                const focusBtn = actionContainer.createEl("span", { text: item.isFocusSession ? "ğŸ¯" : "â—", attr: { style: `cursor: pointer; font-size: 14px; margin-left:2px; color: ${item.isFocusSession ? '#e91e63' : 'var(--text-muted)'};` } });
                focusBtn.onclick = (e) => { e.stopPropagation(); toggleFocusSession(originalIndex); };
                const schedBtn = actionContainer.createEl("span", { text: "ğŸ“…", attr: { style: "cursor: pointer; font-size: 14px;" }, title: "è®¡åˆ’æ—¥ç¨‹" });
                schedBtn.onclick = (e) => { e.stopPropagation(); setItemSchedule(originalIndex, item.scheduled); };
                const deadlineBtn = actionContainer.createEl("span", { text: "ğŸ", attr: { style: "cursor: pointer; font-size: 14px; color: #e67e22;" }, title: "æˆªæ­¢æ—¥æœŸ" });
                deadlineBtn.onclick = (e) => { e.stopPropagation(); setItemDeadline(originalIndex, item.deadline); };
            }

            const contentSpan = line.createEl("span", { attr: { style: "flex: 1; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center;" } });
            
            const textEl = contentSpan.createEl("span");
            if (item.isDimmed) {
                textEl.style.textDecoration = "line-through";
                textEl.style.opacity = "0.5";
                textEl.style.color = "var(--text-muted)";
            }

            // å¦‚æœ showProjectContext ä¸º true ä¸”æ¡ç›®æœ‰é¡¹ç›®ï¼Œåˆ™åœ¨å‰é¢æ˜¾ç¤º [é¡¹ç›®åç§°]
            if (showProjectContext && item.project && item.type !== 'project') {
                textEl.createEl("span", {
                    text: `[${item.project}] `,
                    attr: { style: "color: var(--text-accent); font-weight: 500; opacity: 0.8;" }
                });
            }

            const link = textEl.createEl("a", { text: displayText, cls: "internal-link", attr: { "data-href": displayText, "href": displayText, "target": "_blank", "rel": "noopener" } });
            
            if (!isGhost && item.tags && item.tags.length > 0) {
                item.tags.forEach(t => {
                    const def = TAG_DEFINITIONS[t];
                    if (def) {
                        const pill = contentSpan.createEl("span", { cls: "tag-pill", title: def.label });
                        pill.style.backgroundColor = def.color;
                        pill.innerHTML = `${def.icon} ${def.label}`;
                    }
                });
            }

            if (!isGhost && window.gtdRecentIds.includes(item.id)) {
                contentSpan.createEl("span", {
                    text: " [æ–°]",
                    attr: { style: "color: #ff5252; font-weight: bold; font-size: 0.8em; margin-left: 4px; vertical-align: text-top;" }
                });
            }

            if (isGhost) {
                link.style.color = "var(--text-faint)";
                link.style.opacity = "0.7";
                link.style.fontStyle = "italic";
            } else if (isCompleted) {
                if (fileExists) {
                    link.style.color = "#5F9EA0"; 
                    link.style.textDecoration = "underline";
                    link.style.opacity = "1"; 
                    link.style.fontWeight = "bold";
                } else {
                    link.style.color = "var(--text-muted)";
                    link.style.textDecoration = "none";
                    link.style.opacity = "0.8"; 
                }
            } else {
                if (fileExists) {
                    link.style.color = "var(--text-accent)";
                    link.style.fontWeight = "bold";
                } else {
                    link.style.color = "var(--text-muted)";
                    link.style.fontStyle = "italic";
                }
            }
            
            if (item.isDimmed) {
                link.style.color = "inherit"; 
            }

            if (!isGhost && item.scheduled) {
                const today = moment().format("YYYY-MM-DD");
                let dateColor = "var(--text-muted)";
                if (item.scheduled < today && !isCompleted) dateColor = "var(--text-error)"; else if (item.scheduled === today) dateColor = "var(--text-success)";
                contentSpan.createEl("span", { text: ` ğŸ“… ${item.scheduled}`, attr: { style: `font-size: 0.8em; color: ${dateColor}; margin-left: 8px; background: var(--background-secondary); padding: 2px 6px; border-radius: 4px;` } });
            }
            if (!isGhost && item.deadline) {
                const today = moment().format("YYYY-MM-DD");
                let dlColor = "#e67e22";
                if (item.deadline < today && !isCompleted) dlColor = "#c0392b"; 
                contentSpan.createEl("span", { text: ` ğŸ ${item.deadline}`, attr: { style: `font-size: 0.8em; color: ${dlColor}; margin-left: 4px; font-weight:bold;` } });
            }
        };

        const renderTaskTree = (container, tasks, parentId = null, level = 0, ancestorMatchedTag = false) => {
            const currentLevelTasks = tasks.filter(wrap => { return (wrap.item.parentId || null) === parentId; });
            currentLevelTasks.sort((a, b) => getDisplayName(a.item).localeCompare(getDisplayName(b.item), "zh"));
            currentLevelTasks.forEach(wrap => {
                // [ç­›é€‰é€»è¾‘]
                // - æ ‡ç­¾ç­›é€‰ï¼šåŒ¹é…æ ‡ç­¾çš„æ¡ç›®ï¼Œå…¶æ‰€æœ‰å­å±‚çº§éƒ½æ˜¾ç¤ºï¼ˆå‘ä¸‹ç»§æ‰¿ï¼‰
                // - Focus/FirstClassï¼šå¿…é¡»å½“å‰èŠ‚ç‚¹æˆ–å­å­™æ»¡è¶³æ¡ä»¶ï¼ˆä¸å˜ï¼‰

                // é€’å½’æ£€æŸ¥ï¼šå½“å‰èŠ‚ç‚¹æˆ–å…¶ä»»æ„å­å­™æ˜¯å¦æ»¡è¶³ç‰¹å®šæ¡ä»¶
                const checkTreeCondition = (id, checker) => {
                    const me = gtdList.find(i => i.id === id);
                    if (me && checker(me)) return true;
                    const children = gtdList.filter(i => i.parentId === id && i.status === 'active');
                    return children.some(c => checkTreeCondition(c.id, checker));
                };

                // æ£€æŸ¥å½“å‰æ¡ç›®æ˜¯å¦åŒ¹é…æ ‡ç­¾
                const currentMatchesTag = window.gtdTagFilter ? tagMatchesFilter(wrap.item.tags, window.gtdTagFilter) : false;
                // æ ‡ç­¾å‘ä¸‹ç»§æ‰¿ï¼šç¥–å…ˆåŒ¹é…åˆ™å­å­™éƒ½é€šè¿‡
                const tagInherited = ancestorMatchedTag || currentMatchesTag;

                let passFocus = true;
                let passFirstClass = true;
                let passTag = true;

                // Focus æ¨¡å¼æ£€æŸ¥ï¼ˆä¸å˜ï¼‰
                if (window.gtdShowOnlyFocus) {
                    passFocus = checkTreeCondition(wrap.item.id, (item) =>
                        item.isFocusSession || window.gtdRecentIds.includes(item.id)
                    );
                }

                // FirstClass æ¨¡å¼æ£€æŸ¥ï¼ˆä¸å˜ï¼‰
                if (window.gtdShowOnlyFirstClass) {
                    passFirstClass = checkTreeCondition(wrap.item.id, (item) =>
                        item.isFirstClass || window.gtdRecentIds.includes(item.id)
                    );
                }

                // æ ‡ç­¾æ¨¡å¼æ£€æŸ¥ï¼šç¥–å…ˆåŒ¹é…(å‘ä¸‹ç»§æ‰¿) æˆ– å½“å‰åŒ¹é… æˆ– å­å­™åŒ¹é…(å‘ä¸Šå†’æ³¡) æˆ– æ–°æ·»åŠ çš„æ¡ç›®
                if (window.gtdTagFilter) {
                    passTag = tagInherited || checkTreeCondition(wrap.item.id, (item) =>
                        tagMatchesFilter(item.tags, window.gtdTagFilter) || window.gtdRecentIds.includes(item.id)
                    );
                }

                // æ‰€æœ‰å¯ç”¨çš„æ¡ä»¶éƒ½å¿…é¡»é€šè¿‡
                const shouldRender = passFocus && passFirstClass && passTag;

                if (shouldRender) {
                    renderItemLine(container, wrap.item, wrap.index, false, false, level, true);
                    if (!wrap.item.isCollapsed) {
                        // ä¼ é€’æ ‡ç­¾ç»§æ‰¿çŠ¶æ€ç»™å­èŠ‚ç‚¹
                        renderTaskTree(container, tasks, wrap.item.id, level + 1, tagInherited);
                    }
                }
            });
        };

        const renderCompletedTree = (container) => {
            const completedItemsRaw = gtdList.map((item, index) => ({ item, index })).filter(({ item }) => item.status === 'completed');
            if (completedItemsRaw.length === 0) {
                container.createEl("div", { text: "_æš‚æ— æ•°æ®_", attr: { style: "color:var(--text-faint);font-style:italic;" } });
                return;
            }
            const allItemsMap = new Map(gtdList.map((item, index) => [item.id, { item, index }]));
            const displayNodes = new Map();
            completedItemsRaw.forEach(wrap => {
                displayNodes.set(wrap.item.id, { ...wrap, isGhost: false, isCompleted: true });
                let currentParentId = wrap.item.parentId;
                while (currentParentId) {
                    if (displayNodes.has(currentParentId)) break; 
                    const parentWrap = allItemsMap.get(currentParentId);
                    if (parentWrap) {
                        if (parentWrap.item.status !== 'completed') {
                            displayNodes.set(currentParentId, { ...parentWrap, isGhost: true, isCompleted: false });
                        }
                    } else break; 
                    currentParentId = parentWrap ? parentWrap.item.parentId : null;
                }
            });
            const treeNodes = Array.from(displayNodes.values());
            const nodesByProject = {};
            treeNodes.forEach(node => {
                const projName = node.item.project || "æœªåˆ†ç±»";
                if (!nodesByProject[projName]) nodesByProject[projName] = [];
                nodesByProject[projName].push(node);
            });
            const renderGhostTree = (container, tasks, parentId = null, level = 0) => {
                const currentLevelTasks = tasks.filter(node => (node.item.parentId || null) === parentId);
                currentLevelTasks.sort((a, b) => getDisplayName(a.item).localeCompare(getDisplayName(b.item), "zh"));
                currentLevelTasks.forEach(node => {
                    renderItemLine(container, node.item, node.index, node.isCompleted, false, level, false, node.isGhost);
                    renderGhostTree(container, tasks, node.item.id, level + 1);
                });
            };
            Object.keys(nodesByProject).sort().forEach(projName => {
                const projDiv = container.createEl("div", { attr: { style: "margin-bottom: 10px;" } });
                projDiv.createEl("div", { text: `ğŸ“‚ ${projName}`, attr: { style: "font-weight: bold; color: var(--text-muted); margin-bottom: 5px; font-size: 0.9em;" } });
                renderGhostTree(projDiv, nodesByProject[projName], null, 0);
            });
            container.createEl("div", { text: `å…± ${completedItemsRaw.length} æ¡å·²å®Œæˆè®°å½•`, attr: { style: "color:var(--text-muted);font-size:0.8em;margin-top:15px;text-align:right;border-top:1px dashed var(--background-modifier-border);padding-top:5px;" } });
        };

        // --- æ ¸å¿ƒä¿®å¤ï¼šæŒ‰é¡ºåºæ„å»ºDOMï¼Œæœ€åå†æŒ‚è½½ ---
        
        // 1. å·¥ä½œç¯®æ¨¡å—
        const inboxDiv = dv.el("div", "", { attr: { id: "gtd-section-inbox", style: containerStyle } });
        inboxDiv.createEl("div", { text: "ğŸ“¥ å·¥ä½œç¯® (Inbox)", attr: { style: headerStyle } });
        const inboxIndices = gtdList.map((item, index) => ({ item, index }))
            .filter(({ item }) => item.type === 'inbox' && item.status === 'active' && filterFn(item))
            .filter(({ item }) => !window.gtdShowOnlyFocus || item.isFocusSession || window.gtdRecentIds.includes(item.id))
            // [å‡çº§] å·¥ä½œç¯®æ ‡ç­¾ç­›é€‰ï¼šä½¿ç”¨tagMatchesFilteræ”¯æŒå±‚çº§åŒ¹é…ï¼Œæ–°æ·»åŠ çš„æ¡ç›®ä¸´æ—¶æ˜¾ç¤º
            .filter(({ item }) => {
                if (window.gtdTagFilter && !tagMatchesFilter(item.tags, window.gtdTagFilter) && !window.gtdRecentIds.includes(item.id)) return false;
                return true;
            })
            .sort(nameSort);
        if (inboxIndices.length === 0) inboxDiv.createEl("div", { text: "_ç©ºç©ºå¦‚ä¹Ÿ_", attr: { style: "color:var(--text-faint);font-style:italic;" } });
        else inboxIndices.forEach(({ item, index }) => renderItemLine(inboxDiv, item, index, false, false, 0, true));

        // 2. å¯¼èˆªæ¨¡å— (ç°åœ¨åªæ˜¯åˆ›å»ºDivï¼Œä¸æŒ‚è½½ç‚¹å‡»äº‹ä»¶é‡Œçš„é€»è¾‘ï¼Œå› ä¸ºç›®æ ‡è¿˜æ²¡ç”Ÿæˆ)
        const navDiv = dv.el("div", "", { attr: { id: "gtd-section-quick-nav", style: containerStyle + "background-color: var(--background-secondary);" } });
        navDiv.createEl("div", { text: "âš¡ é¡¹ç›®å¿«é€Ÿå¯¼èˆª (Quick Nav)", attr: { style: headerStyle + "border-color: var(--text-muted);" } });
        const navContainer = navDiv.createEl("div", { attr: { style: "display:flex; flex-direction:column; gap:2px;" } });

        // 3. æ—¥ç¨‹æ¨¡å—
        const scheduleDiv = dv.el("div", "", { attr: { id: "gtd-section-schedule", style: containerStyle + "border-color: var(--interactive-accent);" } });
        scheduleDiv.createEl("div", { text: "ğŸ“… æ—¥ç¨‹å®‰æ’ (Schedule)", attr: { style: headerStyle } });
        const scheduledIndices = gtdList.map((item, index) => ({ item, index })).filter(({ item }) => item.status === 'active' && item.scheduled && filterFn(item)).sort(scheduleSort);
        if (scheduledIndices.length === 0) scheduleDiv.createEl("div", { text: "_æš‚æ— æ—¥ç¨‹å®‰æ’_", attr: { style: "color:var(--text-faint);font-style:italic;" } });
        else scheduledIndices.forEach(({ item, index }) => renderItemLine(scheduleDiv, item, index, false, true));

        // 4. é¡¹ç›®æ¸…å•æ¨¡å—
        const projectDiv = dv.el("div", "", { attr: { id: "gtd-section-projects", style: containerStyle } });
        projectDiv.createEl("div", { text: "ğŸ“‚ é¡¹ç›®æ¸…å• (Projects)", attr: { style: headerStyle } });

        const activeProjectsForNav = gtdList.map((item, index) => ({ item, index }))
            .filter(({ item }) => item.type === 'project' && item.status === 'active')
            .sort(nameSort)
            .filter(({ item }) => {
                // æ— ä»»ä½•ç­›é€‰æ¡ä»¶æ—¶æ˜¾ç¤ºæ‰€æœ‰é¡¹ç›®
                if (!window.gtdShowOnlyFirstClass && !window.gtdShowOnlyFocus && !window.gtdTagFilter) return true;

                const projName = item.project;
                const subs = gtdList.filter(s => s.type === 'next_action' && s.project === projName && s.status === 'active');

                // é€’å½’æ£€æŸ¥ï¼šå½“å‰èŠ‚ç‚¹æˆ–å…¶ä»»æ„å­å­™æ˜¯å¦æ»¡è¶³ç‰¹å®šæ¡ä»¶
                const checkTreeCondition = (id, checker) => {
                    const me = gtdList.find(i => i.id === id);
                    if (me && checker(me)) return true;
                    const children = gtdList.filter(i => i.parentId === id && i.status === 'active');
                    return children.some(c => checkTreeCondition(c.id, checker));
                };

                let passFocus = true;
                let passFirstClass = true;
                let passTag = true;

                // Focus æ¨¡å¼æ£€æŸ¥ï¼šé¡¹ç›®æˆ–å­ä»»åŠ¡æœ‰ç„¦ç‚¹æ ‡è®°
                if (window.gtdShowOnlyFocus) {
                    passFocus = item.isFocusSession || subs.some(s => checkTreeCondition(s.id, (i) =>
                        i.isFocusSession || window.gtdRecentIds.includes(i.id)
                    ));
                }

                // FirstClass æ¨¡å¼æ£€æŸ¥ï¼šé¡¹ç›®æˆ–å­ä»»åŠ¡æœ‰æ˜Ÿæ ‡
                if (window.gtdShowOnlyFirstClass) {
                    passFirstClass = item.isFirstClass || subs.some(s => checkTreeCondition(s.id, (i) =>
                        i.isFirstClass || window.gtdRecentIds.includes(i.id)
                    ));
                }

                // æ ‡ç­¾æ¨¡å¼æ£€æŸ¥ï¼šé¡¹ç›®æœ¬èº«æˆ–ä»»æ„å­ä»»åŠ¡åŒ¹é…æ ‡ç­¾å³å¯ï¼Œæ–°æ·»åŠ çš„æ¡ç›®ä¸´æ—¶é€šè¿‡
                if (window.gtdTagFilter) {
                    passTag = tagMatchesFilter(item.tags, window.gtdTagFilter) ||
                        window.gtdRecentIds.includes(item.id) ||
                        subs.some(s => checkTreeCondition(s.id, (i) =>
                            tagMatchesFilter(i.tags, window.gtdTagFilter) || window.gtdRecentIds.includes(i.id)
                        ));
                }

                // æ‰€æœ‰å¯ç”¨çš„æ¡ä»¶éƒ½å¿…é¡»é€šè¿‡
                return passFocus && passFirstClass && passTag;
            });

        // å¡«å…… Quick Navï¼šæ ‘çŠ¶é¡¹ç›®å¯¼èˆªï¼ˆæ”¯æŒæ‹–æ‹½æ”¹çˆ¶å­ã€æŠ˜å ã€åŒçº§åç§°æ’åºï¼‰
        if (activeProjectsForNav.length > 0) {
            const visibleProjectIdSet = new Set(activeProjectsForNav.map(({ item }) => item.id));

            const getVisibleChildren = (parentId) => {
                return activeProjectsForNav
                    .filter(({ item }) => (item.parentId || null) === parentId)
                    .sort((a, b) => (a.item.project || "").localeCompare((b.item.project || ""), "zh"));
            };

            const rootDropZone = navContainer.createEl("div", { cls: "proj-nav-drop-root", text: "â†¥ æ‹–æ‹½åˆ°è¿™é‡Œè®¾ä¸ºé¡¶å±‚é¡¹ç›®" });
            rootDropZone.addEventListener("dragover", (e) => {
                e.preventDefault();
                if (!window.gtdCurrentDragProjectId) return;
                rootDropZone.classList.add("drag-over");
            });
            rootDropZone.addEventListener("dragleave", () => rootDropZone.classList.remove("drag-over"));
            rootDropZone.addEventListener("drop", async (e) => {
                e.preventDefault();
                rootDropZone.classList.remove("drag-over");
                if (!window.gtdCurrentDragProjectId) return;
                await moveProjectUnderParent(window.gtdCurrentDragProjectId, null);
            });

            const jumpToProject = (projectId) => {
                const targetId = `proj-${projectId}`;
                setTimeout(() => {
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.open = true;
                        setTimeout(() => {
                            targetElement.scrollIntoView({ behavior: "smooth", block: "center" });
                            targetElement.classList.add("highlight-target");
                            setTimeout(() => targetElement.classList.remove("highlight-target"), 1500);
                        }, 50);
                    } else {
                        new Notice("å®šä½å¤±è´¥ï¼šç›®æ ‡é¡¹ç›®å½“å‰ä¸å¯è§ï¼ˆå¯èƒ½è¢«ç­›é€‰éšè—ï¼‰");
                    }
                }, 10);
            };

            const renderNavTree = (parentId, level = 0, chain = new Set()) => {
                const children = getVisibleChildren(parentId);
                children.forEach(({ item }) => {
                    // é˜²å¾¡ï¼šè‹¥æ•°æ®ä¸­å·²æœ‰å¾ªç¯å¼•ç”¨ï¼Œç›´æ¥è·³è¿‡è¯¥åˆ†æ”¯
                    if (chain.has(item.id)) return;
                    const nextChain = new Set(chain);
                    nextChain.add(item.id);

                    const hasChildren = getVisibleChildren(item.id).length > 0;
                    const isCollapsed = !!window.gtdQuickNavCollapsed[item.id];

                    const row = navContainer.createEl("div", { cls: "proj-nav-row", attr: { style: `margin-left:${level * 18}px;` } });
                    row.draggable = true;
                    row.addEventListener("dragstart", (e) => {
                        window.gtdCurrentDragProjectId = item.id;
                        e.dataTransfer.effectAllowed = "move";
                        e.dataTransfer.setData("text/plain", item.id);
                        setTimeout(() => row.classList.add("is-dragging"), 0);
                    });
                    row.addEventListener("dragend", () => {
                        window.gtdCurrentDragProjectId = null;
                        row.classList.remove("is-dragging");
                    });
                    row.addEventListener("dragover", (e) => {
                        e.preventDefault();
                        const draggedId = window.gtdCurrentDragProjectId;
                        if (!draggedId || draggedId === item.id) return;
                        row.classList.add("drag-over");
                    });
                    row.addEventListener("dragleave", () => row.classList.remove("drag-over"));
                    row.addEventListener("drop", async (e) => {
                        e.preventDefault();
                        row.classList.remove("drag-over");
                        const draggedId = window.gtdCurrentDragProjectId;
                        if (!draggedId || draggedId === item.id) return;
                        await moveProjectUnderParent(draggedId, item.id);
                    });

                    if (hasChildren) {
                        const toggle = row.createEl("span", { cls: "proj-nav-toggle", text: isCollapsed ? "â–¶" : "â–¼" });
                        toggle.onclick = (e) => {
                            e.stopPropagation();
                            window.gtdQuickNavCollapsed[item.id] = !isCollapsed;
                            if (renderViewFn) renderViewFn();
                        };
                    } else {
                        row.createEl("span", { cls: "proj-nav-toggle spacer", text: "â€¢" });
                    }

                    const navTag = row.createEl("span", { text: `ğŸ“‚ ${item.project}`, cls: "proj-nav-tag" });
                    navTag.onclick = () => jumpToProject(item.id);

                    if (hasChildren && !isCollapsed) renderNavTree(item.id, level + 1, nextChain);
                });
            };

            // æ ¹èŠ‚ç‚¹ï¼šparentIdä¸ºç©ºï¼Œæˆ–çˆ¶èŠ‚ç‚¹è¢«ç­›é€‰éšè—æ—¶ä¹Ÿæå‡ä¸ºæ ¹æ˜¾ç¤º
            const rootProjects = activeProjectsForNav
                .filter(({ item }) => {
                    const p = item.parentId || null;
                    return p === null || !visibleProjectIdSet.has(p);
                })
                .sort((a, b) => (a.item.project || "").localeCompare((b.item.project || ""), "zh"));

            rootProjects.forEach(({ item }) => {
                const hasChildren = getVisibleChildren(item.id).length > 0;
                const isCollapsed = !!window.gtdQuickNavCollapsed[item.id];

                const row = navContainer.createEl("div", { cls: "proj-nav-row", attr: { style: "margin-left:0px;" } });
                row.draggable = true;
                row.addEventListener("dragstart", (e) => {
                    window.gtdCurrentDragProjectId = item.id;
                    e.dataTransfer.effectAllowed = "move";
                    e.dataTransfer.setData("text/plain", item.id);
                    setTimeout(() => row.classList.add("is-dragging"), 0);
                });
                row.addEventListener("dragend", () => {
                    window.gtdCurrentDragProjectId = null;
                    row.classList.remove("is-dragging");
                });
                row.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    const draggedId = window.gtdCurrentDragProjectId;
                    if (!draggedId || draggedId === item.id) return;
                    row.classList.add("drag-over");
                });
                row.addEventListener("dragleave", () => row.classList.remove("drag-over"));
                row.addEventListener("drop", async (e) => {
                    e.preventDefault();
                    row.classList.remove("drag-over");
                    const draggedId = window.gtdCurrentDragProjectId;
                    if (!draggedId || draggedId === item.id) return;
                    await moveProjectUnderParent(draggedId, item.id);
                });

                if (hasChildren) {
                    const toggle = row.createEl("span", { cls: "proj-nav-toggle", text: isCollapsed ? "â–¶" : "â–¼" });
                    toggle.onclick = (e) => {
                        e.stopPropagation();
                        window.gtdQuickNavCollapsed[item.id] = !isCollapsed;
                        if (renderViewFn) renderViewFn();
                    };
                } else {
                    row.createEl("span", { cls: "proj-nav-toggle spacer", text: "â€¢" });
                }

                const navTag = row.createEl("span", { text: `ğŸ“‚ ${item.project}`, cls: "proj-nav-tag" });
                navTag.onclick = () => jumpToProject(item.id);

                if (hasChildren && !isCollapsed) renderNavTree(item.id, 1, new Set([item.id]));
            });
        } else {
            navDiv.style.display = 'none'; // æ²¡æœ‰é¡¹ç›®æ—¶éšè—å¯¼èˆªæ 
        }

        if (activeProjectsForNav.length === 0) projectDiv.createEl("div", { text: "_æš‚æ— æ´»è·ƒé¡¹ç›®_", attr: { style: "color:var(--text-faint);font-style:italic;" } });
        else {
            activeProjectsForNav.forEach(({ item: projItem, index: projIndex }) => {
                const projName = projItem.project;
                const details = projectDiv.createEl("details", { attr: { id: `proj-${projItem.id}`, open: "", style: "margin-bottom:8px;border-bottom:1px dashed var(--background-modifier-border);padding-bottom:8px;" } });
                const summary = details.createEl("summary", { attr: { style: "cursor:pointer;margin-bottom:5px;font-weight:600;color:var(--text-normal);" } });
                
                summary.addEventListener("dragover", (e) => { e.preventDefault(); e.stopPropagation(); if (!window.gtdCurrentDragId) return; summary.classList.add("drag-over-project"); });
                summary.addEventListener("dragleave", (e) => { e.stopPropagation(); summary.classList.remove("drag-over-project"); });
                summary.addEventListener("drop", async (e) => { e.preventDefault(); e.stopPropagation(); summary.classList.remove("drag-over-project"); await handleDrop(window.gtdCurrentDragId, projName, null, 'project'); });

                const summaryContent = summary.createEl("span");
                const projDoneBtn = summaryContent.createEl("span", { text: "â­•", attr: { style: "margin-right:6px;cursor:pointer;color:var(--interactive-accent);" }, title: "å½’æ¡£é¡¹ç›®" });
                projDoneBtn.onclick = (e) => { e.preventDefault(); completeProject(projIndex, projName); };
                const projRenameBtn = summaryContent.createEl("span", { text: "âœï¸", attr: { style: "margin-right:6px;cursor:pointer;font-size:14px;" }, title: "é‡å‘½åé¡¹ç›®" });
                projRenameBtn.onclick = (e) => { e.preventDefault(); renameItem(projIndex, 'project', projName); };
                const projFocusBtn = summaryContent.createEl("span", { text: projItem.isFocusSession ? "ğŸ¯" : "â—", attr: { style: `margin-right:6px;cursor:pointer;color: ${projItem.isFocusSession ? '#e91e63' : 'var(--text-muted)'};` }, title: "åŠ å…¥æœ¬æ¬¡æ‰§è¡Œ" });
                projFocusBtn.onclick = (e) => { e.preventDefault(); toggleFocusSession(projIndex); };
                const projSchedBtn = summaryContent.createEl("span", { text: "ğŸ“…", attr: { style: "margin-right:4px;cursor:pointer;font-size:14px;" }, title: "è®¾ç½®è®¡åˆ’" });
                projSchedBtn.onclick = (e) => { e.preventDefault(); setItemSchedule(projIndex, projItem.scheduled); };
                const projDlBtn = summaryContent.createEl("span", { text: "ğŸ", attr: { style: "margin-right:8px;cursor:pointer;font-size:14px;color:#e67e22;" }, title: "è®¾ç½®æ­»çº¿" });
                projDlBtn.onclick = (e) => { e.preventDefault(); setItemDeadline(projIndex, projItem.deadline); };
                
                // [ä¿®å¤] æ ‡ç­¾è®¾ç½®æŒ‰é’®ï¼ˆé¡¹ç›®ä¹Ÿå¯ä»¥æ‰“æ ‡ç­¾äº†ï¼ï¼‰
                const projTagBtn = summaryContent.createEl("span", { text: "ğŸ·ï¸", attr: { style: "cursor: pointer; font-size: 14px; margin-right:6px;", title: "è®¾ç½®é¡¹ç›®ç±»å‹" } });
                projTagBtn.onclick = (e) => { e.preventDefault(); modifyTag(projIndex); };

                summaryContent.createEl("a", { text: projName, cls: "internal-link", attr: { "data-href": projName, "href": projName, "target": "_blank", "rel": "noopener" } });
                
                // [æ–°å¢] æ¸²æŸ“é¡¹ç›®çš„æ ‡ç­¾
                if (projItem.tags && projItem.tags.length > 0) {
                    projItem.tags.forEach(t => {
                        const def = TAG_DEFINITIONS[t];
                        if (def) {
                            const pill = summaryContent.createEl("span", { cls: "tag-pill", title: def.label });
                            pill.style.backgroundColor = def.color;
                            pill.innerHTML = `${def.icon} ${def.label}`;
                        }
                    });
                }

                if (projItem.scheduled) summaryContent.createEl("span", { text: ` ğŸ“… ${projItem.scheduled}`, attr: { style: "font-size:0.8em;color:var(--text-muted);margin-left:8px;" } });
                if (projItem.deadline) {
                    const dColor = (projItem.deadline < moment().format("YYYY-MM-DD")) ? "#c0392b" : "#e67e22";
                    summaryContent.createEl("span", { text: ` ğŸ ${projItem.deadline}`, attr: { style: `font-size:0.8em;color:${dColor};margin-left:4px;font-weight:bold;` } });
                }

                const subActionsRaw = gtdList.map((item, index) => ({ item, index }))
                    .filter(({ item }) => item.type === 'next_action' && item.project === projName && item.status === 'active');

                summaryContent.createEl("span", { text: ` (${subActionsRaw.length})`, attr: { style: "font-size:0.8em;color:var(--text-muted);" } });

                const subList = details.createEl("div", { attr: { style: "margin-left:24px;padding-left:10px;border-left:2px solid var(--background-modifier-border);" } });
                if (subActionsRaw.length === 0) subList.createEl("div", { text: "ğŸ‘‰ æš‚æ— ä¸‹ä¸€æ­¥è¡ŒåŠ¨", attr: { style: "color:var(--text-muted);font-size:0.9em;padding:4px 0;" } });
                else {
                    // [æ ¸å¿ƒä¿®å¤] é¡¹ç›®æ ‡ç­¾å‘ä¸‹ç»§æ‰¿ï¼šå¦‚æœé¡¹ç›®åŒ¹é…æ ‡ç­¾ç­›é€‰ï¼Œåˆ™å…¶æ‰€æœ‰å­ä»»åŠ¡éƒ½æ˜¾ç¤º
                    const projectMatchesTag = window.gtdTagFilter ? tagMatchesFilter(projItem.tags, window.gtdTagFilter) : false;
                    renderTaskTree(subList, subActionsRaw, null, 0, projectMatchesTag);
                }
            });
        }
        
        const doneDiv = dv.el("div", "", { attr: { style: containerStyle } }); 
        doneDiv.createEl("div", { text: "âœ… å½’æ¡£åšç‰©é¦† (Archive)", attr: { style: headerStyle } });
        renderCompletedTree(doneDiv);

        // æœ€ç»ˆæŒ‚è½½é¡ºåºï¼šå·¥ä½œç¯® -> å¯¼èˆª -> æ—¥ç¨‹ -> é¡¹ç›® -> å½’æ¡£
        // æ³¨æ„ï¼šdv.el æ˜¯ç›´æ¥ append åˆ° container çš„ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä»£ç é¡ºåºå°±æ˜¯æ¸²æŸ“é¡ºåº
    };

    renderViewFn = () => {
        if (window.gtdTagManagerMode) {
            renderTagManagerView(dv.container);
        } else if (window.gtdKaioKenMode) {
            renderKaioKenView(dv.container);
        } else if (window.gtdTimelineMode) {
            renderTimelineView(dv.container);
        } else {
            renderNormalView();
        }
    };
    if(renderViewFn) renderViewFn();
})();

```
