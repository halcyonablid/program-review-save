```dataviewjs
// ============================================================
// ğŸµï¸ æ›¼é™€ç½—æ—¶ç©ºæ•´åˆç³»ç»Ÿ (v2.5 åˆ†ç±»å¢å¼ºç‰ˆ)
// æ ¸å¿ƒï¼šä¹å®«æ ¼ + è¯„ä»·è¡¥å¡ + æ— é™å±‚çº§æ±‡æ€» + èŠ‚ç‚¹åˆ†ç±» + è¯¦æƒ…Modal
// ============================================================

// --- 0. é…ç½®ä¸åˆå§‹åŒ– ---
const DB_FILE = "Mandala_Database.json";
const LOG_FILE = "Mandala_Logs.json";
const TYPE_FILE = "Mandala_Types.json";
const DEFAULT_DB = { root: { id: "root", title: "æ ¸å¿ƒç›®æ ‡", children: {} } };
const DEFAULT_LOGS = [];
const currentFolder = dv.current().file.folder;
// è§„èŒƒåŒ–è·¯å¾„ï¼Œé¿å… // æˆ–åæ–œæ å¯¼è‡´ getAbstractFileByPath æ‰¾ä¸åˆ°æ–‡ä»¶
const normalizePathSafe = (p) => p.replace(/\\/g, "/").replace(/\/+/g, "/").replace(/^\//, "");
const DB_PATH = normalizePathSafe(`${currentFolder}/${DB_FILE}`);
const LOG_PATH = normalizePathSafe(`${currentFolder}/${LOG_FILE}`);
const TYPE_PATH = normalizePathSafe(`${currentFolder}/${TYPE_FILE}`);

// --- 0.1 èŠ‚ç‚¹ç±»å‹é…ç½® ---
// é»˜è®¤ç±»å‹ï¼ˆå¯åœ¨â€œç±»å‹ç®¡ç†â€é‡Œä¿®æ”¹åç§°/é¢œè‰²/emojiï¼‰
const DEFAULT_NODE_TYPES = {
    default:    { name: "æ™®é€š",     color: "#9ca3af", icon: "ğŸ“¦" },   // æœªåˆ†ç±»
    category:   { name: "å¾…ç»†åˆ†",   color: "#6366f1", icon: "ğŸ“" },   // è¿˜éœ€å¾€ä¸‹æ‹†
    milestone:  { name: "é‡Œç¨‹ç¢‘",   color: "#f59e0b", icon: "ğŸ†" },   // ä¸€æ¬¡æ€§ç»“æœ
    project:    { name: "é¡¹ç›®",     color: "#3b82f6", icon: "ğŸ“‹" },   // é˜¶æ®µæ€§äº§å‡º
    habit:      { name: "ä¹ æƒ¯",     color: "#10b981", icon: "ğŸ”„" },   // é«˜é¢‘åŠ¨ä½œ
    compound:   { name: "å¤åˆ©ç§¯ç´¯", color: "#22c55e", icon: "ğŸª´" },   // é•¿æœŸå¤åˆ©/ç»ƒåŠŸ
    maintenance:{ name: "ç»´æŠ¤è¿è¥", color: "#8b5cf6", icon: "ğŸ› " },   // ä¿å…»/æŒç»­è¿è¥
    block:      { name: "å µç‚¹", color: "#ef4444", icon: "ğŸª " },   // éœ€è¦æ¸…é™¤çš„é˜»ç¢
    backlog:    { name: "ç§å­/æƒ³æ³•", color: "#eab308", icon: "ğŸ’¡" }   // è¿˜æœªå¯åŠ¨çš„æƒ³æ³•
};
let nodeTypes = {};
const safeHexColor = (value, fallback = "#9ca3af") => {
    const hex = (value || "").trim();
    return /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(hex) ? hex : fallback;
};
const toTypeId = (value) => {
    const normalized = (value || "")
        .toLowerCase()
        .trim()
        .replace(/\s+/g, "-")
        .replace(/[^a-z0-9_-]/g, "");
    return normalized || `type_${Date.now().toString(36)}`;
};
const ensureUniqueTypeId = (baseId, dict) => {
    let finalId = baseId;
    let i = 1;
    while (dict[finalId]) {
        finalId = `${baseId}_${i}`;
        i++;
    }
    return finalId;
};
const mergeTypeConfigs = (rawTypes) => {
    const merged = {};
    Object.entries(DEFAULT_NODE_TYPES).forEach(([typeId, cfg]) => {
        merged[typeId] = { ...cfg };
    });
    if (rawTypes && typeof rawTypes === "object" && !Array.isArray(rawTypes)) {
        Object.entries(rawTypes).forEach(([typeId, cfg]) => {
            if (!typeId || !cfg || typeof cfg !== "object") return;
            const base = merged[typeId] || {};
            merged[typeId] = {
                name: (cfg.name || base.name || typeId).toString().trim(),
                color: safeHexColor(cfg.color, base.color || "#9ca3af"),
                icon: (cfg.icon || base.icon || "ğŸ·ï¸").toString().trim() || "ğŸ·ï¸"
            };
        });
    }
    return merged;
};
const getTypeConfig = (typeId) => nodeTypes[typeId] || { name: typeId, color: "#9ca3af", icon: "ğŸ·ï¸" };
const getTypeUsageCount = (typeId) => Object.values(db).filter(n => (n.type || "default") === typeId).length;
const persistTypeConfigs = async () => {
    nodeTypes = mergeTypeConfigs(nodeTypes);
    await saveJson(TYPE_PATH, nodeTypes);
};

if (window.mandalaState === undefined) window.mandalaState = {
    view: "grid", currentId: "root", history: [], detailTargetId: null, typeFilter: "all"
};
if (!window.mandalaState.typeFilter) window.mandalaState.typeFilter = "all";

// --- 1. äº¤äº’ç»„ä»¶ ---
class QuickPrompt extends obsidian.Modal {
    constructor(app, title, placeholder, onSubmit, defaultValue = "") {
        super(app); this.titleStr = title; this.placeholder = placeholder; this.defaultValue = defaultValue; this.onSubmit = onSubmit;
    }
    onOpen() {
        const { contentEl } = this;
        contentEl.createEl("h3", { text: this.titleStr });
        const input = contentEl.createEl("input", { type: "text", value: this.defaultValue });
        input.placeholder = this.placeholder; input.style.width = "100%"; input.focus();
        const btn = contentEl.createEl("button", { text: "ç¡®å®š", cls: "mod-cta", style: "margin-top:15px; float:right;" });
        const submit = () => { if(input.value) { this.close(); this.onSubmit(input.value); }};
        btn.onclick = submit; input.addEventListener("keypress", (e) => { if (e.key === "Enter") submit(); });
    }
    onClose() { this.contentEl.empty(); }
}
const prompt = (title, placeholder = "", defaultValue = "") => new Promise(r => new QuickPrompt(app, title, placeholder, r, defaultValue).open());

// --- 1.1 èŠ‚ç‚¹è¯¦æƒ…Modal (è‡ªå®šä¹‰HTML Modal) ---
// ç¡®ä¿æ¯æ¬¡æ‰“å¼€è¯¦æƒ…éƒ½è¯»å–æœ€æ–°çš„ JSONï¼ˆé˜²æ­¢ç£ç›˜å·²æœ‰æ•°æ®å´æœªè½½å…¥å†…å­˜ï¼‰
const refreshDbFromDisk = async () => {
    nodeTypes = mergeTypeConfigs(await loadJson(TYPE_PATH, DEFAULT_NODE_TYPES));
    db = await loadJson(DB_PATH, DEFAULT_DB);
    logs = await loadJson(LOG_PATH, DEFAULT_LOGS);
    Object.values(db).forEach(migrateNode);
    sortLogsByDate();
};

const openNodeDetail = async (nodeId, onSave) => {
    await refreshDbFromDisk();
    // åˆ›å»ºé®ç½©å±‚
    const modal = document.createElement("div");
    modal.style.cssText = "position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:10000;";

    // åˆ›å»ºå†…å®¹åŒº
    const content = modal.createEl("div");
    content.style.cssText = "background:var(--background-secondary);border-radius:12px;padding:24px;max-width:960px;width:96%;max-height:92vh;overflow-y:auto;";

    // æ ‡é¢˜
    content.createEl("h2", { text: "ğŸ“‹ èŠ‚ç‚¹è¯¦æƒ…", style: "margin-bottom: 15px; display: flex; align-items: center; gap: 8px;" });

    // è·å–èŠ‚ç‚¹æ•°æ®ï¼ˆåˆ·æ–°åï¼‰
    const node = db[nodeId];
    if (!node) {
        new Notice("âŒ èŠ‚ç‚¹ä¸å­˜åœ¨");
        return;
    }

    // æ ‡é¢˜æ˜¾ç¤ºï¼ˆå¸¦ç±»å‹æ ‡ç­¾ï¼‰
    const titleRow = content.createEl("div", {
        style: "margin-bottom: 15px; padding: 8px 12px; background: var(--background-secondary); border-radius: 6px; display: flex; align-items: center; gap: 10px;"
    });
    titleRow.createEl("span", { text: node.title, style: "font-weight: bold; font-size: 1.1em;" });

    // å¦‚æœæœ‰ç±»å‹ï¼Œæ˜¾ç¤ºç±»å‹æ ‡ç­¾
    const nodeType = node.type || 'default';
    if (nodeType !== 'default') {
        const typeConfig = getTypeConfig(nodeType);
        const typeBadge = titleRow.createEl("span", {
            text: `${typeConfig?.icon || ''} ${typeConfig?.name || nodeType}`,
            style: `padding: 2px 8px; border-radius: 12px; font-size: 0.8em; background: ${typeConfig?.color || '#666'}; color: white;`
        });
    }

    // ç»Ÿè®¡ä¿¡æ¯
    const statsDiv = content.createEl("div", {
        style: "background: var(--background-secondary); padding: 12px; border-radius: 8px; margin-bottom: 18px; display: flex; justify-content: space-around; gap: 20px;"
    });
    const allIds = getAllDescendantIds(nodeId);
    const relatedLogs = logs.filter(l => allIds.includes(l.targetId));
    statsDiv.createEl("div", { text: `ğŸ“Š æ€»è®°å½•æ•°: ${relatedLogs.length}` });
    statsDiv.createEl("div", { text: `ğŸ• æœ€è¿‘æ›´æ–°: ${relatedLogs[0]?.date || "æ— "}` });

    // åˆ†éš”çº¿
    content.createEl("div", { style: "border-top: 1px solid var(--background-modifier-border); margin: 15px 0;" });

    // åç§°ç¼–è¾‘
    content.createEl("h4", { text: "âœï¸ èŠ‚ç‚¹åç§°", style: "margin-top: 10px; margin-bottom: 8px;" });
    const titleInput = content.createEl("input", {
        type: "text",
        value: node.title,
        placeholder: "è¯·è¾“å…¥èŠ‚ç‚¹åç§°"
    });
    titleInput.style.cssText = "width: 100%; padding: 10px 12px; border: 1px solid var(--text-muted); border-radius: 6px; background: var(--background-primary); color: var(--text-normal); font-size: 14px;";

    // æ”¹åå†å²ï¼ˆæ—§åç§° -> æ–°åç§°ï¼‰
    const renameHistory = Array.isArray(node.renameHistory) ? node.renameHistory : [];
    content.createEl("h4", { text: "ğŸ§¾ æ”¹åå†å²æ•°æ®å¸§", style: "margin-top: 14px; margin-bottom: 8px;" });
    if (renameHistory.length === 0) {
        content.createEl("div", { text: "æš‚æ— æ”¹åè®°å½•", style: "color: var(--text-muted); font-size: 0.9em; margin-bottom: 10px;" });
    } else {
        const historyTable = content.createEl("table", {
            style: "width: 100%; border-collapse: collapse; font-size: 0.9em; margin-bottom: 10px;"
        });
        const thead = historyTable.createEl("thead");
        const headRow = thead.createEl("tr");
        headRow.createEl("th", { text: "æ—¶é—´", style: "text-align:left; padding: 6px 8px; border-bottom: 1px solid var(--background-modifier-border);" });
        headRow.createEl("th", { text: "æ—§åç§°", style: "text-align:left; padding: 6px 8px; border-bottom: 1px solid var(--background-modifier-border);" });
        headRow.createEl("th", { text: "æ–°åç§°", style: "text-align:left; padding: 6px 8px; border-bottom: 1px solid var(--background-modifier-border);" });

        const tbody = historyTable.createEl("tbody");
        [...renameHistory].slice().reverse().forEach((item) => {
            const row = tbody.createEl("tr");
            row.createEl("td", { text: item.changedAt || "-", style: "padding: 6px 8px; border-bottom: 1px solid var(--background-modifier-border-focus);" });
            row.createEl("td", { text: item.oldTitle || "-", style: "padding: 6px 8px; border-bottom: 1px solid var(--background-modifier-border-focus);" });
            row.createEl("td", { text: item.newTitle || "-", style: "padding: 6px 8px; border-bottom: 1px solid var(--background-modifier-border-focus);" });
        });
    }

    // æè¿°/å¤‡æ³¨ç¼–è¾‘
    content.createEl("h4", { text: "ğŸ“ æè¿°/å¤‡æ³¨ (å¯å†™ 1000 å­—ä»¥ä¸Š)", style: "margin-top: 15px; margin-bottom: 8px;" });
    const textarea = content.createEl("textarea", {
        style: "width: 100%; min-height: 420px; height: 420px; padding: 12px; border: 1px solid var(--text-muted); border-radius: 6px; background: var(--background-primary); color: var(--text-normal); resize: vertical; font-size: 14px; line-height: 1.6;"
    });
    // å¯¹ textarea éœ€è¦æ˜¾å¼èµ‹å€¼ï¼Œè®¾ç½® attribute ä¸ä¼šæ˜¾ç¤ºå†…å®¹
    textarea.value = node.comment || "";

    // ç±»å‹é€‰æ‹©
    content.createEl("h4", { text: "ğŸ·ï¸ èŠ‚ç‚¹ç±»å‹", style: "margin-top: 18px; margin-bottom: 10px;" });
    const typeContainer = content.createEl("div", {
        cls: "type-selector",
        style: "display: flex; flex-wrap: wrap; gap: 10px; padding: 15px; background: var(--background-secondary); border-radius: 8px;"
    });

    const typeRadios = {};
    const currentType = node.type && nodeTypes[node.type] ? node.type : 'default';
    const typeEntries = Object.entries(nodeTypes);
    if (node.type && !nodeTypes[node.type]) typeEntries.push([node.type, getTypeConfig(node.type)]);

    typeEntries.forEach(([typeId, config]) => {
        const isChecked = currentType === typeId;
        const label = typeContainer.createEl("label", {
            style: `display: flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 4px; cursor: pointer; border: 1px solid ${isChecked ? config.color : 'var(--background-modifier-border)'}; background: ${isChecked ? config.color + '20' : 'var(--background-primary)'};`
        });

        const radio = label.createEl("input", {
            type: "radio",
            name: "nodeType",
            value: typeId,
            checked: isChecked
        });
        // ç¡®ä¿åˆå§‹é€‰ä¸­çŠ¶æ€ç”Ÿæ•ˆï¼ˆObsidian createEl å¯¹ boolean å±æ€§ä¸æ€»æ˜¯è®¾ç½® DOM propertyï¼‰
        radio.checked = isChecked;
        typeRadios[typeId] = radio;

        label.createSpan({ text: `${config.icon} ${config.name}`, style: `font-weight: ${isChecked ? 'bold' : 'normal'};` });

        // é¢œè‰²æŒ‡ç¤ºç‚¹
        if (config.color !== 'transparent') {
            const colorDot = label.createEl("span", {
                cls: "type-color-dot",
                style: `width: 10px; height: 10px; border-radius: 50%; background: ${config.color}; ${isChecked ? 'box-shadow: 0 0 6px ' + config.color : ''}`
            });
        }

        // ç‚¹å‡»åˆ‡æ¢ç±»å‹
        label.onclick = () => {
            // å–æ¶ˆæ‰€æœ‰é€‰ä¸­
            Object.values(typeRadios).forEach(r => r.checked = false);
            // é‡ç½®æ‰€æœ‰æ ‡ç­¾æ ·å¼
            typeContainer.querySelectorAll('label').forEach(lbl => {
                lbl.style.border = '1px solid var(--background-modifier-border)';
                lbl.style.background = 'var(--background-primary)';
                const span = lbl.querySelector('span');
                if (span) span.style.fontWeight = 'normal';
                const dot = lbl.querySelector('span:last-child');
                if (dot && dot.classList.contains('type-color-dot')) dot.style.boxShadow = 'none';
            });
            // é€‰ä¸­å½“å‰
            radio.checked = true;
            label.style.border = `1px solid ${config.color}`;
            label.style.background = `${config.color}20`;
            label.querySelector('span').style.fontWeight = 'bold';
            const dot = label.querySelector('span:last-child');
            if (dot && dot.classList.contains('type-color-dot')) dot.style.boxShadow = `0 0 6px ${config.color}`;
        };
    });

    // æ“ä½œæŒ‰é’®
    const btnRow = content.createEl("div", {
        style: "display: flex; gap: 10px; justify-content: flex-end; margin-top: 24px; padding-top: 15px; border-top: 1px solid var(--background-modifier-border);"
    });

    const saveBtn = btnRow.createEl("button", {
        text: "ğŸ’¾ ä¿å­˜",
        style: "padding: 10px 24px; border-radius: 6px; font-size: 14px; background: var(--interactive-accent); color: white; border: none; cursor: pointer;"
    });

    const cancelBtn = btnRow.createEl("button", {
        text: "âœ–ï¸ å…³é—­",
        style: "padding: 10px 24px; border-radius: 6px; font-size: 14px; background: var(--background-modifier-hover); border: none; cursor: pointer;"
    });

    // ä¿å­˜é€»è¾‘
    saveBtn.onclick = async () => {
        // æŸ¥æ‰¾é€‰ä¸­çš„ç±»å‹
        let selectedType = 'default';
        for (const [typeId, radio] of Object.entries(typeRadios)) {
            if (radio.checked) {
                selectedType = typeId;
                break;
            }
        }

        // æ›´æ–°å†…å­˜æ•°æ®
        const trimmedTitle = (titleInput.value || "").trim();
        if (!trimmedTitle) {
            new Notice("âŒ åç§°ä¸èƒ½ä¸ºç©º");
            titleInput.focus();
            return;
        }

        const oldTitle = db[nodeId].title;
        const titleChanged = trimmedTitle !== oldTitle;
        if (titleChanged) {
            await renameLinkedFile(oldTitle, trimmedTitle);
            if (!Array.isArray(db[nodeId].renameHistory)) db[nodeId].renameHistory = [];
            db[nodeId].renameHistory.push({
                oldTitle: oldTitle,
                newTitle: trimmedTitle,
                changedAt: moment().format("YYYY-MM-DD HH:mm:ss"),
                timestamp: Date.now()
            });
            db[nodeId].title = trimmedTitle;
        }

        db[nodeId].comment = textarea.value;
        db[nodeId].type = selectedType;

        // ä¿å­˜åˆ°æ–‡ä»¶ï¼ˆè‹¥ä¸å­˜åœ¨åˆ™è‡ªåŠ¨åˆ›å»ºï¼‰ï¼Œå¹¶åˆ·æ–°
        try {
            await saveJson(DB_PATH, db);
            new Notice(titleChanged ? "âœ… å·²ä¿å­˜ï¼Œåç§°å˜æ›´å·²è®°å½•" : "âœ… å·²ä¿å­˜");
            document.body.removeChild(modal);
            if (onSave) onSave(); else renderView();
        } catch (err) {
            console.error(err);
            new Notice("âŒ ä¿å­˜å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°");
        }
    };

    // å–æ¶ˆé€»è¾‘
    cancelBtn.onclick = () => document.body.removeChild(modal);

    // ç‚¹å‡»é®ç½©å±‚å…³é—­
    modal.onclick = (e) => {
        if (e.target === modal) document.body.removeChild(modal);
    };

    // æ˜¾ç¤ºå¼¹çª—
    document.body.appendChild(modal);
};

// --- 2. æ•°æ®å¤„ç† ---
const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2, 5);

const loadJson = async (path, defaultData) => {
    const normalized = normalizePathSafe(path);
    if (!await app.vault.adapter.exists(normalized)) {
        await app.vault.create(normalized, JSON.stringify(defaultData, null, 2));
        return defaultData;
    }
    try { return JSON.parse(await app.vault.adapter.read(normalized)); } catch (e) { return defaultData; }
};

// ä¿å­˜æ—¶å…œåº•åˆ›å»ºæ–‡ä»¶ï¼Œå¹¶ç»Ÿä¸€ä½¿ç”¨æ ‡å‡†åŒ–è·¯å¾„
const saveJson = async (path, data) => {
    const normalized = normalizePathSafe(path);
    const jsonString = JSON.stringify(data, null, 2);
    const file = app.vault.getAbstractFileByPath(normalized);
    if (file) await app.vault.modify(file, jsonString);
    else await app.vault.create(normalized, jsonString);
};

let db = await loadJson(DB_PATH, DEFAULT_DB);
let logs = await loadJson(LOG_PATH, DEFAULT_LOGS);
nodeTypes = mergeTypeConfigs(await loadJson(TYPE_PATH, DEFAULT_NODE_TYPES));
logs.sort((a, b) => {
    if (a.date !== b.date) return (b.date || "").localeCompare(a.date || "");
    if ((a.time || "") !== (b.time || "")) return (b.time || "").localeCompare(a.time || "");
    return (b.timestamp || 0) - (a.timestamp || 0);
});

// --- 2.1 æ•°æ®è¿ç§» ---
// ç¡®ä¿æ—§æ•°æ®æœ‰ type å’Œ comment å­—æ®µ
const migrateNode = (node) => {
    if (!node.type) node.type = 'default';
    if (!node.comment) node.comment = '';
    if (!Array.isArray(node.renameHistory)) node.renameHistory = [];
    return node;
};
Object.values(db).forEach(migrateNode);

// --- æ ¸å¿ƒé€»è¾‘ ---

const sortLogsByDate = () => {
    logs.sort((a, b) => {
        if (a.date !== b.date) return (b.date || "").localeCompare(a.date || "");
        if ((a.time || "") !== (b.time || "")) return (b.time || "").localeCompare(a.time || "");
        return (b.timestamp || 0) - (a.timestamp || 0);
    });
};

const openLogEditor = async (logId) => {
    await refreshDbFromDisk();
    const log = logs.find((l) => l.id === logId);
    if (!log) {
        new Notice("âŒ è®°å½•ä¸å­˜åœ¨");
        return;
    }

    const modal = document.createElement("div");
    modal.style.cssText = "position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:10001;";
    const content = modal.createEl("div");
    content.style.cssText = "background:var(--background-secondary);border-radius:12px;padding:20px;max-width:680px;width:94%;max-height:88vh;overflow-y:auto;";
    content.createEl("h3", { text: "âœï¸ ç¼–è¾‘è®°å½•", style: "margin: 0 0 12px 0;" });
    content.createEl("div", { text: `ç›®æ ‡ï¼š${getTimelineTargetText(log)}`, style: "color:var(--text-muted);margin-bottom:10px;" });

    const dateLabel = content.createEl("div", { text: "æ—¥æœŸ (YYYY-MM-DD)", style: "margin:6px 0;" });
    const dateInput = content.createEl("input", { type: "text", value: log.date || "" });
    dateInput.style.cssText = "width:100%;padding:8px 10px;border:1px solid var(--background-modifier-border);border-radius:6px;background:var(--background-primary);color:var(--text-normal);";

    const timeLabel = content.createEl("div", { text: "æ—¶é—´ (HH:mm)", style: "margin:12px 0 6px;" });
    const timeInput = content.createEl("input", { type: "text", value: log.time || moment().format("HH:mm") });
    timeInput.style.cssText = "width:100%;padding:8px 10px;border:1px solid var(--background-modifier-border);border-radius:6px;background:var(--background-primary);color:var(--text-normal);";

    const commentLabel = content.createEl("div", { text: "è®°å½•å†…å®¹", style: "margin:12px 0 6px;" });
    const commentInput = content.createEl("textarea");
    commentInput.style.cssText = "width:100%;min-height:220px;padding:10px 12px;border:1px solid var(--background-modifier-border);border-radius:6px;background:var(--background-primary);color:var(--text-normal);resize:vertical;line-height:1.6;";
    commentInput.value = log.comment || "";

    const btnRow = content.createEl("div", { style: "display:flex;gap:10px;justify-content:flex-end;margin-top:16px;" });
    const saveBtn = btnRow.createEl("button", { cls: "m-btn active", text: "ä¿å­˜ä¿®æ”¹" });
    const cancelBtn = btnRow.createEl("button", { cls: "m-btn", text: "å–æ¶ˆ" });

    saveBtn.onclick = async () => {
        const newDate = (dateInput.value || "").trim();
        const newTime = (timeInput.value || "").trim();
        const newComment = (commentInput.value || "").trim();
        if (!moment(newDate, "YYYY-MM-DD", true).isValid()) {
            new Notice("âŒ æ—¥æœŸæ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ YYYY-MM-DD");
            dateInput.focus();
            return;
        }
        if (!/^\d{2}:\d{2}$/.test(newTime)) {
            new Notice("âŒ æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ HH:mm");
            timeInput.focus();
            return;
        }

        log.date = newDate;
        log.time = newTime;
        log.comment = newComment || "âœ… å®Œæˆæ‰“å¡";
        log.editedAt = moment().format("YYYY-MM-DD HH:mm:ss");
        sortLogsByDate();
        await saveJson(LOG_PATH, logs);
        new Notice("âœ… è®°å½•å·²æ›´æ–°");
        document.body.removeChild(modal);
        renderView();
    };

    cancelBtn.onclick = () => document.body.removeChild(modal);
    modal.onclick = (e) => { if (e.target === modal) document.body.removeChild(modal); };
    document.body.appendChild(modal);
};

const addLog = async (targetId, targetTitle) => {
    const comment = await prompt(`æ‰“å¡: ${targetTitle}`, "è¯„ä»·/è®°å½•/æ„Ÿæƒ³ (ç•™ç©ºä»…æ‰“å¡)");
    if (comment === undefined) return;
    const defaultDate = moment().format("YYYY-MM-DD");
    const inputDate = await prompt("ç¡®è®¤æ—¥æœŸ", "YYYY-MM-DD", defaultDate);
    if (inputDate === undefined) return;

    const titleSnapshot = db[targetId]?.title || targetTitle || "æœªå‘½åç›®æ ‡";
    const newLog = {
        id: generateId(),
        targetId: targetId,
        targetTitle: titleSnapshot,
        targetPathAtLog: getPathName(targetId),
        date: inputDate,
        time: moment().format("HH:mm"),
        comment: comment || "âœ… å®Œæˆæ‰“å¡",
        timestamp: Date.now()
    };
    
    logs.push(newLog); 
    sortLogsByDate();

    await saveJson(LOG_PATH, logs);
    new Notice(`ğŸ“ å·²è®°å½•åˆ° ${inputDate}`);
    renderView();
};

const getAllDescendantIds = (rootId) => {
    let ids = [rootId]; 
    const node = db[rootId];
    if (!node) return ids;
    Object.values(node.children).forEach(childId => {
        if (childId && db[childId]) ids = ids.concat(getAllDescendantIds(childId));
    });
    return ids;
};

// ã€å…³é”®æ–°å¢ã€‘è·å–å®Œæ•´çš„è·¯å¾„åç§° (Breadcrumb)
// æ ¼å¼å¦‚ï¼šæ ¸å¿ƒç›®æ ‡ > è´¢åŠ¡ > å‚¨è“„
const getPathName = (targetId) => {
    if (!db[targetId]) return "å·²åˆ é™¤";
    if (targetId === "root") return db["root"].title;

    // å‘ä¸ŠæŸ¥æ‰¾çˆ¶èŠ‚ç‚¹ (æ•ˆç‡ä¼˜åŒ–ï¼šå› ä¸ºDBç»“æ„æ˜¯çˆ¶å­˜å­ï¼Œæ‰€ä»¥éœ€è¦å…¨åº“åæŸ¥)
    // åœ¨æ•°æ®é‡æå¤§æ—¶å¯èƒ½ç¨æ…¢ï¼Œä½†åœ¨ä¸ªäººçŸ¥è¯†åº“é‡çº§ä¸‹é€šå¸¸æ— æ„Ÿ
    let currentId = targetId;
    let pathStack = [db[targetId].title];
    
    // å®‰å…¨è®¡æ•°é˜²æ­¢æ­»å¾ªç¯
    let safety = 0;
    while (currentId !== "root" && safety < 50) {
        let parentFound = null;
        for (const [pId, node] of Object.entries(db)) {
            if (Object.values(node.children).includes(currentId)) {
                parentFound = pId;
                break;
            }
        }
        if (parentFound) {
            pathStack.unshift(db[parentFound].title);
            currentId = parentFound;
        } else {
            break; // æ‰¾ä¸åˆ°çˆ¶èŠ‚ç‚¹ï¼ˆä¹Ÿå°±æ˜¯æ–­é“¾äº†ï¼Œæˆ–è€…åˆ°è¾¾é¡¶å±‚ä½†é€»è¾‘æœªåŒ¹é…ï¼‰
        }
        safety++;
    }
    
    return pathStack.join(" > ");
};

const getCurrentTitleById = (targetId) => db[targetId]?.title || "å·²åˆ é™¤ç›®æ ‡";

const getTimelineTargetText = (log) => {
    const historicalTitle = (log.targetTitle || getCurrentTitleById(log.targetId) || "æœªå‘½åç›®æ ‡").trim();
    const currentTitle = getCurrentTitleById(log.targetId);
    if (currentTitle !== "å·²åˆ é™¤ç›®æ ‡" && historicalTitle !== currentTitle) {
        return `[${historicalTitle}]ï¼ˆç°åï¼š${currentTitle}ï¼‰`;
    }
    return `[${historicalTitle}]`;
};

const getTimelinePathText = (log) => log.targetPathAtLog || getPathName(log.targetId);

const getRecursiveLogCount = (targetId) => {
    const allIds = getAllDescendantIds(targetId);
    return logs.filter(l => allIds.includes(l.targetId)).length;
};

const getNoteImage = async (noteTitle) => {
    const file = app.metadataCache.getFirstLinkpathDest(noteTitle, dv.current().file.path);
    if (!file) return null; 
    const content = await app.vault.read(file);
    const internalMatch = content.match(/!\[\[(.*?)(?:\|.*?)?\]\]/);
    if (internalMatch) {
        const imgName = internalMatch[1];
        const imgFile = app.metadataCache.getFirstLinkpathDest(imgName, file.path);
        if (imgFile) return app.vault.getResourcePath(imgFile);
    }
    const externalMatch = content.match(/!\[.*?\]\((.*?)\)/);
    if (externalMatch) return externalMatch[1];
    return null;
};

const renameLinkedFile = async (oldName, newName) => {
    const currentFile = dv.current().file;
    const targetFile = app.metadataCache.getFirstLinkpathDest(oldName, currentFile.path);
    if (targetFile) {
        try {
            const parentPath = targetFile.parent.path;
            const newPath = parentPath === "/" ? `${newName}.md` : `${parentPath}/${newName}.md`;
            await app.fileManager.renameFile(targetFile, newPath);
            new Notice(`ğŸ“„ æ–‡ä»¶å·²æ›´å: ${newName}`);
        } catch (e) { console.error(e); }
    }
};

const setNodeTitle = async (id, oldTitle) => {
    const newTitle = await prompt("ä¿®æ”¹æ ‡é¢˜ (ä¿ç•™å†å²åç§°)", "è¯·è¾“å…¥åç§°...", oldTitle);
    const trimmedTitle = (newTitle || "").trim();
    if (!trimmedTitle || trimmedTitle === oldTitle) return;
    
    await renameLinkedFile(oldTitle, trimmedTitle);
    if (!Array.isArray(db[id].renameHistory)) db[id].renameHistory = [];
    db[id].renameHistory.push({
        oldTitle: oldTitle,
        newTitle: trimmedTitle,
        changedAt: moment().format("YYYY-MM-DD HH:mm:ss"),
        timestamp: Date.now()
    });
    db[id].title = trimmedTitle;
    await saveJson(DB_PATH, db);
    new Notice("âœï¸ åç§°å·²æ›´æ–°ï¼Œå†å²è®°å½•å·²ä¿ç•™");
    renderView();
};

const createSubNode = async (parentId, slotIndex) => {
    const title = await prompt("æ–°å»ºç›®æ ‡", "è¯·è¾“å…¥åç§°...");
    if (!title) return;
    const newId = generateId();
    db[newId] = {
        id: newId,
        title: title,
        type: 'default',
        comment: '',
        renameHistory: [],
        children: {}
    };
    db[parentId].children[slotIndex] = newId;
    await saveJson(DB_PATH, db);
    renderView();
};

const switchView = (viewName, targetId = null) => {
    window.mandalaState.view = viewName;
    if (targetId) window.mandalaState.detailTargetId = targetId;
    renderView();
};
const drillDown = (nodeId) => {
    window.mandalaState.history.push(window.mandalaState.currentId);
    window.mandalaState.currentId = nodeId;
    renderView();
};
const goBack = () => {
    if (window.mandalaState.history.length > 0) {
        window.mandalaState.currentId = window.mandalaState.history.pop();
        renderView();
    }
};

// --- 3. æ¸²æŸ“è§†å›¾ ---
const renderView = async () => {
    dv.container.innerHTML = "";
    
    const style = document.createElement('style');
    style.textContent = `
        .mandala-wrap { display: flex; flex-direction: column; align-items: center; width: 100%; font-family: sans-serif; }
        .top-bar { width: 100%; display: flex; justify-content: space-between; border-bottom: 2px solid var(--interactive-accent); padding: 5px 0 10px 0; margin-bottom: 15px; }
        .bar-left { display: flex; gap: 8px; }
        .m-btn { background: var(--background-primary); border: 1px solid var(--text-muted); color: var(--text-normal); padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 13px; }
        .m-btn.active { background: var(--interactive-accent); color: white; border-color: var(--interactive-accent); }

        .grid-container { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 8px; width: 100%; max-width: 450px; aspect-ratio: 1; }
        .grid-cell {
            position: relative; background: var(--background-secondary); border-radius: 6px;
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            overflow: hidden; cursor: pointer; transition: transform 0.2s;
            background-size: cover; background-position: center;
        }
        .grid-cell:hover { transform: scale(1.02); z-index: 2; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .cell-has-img { background-size: contain !important; background-repeat: no-repeat !important; background-color: #1e1e1e; }
        .cell-title-bar {
            width: 100%; background: rgba(0,0,0,0.7); color: white; padding: 4px;
            font-size: 0.85em; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .cell-empty { justify-content: center; color: var(--text-faint); border: 1px dashed var(--text-muted); background: transparent; }
        .badge { position: absolute; top: 4px; left: 4px; background: var(--interactive-accent); color: white; font-size: 10px; padding: 1px 5px; border-radius: 8px; z-index: 10; opacity: 0.9; }

        .action-overlay { position: absolute; top: 0; right: 0; padding: 4px; display: flex; gap: 4px; opacity: 0; transition: opacity 0.2s; z-index: 20; }
        .grid-cell:hover .action-overlay { opacity: 1; }
        .icon-btn { background: rgba(0,0,0,0.6); color: white; width: 22px; height: 22px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .icon-btn:hover { background: var(--interactive-accent); }

        /* ç±»å‹æŒ‡ç¤ºå™¨ */
        .type-indicator {
            position: absolute; top: 4px; right: 30px; width: 10px; height: 10px; border-radius: 50%; z-index: 10;
        }

        /* Modalæ ·å¼ */
        .type-option:hover { background: var(--background-secondary); }

        /* èŠ‚ç‚¹è¯¦æƒ…Modalç¾åŒ– */
        .modal-stats { display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; }
        .modal-stats div { font-size: 0.95em; }
        .type-selector { padding: 10px; background: var(--background-secondary); border-radius: 8px; }
        .type-option { background: var(--background-primary); border: 1px solid var(--background-modifier-border) !important; transition: all 0.2s; }
        .type-option:hover { border-color: var(--interactive-accent) !important; transform: translateY(-1px); }
        .type-option:has(input:checked) { border-color: var(--interactive-accent) !important; background: var(--background-modifier-form-field); }
        .modal-btn-row button { padding: 8px 20px; border-radius: 6px; font-size: 14px; }
        .modal-textarea:focus { outline: none; border-color: var(--interactive-accent) !important; box-shadow: 0 0 0 2px var(--interactive-accent-35); }

        .timeline-container { width: 100%; max-width: 600px; }
        .tl-item { display: flex; gap: 10px; padding: 10px 0; border-left: 2px solid var(--background-modifier-border); margin-left: 10px; padding-left: 15px; position: relative; }
        .tl-item::before { content: ''; position: absolute; left: -6px; top: 15px; width: 10px; height: 10px; border-radius: 50%; background: var(--interactive-accent); }
        .tl-date { font-family: monospace; color: var(--text-muted); font-size: 0.9em; min-width: 80px; }
        .tl-content { flex: 1; display:flex; flex-direction:column; gap:2px; }
        .tl-target { font-weight: bold; color: var(--text-normal); cursor: pointer; font-size: 0.9em; color: var(--text-accent); }
        .tl-target:hover { text-decoration: underline; }
        .tl-path { font-size: 0.8em; color: var(--text-muted); opacity: 0.8; margin-bottom: 2px; }
        .tl-comment { color: var(--text-normal); font-size: 0.95em;}
        .tl-actions { display: flex; gap: 8px; margin-top: 6px; }
        .tl-edit-btn { padding: 2px 8px; font-size: 12px; }

        .detail-header { text-align: center; margin-bottom: 20px; padding: 20px; background: var(--background-secondary); border-radius: 8px; width: 100%; max-width: 600px; }
        .stat-box { display: flex; gap: 20px; justify-content: center; margin-top: 10px; }
        .stat-num { font-size: 1.5em; font-weight: bold; color: var(--interactive-accent); }

        .type-filter-bar { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; width: 100%; max-width: 900px; }
        .type-filter-select {
            min-width: 220px; padding: 6px 10px; border-radius: 6px; border: 1px solid var(--background-modifier-border);
            background: var(--background-primary); color: var(--text-normal);
        }
        .node-list { width: 100%; max-width: 900px; display: grid; gap: 10px; }
        .node-item {
            display: flex; align-items: center; justify-content: space-between; gap: 12px;
            padding: 10px 12px; background: var(--background-secondary); border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
        }
        .node-meta { display: flex; flex-direction: column; gap: 4px; min-width: 0; }
        .node-title { font-weight: 600; color: var(--text-normal); }
        .node-path { font-size: 0.85em; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 620px; }
        .node-type-chip {
            display: inline-flex; align-items: center; gap: 6px; padding: 2px 8px; border-radius: 999px;
            font-size: 0.8em; color: #fff; width: fit-content;
        }
        .node-actions { display: flex; gap: 8px; }

        .type-admin-wrap { width: 100%; max-width: 980px; display: flex; flex-direction: column; gap: 14px; }
        .type-admin-row {
            display: grid; grid-template-columns: 170px 160px 90px 170px 120px 120px;
            gap: 10px; align-items: center;
            padding: 10px 12px; background: var(--background-secondary);
            border: 1px solid var(--background-modifier-border); border-radius: 8px;
        }
        .type-admin-row input { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid var(--background-modifier-border); background: var(--background-primary); color: var(--text-normal); }
        .type-admin-row .type-id { font-family: monospace; color: var(--text-muted); }
        .type-admin-create {
            display: grid; grid-template-columns: 1fr 140px 170px 120px; gap: 10px; align-items: center;
            padding: 12px; background: var(--background-secondary); border-radius: 8px; width: 100%;
        }
        .type-admin-create input { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid var(--background-modifier-border); background: var(--background-primary); color: var(--text-normal); }
        .type-color-input-wrap { display: flex; align-items: center; gap: 8px; min-width: 0; }
        .type-color-input-wrap input[type="color"] {
            width: 44px; height: 32px; padding: 2px; border-radius: 6px;
            border: 1px solid var(--background-modifier-border); cursor: pointer;
            background: var(--background-primary);
        }
        .type-color-preview {
            width: 22px; height: 22px; border-radius: 6px;
            border: 1px solid var(--background-modifier-border);
            flex: 0 0 auto;
        }
    `;
    dv.container.appendChild(style);
    
    const wrap = dv.el("div", "", { cls: "mandala-wrap" });

    const topBar = wrap.createEl("div", { cls: "top-bar" });
    const barLeft = topBar.createEl("div", { cls: "bar-left" });
    const barRight = topBar.createEl("div", { cls: "bar-right" });

    const btnGrid = barLeft.createEl("button", { text: "ğŸ•¸ï¸ ä¹å®«æ ¼", cls: `m-btn ${window.mandalaState.view === 'grid' ? 'active' : ''}` });
    btnGrid.onclick = () => switchView("grid");
    const btnFilter = barLeft.createEl("button", { text: "ğŸ” ç±»å‹ç­›é€‰", cls: `m-btn ${window.mandalaState.view === 'type-filter' ? 'active' : ''}` });
    btnFilter.onclick = () => switchView("type-filter");
    const btnTimeline = barLeft.createEl("button", { text: "â³ æ—¶é—´è½´", cls: `m-btn ${window.mandalaState.view === 'timeline' ? 'active' : ''}` });
    btnTimeline.onclick = () => switchView("timeline");
    const btnTypeManage = barLeft.createEl("button", { text: "ğŸ§© ç±»å‹ç®¡ç†", cls: `m-btn ${window.mandalaState.view === 'type-manage' ? 'active' : ''}` });
    btnTypeManage.onclick = () => switchView("type-manage");

    if (window.mandalaState.view === "grid") {
        if (window.mandalaState.history.length > 0) {
            const backBtn = barRight.createEl("button", { text: "â¬…ï¸ ä¸Šä¸€çº§", cls: "m-btn" });
            backBtn.onclick = goBack;
        }
        
        if (!db[window.mandalaState.currentId]) window.mandalaState.currentId = "root";
        const currentNode = db[window.mandalaState.currentId];
        
        wrap.createEl("h4", { text: `å½“å‰èšç„¦: ${currentNode.title}`, style: "margin: 0 0 10px 0; opacity: 0.8;" });
        const gridDiv = wrap.createEl("div", { cls: "grid-container" });

        for (let i = 0; i < 9; i++) {
            const cell = gridDiv.createEl("div", { cls: "grid-cell" });

            const renderCellContent = async (node, isCore) => {
                const nodeType = node.type || 'default';
                const typeConfig = getTypeConfig(nodeType);
                if (!isCore) cell.style.border = `2px solid ${typeConfig.color}`;

                // æ ¸å¿ƒèŠ‚ç‚¹ä½¿ç”¨å¼ºè°ƒè¾¹æ¡†
                if (isCore) cell.style.border = "2px solid var(--interactive-accent)";

                const bgUrl = await getNoteImage(node.title);
                if (bgUrl) { cell.style.backgroundImage = `url("${bgUrl}")`; cell.classList.add("cell-has-img"); }

                // ç±»å‹æŒ‡ç¤ºå™¨ï¼ˆéé»˜è®¤ç±»å‹æ˜¾ç¤ºï¼‰
                if (nodeType !== 'default') {
                    const indicator = cell.createEl("div", { cls: "type-indicator", title: `${typeConfig.icon} ${typeConfig.name}` });
                    indicator.style.background = typeConfig.color;
                }

                const count = getRecursiveLogCount(node.id);
                if (count > 0) cell.createEl("div", { text: `${count}`, cls: "badge", title: "å­ç›®æ ‡ç´¯è®¡è®°å½•" });

                cell.createDiv({ text: node.title, cls: "cell-title-bar" });

                const overlay = cell.createEl("div", { cls: "action-overlay" });
                const detailBtn = overlay.createEl("div", { text: "ğŸ“‹", cls: "icon-btn", title: "èŠ‚ç‚¹è¯¦æƒ…" });
                detailBtn.onclick = async (e) => { e.stopPropagation(); await openNodeDetail(node.id); };
                const historyBtn = overlay.createEl("div", { text: "ğŸ“œ", cls: "icon-btn", title: "æŸ¥çœ‹å†å²(å«å­ç›®æ ‡)" });
                historyBtn.onclick = (e) => { e.stopPropagation(); switchView("detail", node.id); };
                const logBtn = overlay.createEl("div", { text: "âœ…", cls: "icon-btn", title: "è®°å½•è¯„ä»·" });
                logBtn.onclick = (e) => { e.stopPropagation(); addLog(node.id, node.title); };
            };

            if (i === 4) {
                await renderCellContent(currentNode, true);
                cell.onclick = () => app.workspace.openLinkText(currentNode.title, dv.current().file.path);
            } else {
                const childId = currentNode.children[i];
                if (childId && db[childId]) {
                    await renderCellContent(db[childId], false);
                    cell.onclick = () => drillDown(childId);
                } else {
                    cell.classList.add("cell-empty");
                    cell.innerText = "+";
                    cell.onclick = () => createSubNode(currentNode.id, i);
                }
            }
        }
    }

    else if (window.mandalaState.view === "type-filter") {
        wrap.createEl("h3", { text: "ğŸ” æŒ‰ç±»å‹ç­›é€‰èŠ‚ç‚¹" });
        const filterBar = wrap.createEl("div", { cls: "type-filter-bar" });
        filterBar.createEl("span", { text: "ç±»å‹ï¼š" });
        const typeSelect = filterBar.createEl("select", { cls: "type-filter-select" });
        const allOption = typeSelect.createEl("option", { text: "å…¨éƒ¨ç±»å‹", value: "all" });
        allOption.selected = (window.mandalaState.typeFilter || "all") === "all";

        Object.entries(nodeTypes).forEach(([typeId, cfg]) => {
            const usage = getTypeUsageCount(typeId);
            const option = typeSelect.createEl("option", { text: `${cfg.icon} ${cfg.name} (${usage})`, value: typeId });
            option.selected = window.mandalaState.typeFilter === typeId;
        });
        typeSelect.onchange = () => {
            window.mandalaState.typeFilter = typeSelect.value || "all";
            renderView();
        };

        const list = wrap.createEl("div", { cls: "node-list" });
        const activeFilter = window.mandalaState.typeFilter || "all";
        const nodePathMap = {};
        const getNodePath = (nodeId) => {
            if (!nodePathMap[nodeId]) nodePathMap[nodeId] = getPathName(nodeId);
            return nodePathMap[nodeId];
        };
        const getPathSortKey = (nodeId) => getNodePath(nodeId).replace(/\s*>\s*/g, ">");
        const nodes = Object.values(db)
            .filter(n => n && n.id !== "root")
            .filter(n => activeFilter === "all" ? true : (n.type || "default") === activeFilter)
            .sort((a, b) => {
                const byPath = getPathSortKey(a.id).localeCompare(getPathSortKey(b.id), "zh", { numeric: true, sensitivity: "base" });
                if (byPath !== 0) return byPath;
                return (a.title || "").localeCompare(b.title || "", "zh", { numeric: true, sensitivity: "base" });
            });

        if (nodes.length === 0) {
            list.createEl("div", { text: "è¯¥ç±»å‹ä¸‹æš‚æ— èŠ‚ç‚¹", style: "color:var(--text-muted); padding:14px;" });
        }

        nodes.forEach((node) => {
            const nodeType = node.type || "default";
            const cfg = getTypeConfig(nodeType);
            const nodePath = getNodePath(node.id);
            const item = list.createEl("div", { cls: "node-item", title: `è·¯å¾„: ${nodePath}` });

            const meta = item.createEl("div", { cls: "node-meta" });
            const chip = meta.createEl("div", { cls: "node-type-chip", text: `${cfg.icon} ${cfg.name}` });
            chip.style.background = cfg.color;
            meta.createEl("div", { cls: "node-title", text: node.title || "æœªå‘½åç›®æ ‡" });
            meta.createEl("div", { cls: "node-path", text: nodePath });

            const actions = item.createEl("div", { cls: "node-actions" });
            const detailBtn = actions.createEl("button", { cls: "m-btn", text: "è¯¦æƒ…" });
            detailBtn.onclick = () => switchView("detail", node.id);
            const editBtn = actions.createEl("button", { cls: "m-btn", text: "ç¼–è¾‘" });
            editBtn.onclick = async () => openNodeDetail(node.id);
        });
    }

    else if (window.mandalaState.view === "type-manage") {
        wrap.createEl("h3", { text: "ğŸ§© ç±»å‹ç®¡ç†" });
        const adminWrap = wrap.createEl("div", { cls: "type-admin-wrap" });
        adminWrap.createEl("div", { text: "å¯ç¼–è¾‘ç±»å‹åç§°ã€emojiã€é¢œè‰²ã€‚æ–°å¢ç±»å‹åå¯åœ¨èŠ‚ç‚¹è¯¦æƒ…ä¸­ç›´æ¥é€‰æ‹©ã€‚", style: "color:var(--text-muted);" });

        const createRow = adminWrap.createEl("div", { cls: "type-admin-create" });
        const newTypeName = createRow.createEl("input", { placeholder: "æ–°ç±»å‹åç§°ï¼ˆä¾‹å¦‚ï¼šå…³é”®ç»“æœï¼‰" });
        const newTypeIcon = createRow.createEl("input", { placeholder: "emoji", value: "ğŸ·ï¸" });
        const newTypeColorWrap = createRow.createEl("div", { cls: "type-color-input-wrap" });
        const newTypeColor = newTypeColorWrap.createEl("input", { type: "color", value: "#3b82f6", title: "é€‰æ‹©ç±»å‹é¢œè‰²" });
        const newTypeColorPreview = newTypeColorWrap.createEl("span", { cls: "type-color-preview" });
        const syncNewTypeColorPreview = () => {
            const normalized = safeHexColor(newTypeColor.value, "#3b82f6");
            newTypeColor.value = normalized;
            newTypeColorPreview.style.background = normalized;
        };
        syncNewTypeColorPreview();
        newTypeColor.oninput = syncNewTypeColorPreview;
        const addTypeBtn = createRow.createEl("button", { cls: "m-btn active", text: "æ–°å¢ç±»å‹" });
        addTypeBtn.onclick = async () => {
            const name = (newTypeName.value || "").trim();
            if (!name) return new Notice("âŒ è¯·è¾“å…¥ç±»å‹åç§°");
            const typeId = ensureUniqueTypeId(toTypeId(name), nodeTypes);
            nodeTypes[typeId] = {
                name,
                icon: (newTypeIcon.value || "ğŸ·ï¸").trim() || "ğŸ·ï¸",
                color: safeHexColor(newTypeColor.value, "#3b82f6")
            };
            await persistTypeConfigs();
            new Notice(`âœ… å·²æ–°å¢ç±»å‹: ${name}`);
            renderView();
        };

        Object.entries(nodeTypes).forEach(([typeId, cfg]) => {
            const row = adminWrap.createEl("div", { cls: "type-admin-row" });
            row.createEl("div", { cls: "type-id", text: typeId });

            const nameInput = row.createEl("input", { value: cfg.name || typeId });
            const iconInput = row.createEl("input", { value: cfg.icon || "ğŸ·ï¸" });
            const colorWrap = row.createEl("div", { cls: "type-color-input-wrap" });
            const colorInput = colorWrap.createEl("input", {
                type: "color",
                value: safeHexColor(cfg.color, "#9ca3af"),
                title: "é€‰æ‹©ç±»å‹é¢œè‰²"
            });
            const colorPreview = colorWrap.createEl("span", { cls: "type-color-preview" });
            const syncColorPreview = () => {
                const normalized = safeHexColor(colorInput.value, "#9ca3af");
                colorInput.value = normalized;
                colorPreview.style.background = normalized;
            };
            syncColorPreview();
            colorInput.oninput = syncColorPreview;
            const usage = row.createEl("div", { text: `ä½¿ç”¨ä¸­: ${getTypeUsageCount(typeId)}` });
            usage.style.color = "var(--text-muted)";

            const actionWrap = row.createEl("div", { style: "display:flex; gap:8px;" });
            const saveBtn = actionWrap.createEl("button", { cls: "m-btn", text: "ä¿å­˜" });
            saveBtn.onclick = async () => {
                const newName = (nameInput.value || "").trim();
                if (!newName) return new Notice("âŒ ç±»å‹åç§°ä¸èƒ½ä¸ºç©º");
                nodeTypes[typeId] = {
                    name: newName,
                    icon: (iconInput.value || "ğŸ·ï¸").trim() || "ğŸ·ï¸",
                    color: safeHexColor(colorInput.value, cfg.color || "#9ca3af")
                };
                await persistTypeConfigs();
                new Notice(`âœ… å·²æ›´æ–°ç±»å‹: ${newName}`);
                renderView();
            };

            const delBtn = actionWrap.createEl("button", { cls: "m-btn", text: "åˆ é™¤" });
            const isDefault = !!DEFAULT_NODE_TYPES[typeId];
            if (isDefault) {
                delBtn.disabled = true;
                delBtn.title = "é»˜è®¤ç±»å‹ä¸å¯åˆ é™¤";
            } else {
                delBtn.onclick = async () => {
                    if (!confirm(`ç¡®å®šåˆ é™¤ç±»å‹ã€Œ${cfg.name}ã€å—ï¼Ÿæ­¤ç±»å‹èŠ‚ç‚¹å°†å›é€€ä¸ºâ€œæ™®é€šâ€ã€‚`)) return;
                    Object.values(db).forEach((node) => {
                        if ((node.type || "default") === typeId) node.type = "default";
                    });
                    delete nodeTypes[typeId];
                    await persistTypeConfigs();
                    await saveJson(DB_PATH, db);
                    new Notice("ğŸ—‘ï¸ ç±»å‹å·²åˆ é™¤ï¼Œç›¸å…³èŠ‚ç‚¹å·²å›é€€ä¸ºæ™®é€š");
                    renderView();
                };
            }
        });
    }

    else if (window.mandalaState.view === "timeline") {
        wrap.createEl("h3", { text: "â³ å…¨å±€è¡ŒåŠ¨è®°å½•" });
        const tlContainer = wrap.createEl("div", { cls: "timeline-container" });
        if (logs.length === 0) tlContainer.createDiv({ text: "æš‚æ— è®°å½•", style: "color:var(--text-muted); padding:20px;" });

        logs.forEach(log => {
            const item = tlContainer.createEl("div", { cls: "tl-item" });
            item.createEl("div", { text: `${log.date}${log.time ? ` ${log.time}` : ""}`, cls: "tl-date" });
            const content = item.createEl("div", { cls: "tl-content" });
            
            // ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ˜¾ç¤ºå®Œæ•´è·¯å¾„
            const fullPath = getTimelinePathText(log);
            content.createEl("div", { text: fullPath, cls: "tl-path" });
            
            // æ˜¾ç¤ºå…·ä½“çš„æ‰“å¡ç›®æ ‡ï¼Œç‚¹å‡»å¯è·³è½¬è¯¦æƒ…
            const targetLink = content.createEl("div", { text: getTimelineTargetText(log), cls: "tl-target" });
            targetLink.onclick = () => switchView("detail", log.targetId);
            
            content.createEl("span", { text: log.comment, cls: "tl-comment" });
            const actionRow = content.createEl("div", { cls: "tl-actions" });
            const editBtn = actionRow.createEl("button", { text: "âœï¸ ç¼–è¾‘", cls: "m-btn tl-edit-btn" });
            editBtn.onclick = () => openLogEditor(log.id);
        });
    }

    else if (window.mandalaState.view === "detail") {
        const targetId = window.mandalaState.detailTargetId;
        const targetName = db[targetId] ? db[targetId].title : "å·²åˆ é™¤ç›®æ ‡";
        const targetPath = getPathName(targetId); // è¯¦æƒ…é¡µä¹Ÿæ˜¾ç¤ºä¸€ä¸‹è·¯å¾„

        const allDescendantIds = getAllDescendantIds(targetId);
        const relatedLogs = logs.filter(l => allDescendantIds.includes(l.targetId));
        
        const header = wrap.createEl("div", { cls: "detail-header" });
        // æ˜¾ç¤ºè·¯å¾„é¢åŒ…å±‘
        header.createEl("div", { text: targetPath, style: "font-size:0.8em; color:var(--text-muted); margin-bottom:5px;" });
        header.createEl("h2", { text: targetName, style: "margin:0;" });
        const statBox = header.createEl("div", { cls: "stat-box" });
        
        statBox.createEl("div", { cls: "stat-item" }).innerHTML = `<div class="stat-num">${relatedLogs.length}</div><div>æ€»è®°å½•(å«å­ç›®æ ‡)</div>`;
        const lastDate = relatedLogs.length > 0 ? relatedLogs[0].date : "æ— ";
        statBox.createEl("div", { cls: "stat-item" }).innerHTML = `<div class="stat-num" style="font-size:1.2em; line-height:1.5;">${lastDate}</div><div>æœ€è¿‘æ›´æ–°</div>`;

        const btnRow = wrap.createEl("div", { style: "display:flex; gap:10px; margin-bottom:20px;" });
        const backBtn = btnRow.createEl("button", { text: "ğŸ”™ è¿”å›ä¹å®«æ ¼", cls: "m-btn" });
        backBtn.onclick = () => switchView("grid");
        const logBtn = btnRow.createEl("button", { text: "âœ… æ–°å¢å½“å‰è®°å½•", cls: "m-btn active" });
        logBtn.onclick = () => addLog(targetId, targetName);

        const tlContainer = wrap.createEl("div", { cls: "timeline-container" });
        
        if (relatedLogs.length === 0) tlContainer.createDiv({ text: "è¯¥ç›®æ ‡åŠå…¶å­ç›®æ ‡æš‚æ— ä»»ä½•è®°å½•", style: "color:var(--text-muted); font-style:italic;" });

        relatedLogs.forEach(log => {
            const item = tlContainer.createEl("div", { cls: "tl-item" });
            item.createEl("div", { text: `${log.date}${log.time ? ` ${log.time}` : ""}`, cls: "tl-date" });
            const content = item.createEl("div", { cls: "tl-content" });
            const targetLink = content.createEl("div", { text: getTimelineTargetText(log), cls: "tl-target" });
            targetLink.onclick = () => switchView("detail", log.targetId);
            
            // å¦‚æœæ˜¯å­ç›®æ ‡çš„æ—¥å¿—ï¼Œæ˜¾ç¤ºå®ƒçš„æ¥æºè·¯å¾„ï¼ˆåªæ˜¾ç¤ºç›¸å¯¹äºå½“å‰èŠ‚ç‚¹çš„å·®å¼‚è·¯å¾„ï¼‰
            if (log.targetId !== targetId) {
                // è¿™é‡Œçš„è·¯å¾„å¯ä»¥æ˜¯å…¨è·¯å¾„ï¼Œä¹Ÿå¯ä»¥ä¼˜åŒ–æ˜¾ç¤º
                // ä¸ºäº†æ¸…æ™°ï¼Œè¿™é‡Œç›´æ¥å±•ç¤ºå®ƒçš„å…¨è·¯å¾„ï¼Œæ ‡æ˜ "â†³"
                const subPath = getTimelinePathText(log);
                content.createEl("div", { text: `â†³ ${subPath}`, cls: "tl-path", style: "color:var(--text-accent);" });
            }
            
            content.createEl("span", { text: log.comment, cls: "tl-comment" });
            const actionRow = content.createEl("div", { cls: "tl-actions" });
            const editBtn = actionRow.createEl("button", { text: "âœï¸ ç¼–è¾‘", cls: "m-btn tl-edit-btn" });
            editBtn.onclick = () => openLogEditor(log.id);
        });
    }
};

renderView();

```
